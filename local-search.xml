<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>慕ke体系-AI人工智能算法工程师</title>
    <link href="/2024/05/29/%E6%85%95ke%E4%BD%93%E7%B3%BB-AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2024/05/29/%E6%85%95ke%E4%BD%93%E7%B3%BB-AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-深度卷积神经网络（Deep-CNN）"><a href="#1-深度卷积神经网络（Deep-CNN）" class="headerlink" title="1. 深度卷积神经网络（Deep CNN）"></a>1. 深度卷积神经网络（Deep CNN）</h2><p>深度卷积神经网络通过增加更多的卷积层和池化层来捕捉更多的图像特征，从而提高图像分类的准确率。以下是一个使用VGG16模型的示例，该模型在ImageNet挑战中表现优异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.applications <span class="hljs-keyword">import</span> VGG16<br><span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers, models<br><br><span class="hljs-comment"># 加载预训练的VGG16模型</span><br>vgg16_base = VGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>, input_shape=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 冻结卷积基</span><br>vgg16_base.trainable = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 构建模型</span><br>model = models.Sequential()<br>model.add(vgg16_base)<br>model.add(layers.Flatten())<br>model.add(layers.Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br><br><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,<br>              loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>,<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 数据预处理</span><br>train_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br>validation_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br><br>train_generator = train_datagen.flow_from_directory(<br>    <span class="hljs-string">&#x27;data/train&#x27;</span>,<br>    target_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>),<br>    batch_size=<span class="hljs-number">20</span>,<br>    class_mode=<span class="hljs-string">&#x27;binary&#x27;</span>)<br><br>validation_generator = validation_datagen.flow_from_directory(<br>    <span class="hljs-string">&#x27;data/validation&#x27;</span>,<br>    target_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>),<br>    batch_size=<span class="hljs-number">20</span>,<br>    class_mode=<span class="hljs-string">&#x27;binary&#x27;</span>)<br><br><span class="hljs-comment"># 训练模型</span><br>history = model.fit(<br>    train_generator,<br>    steps_per_epoch=<span class="hljs-number">100</span>,<br>    epochs=<span class="hljs-number">30</span>,<br>    validation_data=validation_generator,<br>    validation_steps=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><h2 id="2-长短期记忆网络（LSTM）"><a href="#2-长短期记忆网络（LSTM）" class="headerlink" title="2. 长短期记忆网络（LSTM）"></a>2. 长短期记忆网络（LSTM）</h2><p>LSTM是RNN的一种变体，擅长处理长时间依赖问题。以下是一个改进版的LSTM实现，用于文本生成任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Embedding, LSTM, Dense<br><span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.text <span class="hljs-keyword">import</span> Tokenizer<br><span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="hljs-keyword">import</span> pad_sequences<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 文本数据</span><br>data = <span class="hljs-string">&quot;&quot;&quot;Your text data here&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 文本预处理</span><br>tokenizer = Tokenizer()<br>tokenizer.fit_on_texts([data])<br>total_words = <span class="hljs-built_in">len</span>(tokenizer.word_index) + <span class="hljs-number">1</span><br><br>input_sequences = []<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data.split(<span class="hljs-string">&#x27;\n&#x27;</span>):<br>    token_list = tokenizer.texts_to_sequences([line])[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(token_list)):<br>        n_gram_sequence = token_list[:i+<span class="hljs-number">1</span>]<br>        input_sequences.append(n_gram_sequence)<br><br><span class="hljs-comment"># 填充序列</span><br>max_sequence_len = <span class="hljs-built_in">max</span>([<span class="hljs-built_in">len</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_sequences])<br>input_sequences = np.array(pad_sequences(input_sequences, maxlen=max_sequence_len, padding=<span class="hljs-string">&#x27;pre&#x27;</span>))<br><br><span class="hljs-comment"># 创建预测变量</span><br>xs, labels = input_sequences[:,:-<span class="hljs-number">1</span>],input_sequences[:,-<span class="hljs-number">1</span>]<br>ys = tf.keras.utils.to_categorical(labels, num_classes=total_words)<br><br><span class="hljs-comment"># 构建模型</span><br>model = tf.keras.Sequential()<br>model.add(Embedding(total_words, <span class="hljs-number">100</span>, input_length=max_sequence_len-<span class="hljs-number">1</span>))<br>model.add(LSTM(<span class="hljs-number">150</span>))<br>model.add(Dense(total_words, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br><br><span class="hljs-comment"># 编译模型</span><br>model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><br><span class="hljs-comment"># 训练模型</span><br>history = model.fit(xs, ys, epochs=<span class="hljs-number">100</span>, verbose=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 文本生成</span><br>seed_text = <span class="hljs-string">&quot;Your seed text&quot;</span><br>next_words = <span class="hljs-number">50</span><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(next_words):<br>    token_list = tokenizer.texts_to_sequences([seed_text])[<span class="hljs-number">0</span>]<br>    token_list = pad_sequences([token_list], maxlen=max_sequence_len-<span class="hljs-number">1</span>, padding=<span class="hljs-string">&#x27;pre&#x27;</span>)<br>    predicted = np.argmax(model.predict(token_list, verbose=<span class="hljs-number">0</span>), axis=-<span class="hljs-number">1</span>)<br>    output_word = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> word, index <span class="hljs-keyword">in</span> tokenizer.word_index.items():<br>        <span class="hljs-keyword">if</span> index == predicted:<br>            output_word = word<br>            <span class="hljs-keyword">break</span><br>    seed_text += <span class="hljs-string">&quot; &quot;</span> + output_word<br><span class="hljs-built_in">print</span>(seed_text)<br></code></pre></td></tr></table></figure><h2 id="3-注意力机制和Transformer模型"><a href="#3-注意力机制和Transformer模型" class="headerlink" title="3. 注意力机制和Transformer模型"></a>3. 注意力机制和Transformer模型</h2><p>Transformer模型引入了注意力机制，在自然语言处理任务中表现出色。以下是一个简单的Transformer实现，用于机器翻译任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense, LayerNormalization, Embedding, MultiHeadAttention, Dropout<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Model<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerBlock</span>(tf.keras.layers.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, embed_dim, num_heads, ff_dim, rate=<span class="hljs-number">0.1</span></span>):<br>        <span class="hljs-built_in">super</span>(TransformerBlock, self).__init__()<br>        self.att = MultiHeadAttention(num_heads=num_heads, key_dim=embed_dim)<br>        self.ffn = tf.keras.Sequential(<br>            [Dense(ff_dim, activation=<span class="hljs-string">&quot;relu&quot;</span>), Dense(embed_dim),]<br>        )<br>        self.layernorm1 = LayerNormalization(epsilon=<span class="hljs-number">1e-6</span>)<br>        self.layernorm2 = LayerNormalization(epsilon=<span class="hljs-number">1e-6</span>)<br>        self.dropout1 = Dropout(rate)<br>        self.dropout2 = Dropout(rate)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, inputs, training</span>):<br>        attn_output = self.att(inputs, inputs)<br>        attn_output = self.dropout1(attn_output, training=training)<br>        out1 = self.layernorm1(inputs + attn_output)<br>        ffn_output = self.ffn(out1)<br>        ffn_output = self.dropout2(ffn_output, training=training)<br>        <span class="hljs-keyword">return</span> self.layernorm2(out1 + ffn_output)<br><br><span class="hljs-comment"># 创建Transformer模型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenAndPositionEmbedding</span>(tf.keras.layers.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, maxlen, vocab_size, embed_dim</span>):<br>        <span class="hljs-built_in">super</span>(TokenAndPositionEmbedding, self).__init__()<br>        self.token_emb = Embedding(input_dim=vocab_size, output_dim=embed_dim)<br>        self.pos_emb = Embedding(input_dim=maxlen, output_dim=embed_dim)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, x</span>):<br>        maxlen = tf.shape(x)[-<span class="hljs-number">1</span>]<br>        positions = tf.<span class="hljs-built_in">range</span>(start=<span class="hljs-number">0</span>, limit=maxlen, delta=<span class="hljs-number">1</span>)<br>        positions = self.pos_emb(positions)<br>        x = self.token_emb(x)<br>        <span class="hljs-keyword">return</span> x + positions<br><br>vocab_size = <span class="hljs-number">20000</span>  <span class="hljs-comment"># 词汇表大小</span><br>maxlen = <span class="hljs-number">200</span>  <span class="hljs-comment"># 序列最大长度</span><br>embed_dim = <span class="hljs-number">32</span>  <span class="hljs-comment"># 嵌入维度</span><br>num_heads = <span class="hljs-number">2</span>  <span class="hljs-comment"># 注意力头数量</span><br>ff_dim = <span class="hljs-number">32</span>  <span class="hljs-comment"># 前馈网络维度</span><br><br>inputs = tf.keras.Input(shape=(maxlen,))<br>embedding_layer = TokenAndPositionEmbedding(maxlen, vocab_size, embed_dim)<br>x = embedding_layer(inputs)<br>transformer_block = TransformerBlock(embed_dim, num_heads, ff_dim)<br>x = transformer_block(x)<br>x = tf.keras.layers.GlobalAveragePooling1D()(x)<br>x = tf.keras.layers.Dropout(<span class="hljs-number">0.1</span>)(x)<br>x = tf.keras.layers.Dense(<span class="hljs-number">20</span>, activation=<span class="hljs-string">&quot;relu&quot;</span>)(x)<br>x = tf.keras.layers.Dropout(<span class="hljs-number">0.1</span>)(x)<br>outputs = tf.keras.layers.Dense(<span class="hljs-number">2</span>, activation=<span class="hljs-string">&quot;softmax&quot;</span>)(x)<br><br>model = Model(inputs=inputs, outputs=outputs)<br><br><span class="hljs-comment"># 编译和训练模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&quot;adam&quot;</span>, loss=<span class="hljs-string">&quot;sparse_categorical_crossentropy&quot;</span>, metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>])<br></code></pre></td></tr></table></figure><h2 id="4-自编码器（Autoencoder）"><a href="#4-自编码器（Autoencoder）" class="headerlink" title="4. 自编码器（Autoencoder）"></a>4. 自编码器（Autoencoder）</h2><p>自编码器用于无监督学习，尤其是在数据降维和特征提取方面。以下是一个简单的自编码器实现示例，用于图像去噪。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers, models<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 构建自编码器模型</span><br>input_img = tf.keras.Input(shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 编码器</span><br>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(input_img)<br>x = layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<br>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<br>encoded = layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<br><br><span class="hljs-comment"># 解码器</span><br>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(encoded)<br>x = layers.UpSampling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(x)<br>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<br>x = layers.UpSampling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(x)<br>decoded = layers.Conv2D(<span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<br><br>autoencoder = models.Model(input_img, decoded)<br>autoencoder.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>)<br><br><span class="hljs-comment"># 加载数据并添加噪声</span><br>(x_train, _), (x_test, _) = tf.keras.datasets.mnist.load_data()<br>x_train = x_train.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.</span><br>x_test = x_test.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.</span><br>x_train = np.reshape(x_train, (<span class="hljs-built_in">len</span>(x_train), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))<br>x_test = np.reshape(x_test, (<span class="hljs-built_in">len</span>(x_test), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))<br><br>noise_factor = <span class="hljs-number">0.5</span><br>x_train_noisy = x_train + noise_factor * np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>, size=x_train.shape)<br>x_test_noisy = x_test + noise_factor * np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>, size=x_test.shape)<br>x_train_noisy = np.clip(x_train_noisy, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>)<br>x_test_noisy = np.clip(x_test_noisy, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>)<br><br><span class="hljs-comment"># 训练自编码器</span><br>autoencoder.fit(x_train_noisy, x_train,<br>                epochs=<span class="hljs-number">50</span>,<br>                batch_size=<span class="hljs-number">256</span>,<br>                shuffle=<span class="hljs-literal">True</span>,<br>                validation_data=(x_test_noisy, x_test))<br><br><span class="hljs-comment"># 预测</span><br>decoded_imgs = autoencoder.predict(x_test_noisy)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>慕ke慕w-鸿蒙NEXT应用开发工程师</title>
    <link href="/2024/05/28/%E6%85%95ke%E6%85%95w-%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2024/05/28/%E6%85%95ke%E6%85%95w-%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>鸿蒙系统采用ArkTS作为其原生开发语言。如果你对TypeScript有所了解，那么你将能够轻松过渡到ArkTS，因为它并非一种全新的语言，而是基于TypeScript的扩展。这意味着我们可以省去学习新语言的过程，只需专注于鸿蒙的UI框架——ArkUI。</p><p>ArkUI框架与React类似，采用声明式开发模式来构建用户界面，并内置了全面的状态管理机制，无需像React那样面对众多复杂的第三方状态管理库。</p><p>鸿蒙系统的内置组件布局设计灵感来源于CSS，包括margin、padding、flex、grid、栅格系统和媒体查询等概念，这些都是Web前端开发者所熟悉的。</p><p>鸿蒙Next提供了一套完整的开发、调试、测试和发布流程，集成在一个IDE中。如果你之前使用过IntelliJ IDEA，那么你将发现使用鸿蒙的DevEco Studio是无缝的，因为它是基于IntelliJ IDEA Community版深度定制的。即使你是Neovim或VSCode的忠实用户，DevEco Studio同样易于上手。</p><h3 id="IDE介绍"><a href="#IDE介绍" class="headerlink" title="IDE介绍"></a>IDE介绍</h3><p>在开始之前，让我们先了解鸿蒙的IDE——DevEco Studio。</p><h4 id="DevEco-Studio-安装"><a href="#DevEco-Studio-安装" class="headerlink" title="DevEco-Studio 安装"></a>DevEco-Studio 安装</h4><p>目前，DevEco Studio提供了三个版本供下载：</p><ul><li>Windows(64-bit)</li><li>Mac(X86)</li><li>Mac(ARM)</li></ul><p>请注意，当前版本需要Node 18.x环境。对于前端开发者，建议安装nvm，并预先切换到正确的Node版本。</p><p>安装nvm后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm install 18.14.1<br>nvm use 18.14.1<br>node -v<br></code></pre></td></tr></table></figure><p>这样，在安装DevEco时，你可以选择本地的Node环境。如果你的本地没有Node，也可以选择全新安装。</p><p>如果一切顺利，在Diagnose界面，你将看到所有的检查项都显示为对号，这表示安装成功。</p><p>我相信你能够自己摸索着创建一个”Hello World”项目。</p><p>接下来，你将看到项目中默认创建了大量的文件。起初，我和你一样，不知道从何下手。但经过研究，我发现许多文件都存在两个版本：一个是模块级的，另一个是应用级的。</p><p>为了更清晰地展示，我制作了一张图，图中左侧列出的文件都是应用和模块的两个版本。</p><p>整个<code>entry</code>目录称为一个Module，该目录将编译为一个以<code>.hap</code>为后缀的文件，即HAP包。</p><p>当应用最终发布时，它将被打包成一个以<code>.app</code>为扩展名的文件，并上传到华为应用商店。</p><p>Module不仅限于<code>entry</code>类型，还包括其他类型。为了简化，我仍然总结了一张图：</p><p>初看可能会感到有些困惑，但实际上，作为初学者，我们只需要关注<code>entry</code>模块。其他Module类型可以等到更深入的开发阶段再去文档中了解。</p><p>在<code>entry</code>目录下，有一个<code>src/main/ets/pages/index.ets</code>文件，这是用户看到的第一个页面。我们先打开这个文件，稍后我将详细介绍对应的语法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Index</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Column</span>() &#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br>          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一行的<code>@Entry</code>装饰器表明这是应用的入口点，<code>build()</code>方法返回的是整个声明式UI的页面结构。</p><p>翻译过来，就是在较高的<code>Row</code>组件中放置了一个较宽的<code>Column</code>组件，其中包含了一个文本组件，字体大小为50。</p><p>在右上角选择<code>previewer</code>，点击<code>run</code>按钮即可运行并预览效果。</p><h3 id="输出效果"><a href="#输出效果" class="headerlink" title="输出效果"></a>输出效果</h3><p>这就是整个开发流程。刚才的代码看起来是否非常熟悉？是的，它是TypeScript！</p><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>鸿蒙的主要开发语言是ArkTS（以<code>.ets</code>文件为扩展名）。它看起来如此熟悉，因为它是TypeScript的一个超集，基本上是TS代码。最大的区别或特点是，在编译时对静态类型的检查和分析进行了增强，并对一些动态特性进行了一些限制。这使得程序在运行时类型都是已知的，减少了运行时错误并提高了程序性能。</p><p>例如，强制类型不允许使用<code>any</code>或<code>unknown</code>类型。也不能使用<code>obj as any</code>之类的语法动态给对象添加属性和方法，更不能在运行时使用<code>delete</code>删除属性或方法。在某些需要<code>any</code>类型的情况下，建议使用<code>Record&lt;string, Object&gt;</code>类型。</p><p>编译器默认开启了TypeScript的一些严格模式，例如<code>strictPropertyInitialization</code>，要求强制给定初始值。<code>strictNullChecks</code>强制进行空值安全检查等。</p><p>总之，你能想到的所有运行时的动态类型特性都将受到限制，尽量不要使用。更多详细的语法规则可以参考官方文档中关于《从TypeScript到ArkTS的适配规则》的文章，内容非常详细。实际上，在开发过程中，DevEco Studio会提供非常好的错误报告信息，因此你可以先不必了解这些语法规则，等到遇到问题时再去查询。</p><h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3><p>ArkUI框架是基于ArkTS的UI框架，采用声明式开发范式，数据驱动UI更新，并提供了页面级路由导航等。</p><p>在页面布局方面，提供了多种媒体查询，例如：</p><ul><li>设备类型</li><li>窗口宽高监听</li><li>折叠屏状态</li><li>横竖屏查询</li></ul><p>统一了单位，例如：</p><ul><li><code>vp</code> 虚拟像素</li><li><code>fp</code> 字体像素，用户端的设置会乘以系数 <code>1fp = 1vp * scale</code></li></ul><p>并提供了多种栅格系统，窗口栅格会根据容器宽度自动匹配栅格数量：</p><ul><li>4格：small（360～600），手机竖屏</li><li>8格：medium（600～840），手机横屏，pad竖屏，折叠屏</li><li>12格：large（840～1440），pad横屏，2in1</li><li>12格：x-large（1440～），全屏</li></ul><p>需要注意的是，目前稳定主推的应用模型称为Stage模型。如果你在学习过程中看到FA模型，那就是旧版教程，可以不用看了。</p><p>下面我们在代码层面了解一下如何声明UI。</p><h4 id="声明式UI描述"><a href="#声明式UI描述" class="headerlink" title="声明式UI描述"></a>声明式UI描述</h4><p>声明式UI的描述方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Column</span>() &#123;<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 1&#x27;</span>)<br>  <span class="hljs-title class_">Divider</span>()<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 2&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Column</code>是容器组件，所以后面带有<code>&#123;&#125;</code>，包含子组件。非容器组件则无需<code>&#123;&#125;</code>。</p><p>给组件配置属性通常使用链式调用的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Text</span>(<br>  <span class="hljs-string">&quot;hello&quot;</span><br>).<span class="hljs-title function_">fontSize</span>(<br>  <span class="hljs-number">20</span><br>).<span class="hljs-title function_">fontColor</span>(<br>  <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span><br>).<span class="hljs-title function_">fontWeight</span>(<br>  <span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span><br>);<br></code></pre></td></tr></table></figure><p>为了更加清晰，通常会写成这种格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)<br>  .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>)<br>  .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>);<br></code></pre></td></tr></table></figure><h4 id="添加事件处理"><a href="#添加事件处理" class="headerlink" title="添加事件处理"></a>添加事件处理</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;Click me&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">myText</span> = <span class="hljs-string">&quot;ArkUI&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>ArkUI中大量使用了装饰器，包括我们之前看到的<code>@entry</code>表示入口。再看一个最简单的自定义组件：</p><p>ArkUI中用<code>@Component</code>装饰的<code>struct</code>结构代表自定义组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MyComponent</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在build函数里返回UI描述</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在当前流行的数据驱动UI编程范式中，UI &#x3D; f(State)，状态是不可或缺的。</p><p>ArkUI中用<code>@State</code>装饰器来声明状态，Parent可以直接覆盖Child State：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-comment">// 父组件覆盖State</span><br>      <span class="hljs-title class_">MyComponent</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hi&quot;</span> &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和React中的State类似，状态的变化可以引起UI更新，但注意这个状态不是immutable的，UI是否可以观察到状态的变化要看数据类型，具体要参考详细的文档。</p><p>下面是典型的事件处理中修改状态，引起UI刷新的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">HelloComponent</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 基础类型的状态变量message改变驱动UI刷新，</span><br>          <span class="hljs-comment">// UI从&#x27;Hello, World!&#x27;刷新为&#x27;Hello, ArkUI!&#x27;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Hello, ArkUI!&#x27;</span>;<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@State</code>只是组件内部的状态。如果想在状态更改时引发Child组件的更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>鸿蒙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件项目-自动化云测平台/Spingboot3.X/微服务/Kafka3.x学习指南</title>
    <link href="/2024/05/28/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2024/05/28/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="基于云的测试实践"><a href="#基于云的测试实践" class="headerlink" title="基于云的测试实践"></a>基于云的测试实践</h2><p>在当今快速发展的科技时代，云计算技术已经深入到各个领域，其中软件测试行业也受到了显著的影响。本文将探讨云测试的概念、优势、挑战以及如何有效利用云资源进行软件测试。</p><p><strong>测试的现状与痛点</strong></p><p>首先，我们来审视一下软件测试领域目前所面临的一些挑战。测试成本高昂，特别是兼容性测试，随着移动设备的快速迭代，跨设备的兼容性测试变得越来越复杂和耗时。此外，测试机系统需要频繁升级，测试硬件和软件的利用率低，测试环境管理复杂，这些都是测试领域需要解决的问题。</p><p><strong>云计算带给测试领域的变革</strong></p><p>云计算作为一种服务提供模型，允许用户随时随地通过网络访问共享资源池的资源。这种模式为软件测试带来了新的可能性。企业不再需要购买大量实体机型进行测试，而是可以将测试过程迁移到云中，利用云计算平台提供的计算和存储资源进行测试活动。资源的自动生成、弹性分配、按需服务等特性，有效解决了传统测试中的诸多问题。</p><p><strong>云测试平台</strong></p><p>云测试平台是一种利用云环境进行测试的方法，它集约化利用测试资源，规模化完成测试任务。用户可以通过浏览器提交测试项目和脚本，测试任务在云端执行，并将结果集中展现给用户。云测试平台具有节约成本、服务按需付费、扩展性强、高可靠性、联网即得和加速测试等优点。然而，它也存在一些缺点，如平台服务及数据的安全性、供应商角色增加的复杂度以及虚拟技术不固定影响性能测试等。</p><p><strong>云测试平台的选择</strong></p><p>市场上存在多种云测试平台，如Xamarin Test Cloud、Testin云测、AWS Device Farm、Sauce Labs等，它们各自拥有独特的优势。在选择云测试平台时，需要考虑供应商的选择标准、软硬件标准、安全性、服务类型（私有云、公有云或混合云平台）等因素。</p><p><strong>AWS Device Farm</strong></p><p>AWS Device Farm是一个相对较新的云测试平台，它支持的设备数量较少，但在脚本测试中支持的语言和框架发展迅速。AWS Device Farm是唯一支持测试FireOS设备的云测试平台，支持远程访问测试、脚本测试、并行运行测试等多种功能。它还提供了丰富的日志记录操作、与CloudTrail集成、模拟不同网络连接状态的性能监控和分析等功能。</p><p><strong>云测试平台搭建</strong></p><p>搭建云测试平台可以分为用户接口层、云测试项目管理层和云管理层。用户接口层是用户访问云测试系统的入口，通过Web界面实现测试任务的提交、状态查看和结果审阅。云测试项目管理层负责资源预留和调度，监控测试状态，并分析统计测试结果。云管理层则是测试云的基础设施，根据任务管理层的指令来选择镜像并创建虚拟机，动态分配和管理各种虚拟资源。</p><h2 id="微服务架构的陷阱与最佳实践"><a href="#微服务架构的陷阱与最佳实践" class="headerlink" title="微服务架构的陷阱与最佳实践"></a>微服务架构的陷阱与最佳实践</h2><p>在当今快速发展的软件开发领域，微服务架构因其灵活性和可扩展性而受到广泛关注。然而，微服务架构并非没有陷阱。本文将探讨微服务架构的一些常见问题，并提供一系列最佳实践，以帮助开发者和团队更有效地实施微服务。</p><h3 id="微服务架构的陷阱"><a href="#微服务架构的陷阱" class="headerlink" title="微服务架构的陷阱"></a>微服务架构的陷阱</h3><p>首先，我们来识别微服务架构中的一些常见陷阱：</p><ol><li><strong>服务拆分过细</strong>：过度强调“small”而忽略了服务的实用性和维护性。</li><li><strong>基础设施不完善</strong>：忽略了“automated”的重要性，导致微服务架构难以维护和扩展。</li><li><strong>并非轻量级</strong>：随着规模的扩大，微服务的“lightweight”特性不再适用。</li></ol><h3 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h3><p>针对服务拆分过细的问题，可以基于团队规模进行服务拆分。这里引入了“三个火枪手”原则，即一个微服务由三个人负责开发。这种原则基于团队规模来划分服务数量，随着业务的发展和团队规模的扩大，可以进一步拆分服务。</p><h3 id="为什么选择三个人？"><a href="#为什么选择三个人？" class="headerlink" title="为什么选择三个人？"></a>为什么选择三个人？</h3><ul><li><strong>系统规模</strong>：三个人可以全面理解系统，同时进行有效的分工。</li><li><strong>团队管理</strong>：三个人可以形成稳定的备份，即使有人休假或调配，剩余人员仍可支撑。</li><li><strong>技术提升</strong>：三个人可以进行有效讨论，并快速达成一致。</li></ul><h3 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h3><p>在实施微服务架构时，拆分服务的具体方法也至关重要。以下是几种推荐的拆分策略：</p><ol><li><p><strong>基于业务进行拆分</strong>：识别系统中的业务模块，并将其拆分成独立的服务。需要注意的是，拆分粒度应根据“三个火枪手”原则来确定，避免过粗或过细。</p></li><li><p><strong>基于可扩展性拆分</strong>：将服务按照稳定性排序，将成熟和变动不大的服务拆分成稳定服务，而将经常变动的服务拆分成变动服务。</p></li><li><p><strong>基于可靠性拆分</strong>：将业务模块按照优先级排序，将核心服务和非核心服务分开，重点保护核心服务的高可用性。</p></li><li><p><strong>基于性能拆分</strong>：将性能要求高或压力大的模块拆分出来，避免影响其他服务。</p></li></ol><p>这些拆分方式可以根据实际情况自由组合。</p><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>微服务的成功不仅取决于服务的划分，更在于基础设施的完善。以下是微服务基础设施的关键组成部分：</p><ul><li><strong>服务发现</strong>、<strong>服务路由</strong>、<strong>服务容错</strong>：这是最基本的微服务基础设施。</li><li><strong>接口框架</strong>、<strong>API网关</strong>：提高开发效率和与外部服务对接的效率。</li><li><strong>自动化部署</strong>、<strong>自动化测试</strong>、<strong>配置中心</strong>：提升测试和运维效率。</li><li><strong>服务监控</strong>、<strong>服务跟踪</strong>、<strong>服务安全</strong>：提升监控效率。</li></ul><p>微服务的基础设施可能看起来是一个庞大的工程，但现有的开源解决方案如Spring Cloud可以帮助简化这一过程。此外，如果微服务的数量不多，并不是所有基础设施组件都是必需的。</p><h2 id="kafka工作原理"><a href="#kafka工作原理" class="headerlink" title="kafka工作原理"></a>kafka工作原理</h2><p>Kafka是一种流行的分布式流处理平台，它被设计用来处理高吞吐量的实时数据。本文将深入探讨Kafka的工作原理，包括其系统角色、数据结构、以及与Zookeeper的交互。</p><h3 id="Kafka系统的角色"><a href="#Kafka系统的角色" class="headerlink" title="Kafka系统的角色"></a>Kafka系统的角色</h3><p>在Kafka架构中，有几个关键角色：</p><ul><li><strong>Broker</strong>：Kafka服务器的实例，一个集群由多个Broker组成，每个Broker可以存储多个Topic。</li><li><strong>Topic</strong>：可以理解为消息队列的名称，是消息的分类。</li><li><strong>Partition</strong>：为了实现扩展性，一个Topic可以被分割成多个Partition，每个Partition是一个有序的队列，并且每个Partition中的每条消息都有一个唯一的offset。</li></ul><h3 id="Topic、Partition和Replica的关系"><a href="#Topic、Partition和Replica的关系" class="headerlink" title="Topic、Partition和Replica的关系"></a>Topic、Partition和Replica的关系</h3><p>Partition是Kafka中实现并行处理的关键。一个Topic可以有多个Partition，而每个Partition可以有多个Replica（副本）。这样设计可以提高系统的可用性和容错性。Partition的分配策略通常基于两种基本算法：Key Hash算法和Round Robin算法。</p><h3 id="Kafka与Zookeeper的交互"><a href="#Kafka与Zookeeper的交互" class="headerlink" title="Kafka与Zookeeper的交互"></a>Kafka与Zookeeper的交互</h3><p>Kafka使用Zookeeper来维护集群状态和协调分布式操作。Broker、Consumer和Producer都与Zookeeper交互：</p><ul><li><strong>Broker</strong>：在Zookeeper中注册信息，并更新元数据，如Topic和Partition信息。</li><li><strong>Consumer</strong>：使用Zookeeper来注册信息，包括消费的Partition列表，并发现Broker列表，建立连接并获取消息。</li><li><strong>Producer</strong>：与Zookeeper没有直接关系，主要与Broker交互。</li></ul><p>Zookeeper在Kafka中扮演着协调者的角色，但不直接存储Topic数据。</p><h3 id="Kafka的文件存储机制"><a href="#Kafka的文件存储机制" class="headerlink" title="Kafka的文件存储机制"></a>Kafka的文件存储机制</h3><p>Kafka的消息存储在磁盘上，文件以<code>offset.kafka</code>命名，这样设计便于根据offset快速查找消息。例如，要查找位于2049位置的消息，只需定位到2048.kafka文件即可。</p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>Kafka支持两种消息传递模式：广播（将消息发送给所有消费者）和发布订阅（只发送给订阅者）。通过Consumer Group（CG），Kafka实现了这两种模式：</p><ul><li>一个Topic的消息可以复制到所有CG，但每个CG中的Consumer只会收到消息的一份。</li><li>如果需要广播，每个Consumer可以有自己的CG。</li><li>如果需要单播，所有Consumer可以属于同一个CG。</li></ul><h3 id="Kafka的动态集群扩展"><a href="#Kafka的动态集群扩展" class="headerlink" title="Kafka的动态集群扩展"></a>Kafka的动态集群扩展</h3><p>Kafka通过Zookeeper实现动态集群扩展，无需更改客户端配置。Broker在Zookeeper中注册并保持元数据更新，客户端在Zookeeper上注册watcher，以感知变化并作出调整。</p><h3 id="如何查看Topic的Partition数量"><a href="#如何查看Topic的Partition数量" class="headerlink" title="如何查看Topic的Partition数量"></a>如何查看Topic的Partition数量</h3><p>可以使用Kafka提供的脚本<code>kakfa-topic.sh</code>来查看Topic的Partition数量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kafka-topic.sh --list --topic topicName --zookeeper zookeeper.servers.list<br></code></pre></td></tr></table></figure><h3 id="Zookeeper存储结构"><a href="#Zookeeper存储结构" class="headerlink" title="Zookeeper存储结构"></a>Zookeeper存储结构</h3><p>Zookeeper存储了Kafka集群的元数据，包括admin、consumers、config和brokers等节点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>慕体系Python全能工程师2024之深入底层原理</title>
    <link href="/2024/05/27/%E6%85%95%E4%BD%93%E7%B3%BBPython%E5%85%A8%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%B8%882024%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/27/%E6%85%95%E4%BD%93%E7%B3%BBPython%E5%85%A8%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%B8%882024%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Python数据类型底层原理"><a href="#Python数据类型底层原理" class="headerlink" title="Python数据类型底层原理"></a>Python数据类型底层原理</h2><p>Python是一种动态类型的编程语言，它允许我们在不指定类型的情况下为变量赋值。例如，我们可以连续地给一个变量赋值为整数和字符串，而不会报错。这种灵活性源于Python的动态数据类型设计，其中每个变量都包含了值信息和类型额外信息。</p><blockquote><p>“夏のke”》 Ukoou·ㄷㅁΜ</p></blockquote><p>在Python的内部实现中，每个对象都是基于C语言编写的结构体，例如整型对象。一个整型在Python中实际上是一个指向C语言结构体的指针。这个结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">longobject</span> &#123;</span><br>    <span class="hljs-type">long</span> ob_refcnt;<br>    PyTypeObject *ob_type;<br>    <span class="hljs-type">size_t</span> ob_size;<br>    <span class="hljs-type">long</span> ob_digit[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个结构体中，<code>ob_refcnt</code>是引用计数，用于协助Python的垃圾回收（GC）。<code>ob_type</code>是类型对象，它编码了变量的类型信息。<code>ob_size</code>表示数据成员的大小，而<code>ob_digit</code>则包含了实际的整数值。</p><p>由于Python的动态类型系统，存储一个整型需要额外的开销。除了实际的数值之外，还需要存储类型和引用计数等信息。这种设计虽然带来了灵活性，但也增加了内存的使用。</p><p>列表（list）是Python中的标准可变多元素容器。它的底层实现是一个包含多个Python对象的指针数组。列表的C语言结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    PyObject *ob_item; <span class="hljs-comment">// 指针数组</span><br>    Py_ssize_t allocated; <span class="hljs-comment">// 申请内存的槽个数</span><br>&#125; PyListObject;<br></code></pre></td></tr></table></figure><p>列表中的每个元素都是一个指向Python对象的指针。当添加或删除元素时，可能需要重新分配内存。不过，由于Python的实现细节，并不是每次操作都需要改变数组的大小。</p><p>NumPy库提供了固定类型的数组，这与Python原生的列表有所不同。NumPy数组的底层结构体中包含了头信息、数据、维度和步幅等信息，然后指向数组的第一个元素。通过步幅和维度可以快速定位到数组中的任何元素。</p><p>慕课Python全能工程师2024 字典（dict）在Python中的底层实现是基于哈希表的。只有可哈希的对象才能作为字典的键。Python使用伪随机探测的哈希表作为字典的底层结构。解决哈希碰撞的方法包括开放寻址、再hash法、链地址法、公共溢出区以及装填因子等。</p><p>集合（set）的实现与哈希表类似，它基于hash对元素进行散列，只包含对键的引用，没有对值的引用。</p><p>通过深入了解Python数据类型的底层原理，我们可以更好地理解Python的内存管理和性能特性。这对于编写高效、可维护的Python代码至关重要。</p><h2 id="Python封装底层实现原理"><a href="#Python封装底层实现原理" class="headerlink" title="Python封装底层实现原理"></a>Python封装底层实现原理</h2><p>慕课Python全能工程师2024 Python中的封装特性并非通过传统的访问控制修饰符（如Java中的public、private等）来实现，而是通过名称修改（name mangling）的方式。这意味着，当你试图在一个类中定义私有属性或方法时，Python会自动将这些属性或方法的名称进行修改，以防止它们被外部直接访问。</p><p>在提供的示例代码中，我们定义了一个名为<code>CLanguage</code>的类，其中包含了私有属性<code>__name</code>和<code>__add</code>，以及对应的setter和getter方法。此外，还有一个私有方法<code>__display</code>，用于打印这些私有属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CLanguage</span> :<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setname</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;名称长度必须大于3！&#x27;</span>)<br>        self.__name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getname</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br>    <span class="hljs-comment"># 为 name 配置 setter 和 getter 方法</span><br>    name = <span class="hljs-built_in">property</span>(getname, setname)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setadd</span>(<span class="hljs-params">self, add</span>):<br>        <span class="hljs-keyword">if</span> add.startswith(<span class="hljs-string">&quot;http://&quot;</span>):<br>            self.__add = add<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;地址必须以 http:// 开头&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getadd</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__add<br><br>    <span class="hljs-comment"># 为 add 配置 setter 和 getter 方法</span><br>    add = <span class="hljs-built_in">property</span>(getadd, setadd)<br><br>    <span class="hljs-comment"># 定义个私有方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__display</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.__name,self.__add)<br></code></pre></td></tr></table></figure><p>当我们尝试直接调用私有方法<code>__display</code>时，Python会抛出一个<code>AttributeError</code>，因为该方法的名称已经被修改，不再是<code>__display</code>。然而，如果我们知道了名称修改的规则，即在属性或方法名前加上<code>_类名__</code>，我们就可以访问到这些私有成员。例如，<code>_CLanguage__display</code>就是<code>__display</code>方法修改后的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">clang = CLanguage()<br><span class="hljs-comment"># 尝试调用私有的 display() 方法</span><br>clang.__display()  <span class="hljs-comment"># 这将引发错误</span><br><br><span class="hljs-comment"># 调用name的setname()方法</span><br>clang.name = <span class="hljs-string">&quot;新宝库&quot;</span><br><span class="hljs-comment"># 调用add的setadd()方法</span><br>clang.add = <span class="hljs-string">&quot;https://www.xinbaoku.com&quot;</span><br><span class="hljs-comment"># 直接调用隐藏的display()方法</span><br>clang._CLanguage__display()  <span class="hljs-comment"># 正确调用</span><br></code></pre></td></tr></table></figure><p>此外，我们还可以访问和修改私有属性<code>__name</code>和<code>__add</code>，尽管这不是推荐的做法，因为它破坏了封装性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">clang = CLanguage()<br>clang.name = <span class="hljs-string">&quot;新宝库&quot;</span><br>clang.add = <span class="hljs-string">&quot;https://www.xinbaoku.com&quot;</span><br><span class="hljs-comment"># 直接调用 name 和 add 私有属性</span><br><span class="hljs-built_in">print</span>(clang._CLanguage__name,clang._CLanguage__add)<br><br><span class="hljs-comment"># 甚至于，我们还可以通过这种方式修改 clang 对象的私有属性</span><br>clang._CLanguage__name = <span class="hljs-string">&quot;Python教程&quot;</span><br>clang._CLanguage__add = <span class="hljs-string">&quot;https://www.xinbaoku.com/python&quot;</span><br><span class="hljs-built_in">print</span>(clang._CLanguage__name,clang._CLanguage__add)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件项目大课-自动化云测平台/Spingboot3.X/微服务/Kafka3.x</title>
    <link href="/2024/05/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%AF%BE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x/"/>
    <url>/2024/05/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%AF%BE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x/</url>
    
    <content type="html"><![CDATA[<p>在当今快速发展的信息技术时代，中间件技术在企业信息化建设中扮演着至关重要的角色。自20世纪80年代以来，随着企业业务需求的不断变化，企业可能需要同时运行多个不同的业务系统，这些系统可能基于不同的操作系统、数据库和异构网络环境。中间件的出现，正是为了解决这些信息系统如何协同工作的问题，实现企业跨平台、分布式应用的目标。</p><h3 id="中间件的定义与作用"><a href="#中间件的定义与作用" class="headerlink" title="中间件的定义与作用"></a>中间件的定义与作用</h3><p>中间件（Middleware）是一种位于操作系统和应用程序之间的软件，有时也被认为是操作系统的一部分。它通过一组集成的中间件构成一个平台，包括开发平台和运行平台。中间件的核心功能是通信，它使得分布式系统中的各个部分能够相互通信。中间件的使用简化了企业应用的复杂性，使得开发人员能够面对一个简单而统一的开发环境，专注于业务逻辑的实现，而不必为程序在不同系统软件上的移植而烦恼。</p><h3 id="中间件的特点"><a href="#中间件的特点" class="headerlink" title="中间件的特点"></a>中间件的特点</h3><p>中间件应具备以下特点：</p><ol><li><strong>满足大量应用的需要</strong>：中间件需要能够支持广泛的应用场景。</li><li><strong>运行于多种硬件和操作系统平台</strong>：中间件应具有跨平台的特性。</li><li><strong>支持分布计算</strong>：提供跨网络、硬件和操作系统平台的透明性应用或服务的交互。</li><li><strong>支持标准的协议和接口</strong>：这是中间件可移植性和互操作性的关键。</li></ol><p>中间件的这些特点使其成为许多标准化工作的主要部分，对于应用软件开发来说，中间件的重要性甚至超过了操作系统和网络服务。中间件提供的程序接口定义了一个相对稳定的高层应用环境，保护了企业在应用软件开发和维护中的投资。</p><h3 id="消息中间件——Kafka机制"><a href="#消息中间件——Kafka机制" class="headerlink" title="消息中间件——Kafka机制"></a>消息中间件——Kafka机制</h3><p><strong>储存模型</strong></p><p>Kafka节点上，一个Partition的每个副本对应一个磁盘目录，新的日志，都是直接append到文件末尾，所以不管文件多大，写入总是O(1)的时间复杂度。但如果文件很大，顺序查找的效率也会很低。kafka通过两种方式解决：分段、索引。</p><p><strong>分段</strong></p><p>比如有100条 Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文 件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段 中。</p><p><strong>索引</strong></p><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的 Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立 了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。</p><p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p><p>注: index文件中并没有为数据文件中的每条Message建立索引，而是采用了 稀疏存储 的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的 Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。</p><p><strong>高性能</strong></p><p>顺序读写</p><p>kafka采用的磁盘的顺序读写比无序快了太多，这是由操作系统决定的，即使是普通的机械磁盘，顺序访问速率也接近了内存的随机访问速率。</p><p>即使是顺序读写，过于频繁的大量小IO操作一样会造成磁盘的瓶颈，此时又变成了随机读写。Kafka的策略是把消息集合在一起，批量发送，尽可能减少对磁盘的访问。所以，Kafka的Topic和Partition数量不宜过多，超过64个Topic&#x2F;Partition以后，Kafka性能会急剧下降。</p><p><strong>零拷贝</strong></p><p>Kafka中存在大量的网络数据持久化到磁盘（Producer到Broker）和磁盘文件通过网络发送（Broker到Consumer）的过程。这一过程的性能直接影响Kafka的整体吞吐量。</p><p>Linux 2.4+内核通过sendfile系统调用，提供了零拷贝。数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个sendfile调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p><p>Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo和transferFrom方法实现零拷贝。</p><p><strong>页缓存</strong></p><p>Kafka并不太依赖JVM内存大小，而是主要利用Page Cache，如果使用应用层缓存（JVM堆内存），会增加GC负担，增加停顿时间和延迟，创建对象的开销也会比较高。</p><p>读取操作可以直接在Page Cache上进行，如果消费和生产速度相当，甚至不需要通过物理磁盘直接交换数据，这是Kafka高吞吐量的一个重要原因。</p><p>这么做还有一个优势，如果Kafka重启，JVM内的Cache会失效，Page Cache依然可用。</p><p>代码机制</p><p>kafka-producer.xml</p><pre><code class="hljs">&lt;!--基本配置 --&gt;&lt;bean id=&quot;producerProperties&quot; class=&quot;java.util.HashMap&quot;&gt;    &lt;constructor-arg&gt;        &lt;map&gt;            &lt;!-- kafka服务地址，可能是集群--&gt;            &lt;entry key=&quot;bootstrap.servers&quot; value=&quot;192.168.62.212:9092,192.168.62.213:9092,192.168.62.214:9092&quot;/&gt;            &lt;!-- 有可能导致broker接收到重复的消息,默认值为3--&gt;            &lt;entry key=&quot;retries&quot; value=&quot;10&quot;/&gt;            &lt;!-- 每次批量发送消息的数量--&gt;            &lt;entry key=&quot;batch.size&quot; value=&quot;1638&quot;/&gt;            &lt;!-- 默认0ms，在异步IO线程被触发后（任何一个topic，partition满都可以触发）--&gt;            &lt;entry key=&quot;linger.ms&quot; value=&quot;1&quot;/&gt;            &lt;!--producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常 --&gt;            &lt;entry key=&quot;buffer.memory&quot; value=&quot;33554432 &quot;/&gt;            &lt;!-- producer需要server接收到数据之后发出的确认接收的信号，此项配置就是指procuder需要多少个这样的确认信号--&gt;            &lt;entry key=&quot;acks&quot; value=&quot;all&quot;/&gt;            &lt;entry key=&quot;key.serializer&quot; value=&quot;org.apache.kafka.common.serialization.StringSerializer&quot;/&gt;            &lt;entry key=&quot;value.serializer&quot; value=&quot;org.apache.kafka.common.serialization.StringSerializer&quot;/&gt;        &lt;/map&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 创建kafkatemplate需要使用的producerfactory bean --&gt;&lt;bean id=&quot;producerFactory&quot;      class=&quot;org.springframework.kafka.core.DefaultKafkaProducerFactory&quot;&gt;    &lt;constructor-arg&gt;        &lt;ref bean=&quot;producerProperties&quot;/&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --&gt;&lt;bean id=&quot;KafkaTemplate&quot; class=&quot;org.springframework.kafka.core.KafkaTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;producerFactory&quot;/&gt;    &lt;!--设置对应topic--&gt;    &lt;property name=&quot;defaultTopic&quot; value=&quot;bert&quot;/&gt;&lt;/bean&gt;// 测试类@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:kafka-producer.xml&quot;)public class KafkaTemplateTest &#123;    @Autowired    private KafkaTemplate&lt;Integer, String&gt; kafkaTemplate;    @Test    public void hello()&#123;        kafkaTemplate.sendDefault(&quot;hello world&quot;);    &#125;&#125;</code></pre><p>kafka-consumer.xml</p><pre><code class="hljs">&lt;bean id=&quot;consumerProperties&quot; class=&quot;java.util.HashMap&quot;&gt;        &lt;constructor-arg&gt;            &lt;map&gt;                &lt;!--Kafka服务地址 --&gt;                &lt;entry key=&quot;bootstrap.servers&quot; value=&quot;192.168.62.212:9092,192.168.62.213:9092,192.168.62.214:9092&quot; /&gt;                &lt;!--Consumer的组ID，相同goup.id的consumer属于同一个组。 --&gt;                &lt;entry key=&quot;group.id&quot; value=&quot;bert.mac&quot; /&gt;                &lt;!--如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。 --&gt;                &lt;entry key=&quot;enable.auto.commit&quot; value=&quot;true&quot; /&gt;                &lt;!--网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定 --&gt;                &lt;entry key=&quot;session.timeout.ms&quot; value=&quot;15000 &quot; /&gt;                &lt;entry key=&quot;key.deserializer&quot;                    value=&quot;org.apache.kafka.common.serialization.StringDeserializer&quot; /&gt;                &lt;entry key=&quot;value.deserializer&quot;                    value=&quot;org.apache.kafka.common.serialization.StringDeserializer&quot; /&gt;            &lt;/map&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!--指定具体监听类的bean --&gt;    &lt;bean id=&quot;messageListernerConsumerService&quot; class=&quot;com.ximalaya.queue.KafkaConsumerListener&quot; /&gt;    &lt;!-- 创建consumerFactory bean --&gt;    &lt;bean id=&quot;consumerFactory&quot; class=&quot;org.springframework.kafka.core.DefaultKafkaConsumerFactory&quot;&gt;        &lt;constructor-arg&gt;            &lt;ref bean=&quot;consumerProperties&quot;/&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;containerProperties&quot; class=&quot;org.springframework.kafka.listener.config.ContainerProperties&quot;&gt;        &lt;!-- 要消费的 topic --&gt;        &lt;constructor-arg value=&quot;bert&quot;/&gt;        &lt;property name=&quot;messageListener&quot; ref=&quot;messageListernerConsumerService&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;messageListenerContainer&quot; class=&quot;org.springframework.kafka.listener.KafkaMessageListenerContainer&quot; init-method=&quot;doStart&quot;&gt;        &lt;constructor-arg ref=&quot;consumerFactory&quot;/&gt;        &lt;constructor-arg ref=&quot;containerProperties&quot;/&gt;    &lt;/bean&gt;</code></pre><p>生产者</p><ol><li><p>直接使用KafkaProducer， DefaultKafkaProducerFactory 典型的工厂模式， 封装了kafka producer 配置</p></li><li><p>KafkaTemplate 来了一个 经典的单例模式</p><pre><code class="hljs"> public class KafkaTemplate&lt;K, V&gt; implements KafkaOperations&lt;K, V&gt; &#123;     private final ProducerFactory&lt;K, V&gt; producerFactory;     // volatile 保证多线程的可见性     private volatile Producer&lt;K, V&gt; producer;     private Producer&lt;K, V&gt; getTheProducer() &#123;         if (this.producer == null) &#123;             synchronized (this) &#123;                 // 多重检查                 if (this.producer == null) &#123;                     this.producer = this.producerFactory.createProducer();                 &#125;             &#125;         &#125;         return this.producer;     &#125; &#125;</code></pre></li></ol><p>发送逻辑</p><pre><code class="hljs">public ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, V data) &#123;    ProducerRecord&lt;K, V&gt; producerRecord = new ProducerRecord&lt;&gt;(topic, data);    return doSend(producerRecord);&#125;protected ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(final ProducerRecord&lt;K, V&gt; producerRecord) &#123;    getTheProducer();    final SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = new SettableListenableFuture&lt;&gt;();    getTheProducer().send(producerRecord, new Callback() &#123;        public void onCompletion(RecordMetadata metadata, Exception exception) &#123;            if (exception == null) &#123;                future.set(new SendResult&lt;&gt;(producerRecord, metadata));                if (KafkaTemplate.this.producerListener != null                        &amp;&amp; KafkaTemplate.this.producerListener.isInterestedInSuccess()) &#123;                    KafkaTemplate.this.producerListener.onSuccess(producerRecord.topic(),                            producerRecord.partition(), producerRecord.key(), producerRecord.value(), metadata);                &#125;            &#125;else &#123;                future.setException(new KafkaProducerException(producerRecord, &quot;Failed to send&quot;, exception));                if (KafkaTemplate.this.producerListener != null) &#123;                    KafkaTemplate.this.producerListener.onError(producerRecord.topic(),                            producerRecord.partition(), producerRecord.key(), producerRecord.value(), exception);                &#125;            &#125;        &#125;    &#125;);    if (this.autoFlush) &#123;        flush();    &#125;    return future;&#125;</code></pre><ol><li>将KafkaProducer 的send callback 转换为ListenableFuture</li><li>使用 producerListener 将“事件处理”逻辑与发送主流程解耦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 高级教程系列 - 线程创建</title>
    <link href="/2024/05/20/15_Java%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%20-%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/05/20/15_Java%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%20-%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-创建多线程（Multithreading）"><a href="#Java-创建多线程（Multithreading）" class="headerlink" title="Java 创建多线程（Multithreading）"></a>Java 创建多线程（Multithreading）<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Java-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Multithreading%EF%BC%89"></a></h1><p>Java 并发编程以多线程（Multithreading）为基础。Java 屏蔽了不同操作系统之间多线程 API 的差异，抽象出一套统一的多线程编程范式，为程序员减轻多线程开发的难度。</p><p>在 Java 中，线程被抽象为了<code>Thread</code>类，一枚<code>Thread</code>类实例即对应一枚操作系统线程（1：1）。Java 线程创建有如下几种方式：</p><ul><li><p>继承<code>Thread</code>类</p></li><li><p>实现<code>Runnable</code>接口</p></li><li><p>实现<code>Callable</code>接口</p></li></ul><h1 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E7%BB%A7%E6%89%BFThread%E7%B1%BB" title="继承Thread类"></a>继承<code>Thread</code>类<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"></a></h1><p>继承<code>Thread</code>类，覆写其<code>run()</code>方法，即可创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.String;<br><span class="hljs-keyword">import</span> java.lang.Thread;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyThread -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：继承<code>Thread</code>类</p></blockquote><h1 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3" title="实现Runnable接口"></a>实现<code>Runnable</code>接口<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"></a></h1><p>直接继承<code>Thread</code>类创建线程，可能会受限于 Java 仅支持单继承的局限性，不够灵活。实现<code>Runnable</code>接口，实现接口<code>run()</code>方法体，是另一种创建线程的方式。在创建线程时，向<code>Thread</code>类构造函数传递一枚<code>Runnable</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.String;<br><span class="hljs-keyword">import</span> java.lang.Runnable;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        thread.start();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyRunnable -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：实现<code>Runnable</code>接口</p></blockquote><p><code>Runnable</code>接口非常简单，只有一个待实现的抽象<code>run()</code>方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Runnable</code>接口源码</p></blockquote><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3" title="实现Callable接口"></a>实现<code>Callable</code>接口<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"></a></h1><p><code>Callable</code>接口的出现是为了弥补<code>Runnable</code>接口实现多线程无法带回线程任务执行结果（返回值），无法抛出异常的局限。利用<code>Callable</code>、<code>Future</code>、<code>FutureTask</code>等并发组件，我们可以方便地取得多线程任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><span class="hljs-keyword">import</span> java.util.concurrent.RunnableFuture;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>()<br>        );<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        myCallable.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: myCallable result -&gt; &quot;</span> + result);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyCallable -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCallable-&quot;</span> + String.valueOf(<span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：实现<code>Callable</code>接口</p></blockquote><p><code>Callable</code>接口是一枚泛型接口，有一个待实现<code>call()</code>方法。如果线程正常退出，方法可带回线程执行结果，如果线程执行出错，则抛出异常。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Callable</code>接口源码</p></blockquote><p><code>Future</code>接口是一枚泛型接口，提供了<code>Callable</code>线程任务的一些调用方法，如：获取计算结果、取消线程任务、判断任务是否完成…</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Future</code>接口源码</p></blockquote><h1 id="Thread类源码观察"><a href="#Thread类源码观察" class="headerlink" title="Thread类源码观察"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%82%E5%AF%9F" title="Thread类源码观察"></a><code>Thread</code>类源码观察<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%82%E5%AF%9F"></a></h1><p>我们观察<code>Thread</code>类源码，可以看到，在<code>Thread</code>类构造函数中，<code>Runnable</code>实例会被传递至内部<code>target</code>中，并在线程中实际调用<code>target.run()</code>。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">...<br>    <span class="hljs-comment">/* What will be run. */</span><br>    <span class="hljs-keyword">private</span> Runnable <span class="hljs-keyword">target</span>;<br>...<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Initializes a Thread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> g the Thread group</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target the object whose run() method gets called</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name the name of the new Thread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stackSize the desired stack size for the new thread, or</span><br><span class="hljs-comment">     *        zero to indicate that this parameter is to be ignored.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> acc the AccessControlContext to inherit, or</span><br><span class="hljs-comment">     *            AccessController.getContext() if null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inheritThreadLocals if &#123;<span class="hljs-doctag">@code</span> true&#125;, inherit initial values for</span><br><span class="hljs-comment">     *            inheritable thread-locals from the constructing thread</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadGroup g, Runnable <span class="hljs-keyword">target</span>, String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>...<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * If this thread was constructed using a separate</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> Runnable&#125; run object, then that</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> Runnable&#125; object&#x27;s &#123;<span class="hljs-doctag">@code</span> run&#125; method is called;</span><br><span class="hljs-comment">     * otherwise, this method does nothing and returns.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Subclasses of &#123;<span class="hljs-doctag">@code</span> Thread&#125; should override this method.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #start()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #stop()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">target</span>.run();<br>        &#125;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Thread</code>类部分源码</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Vite 搭建 React18 + TS 的开发模板</title>
    <link href="/2022/05/25/14_%E6%90%AD%E5%BB%BA%20Vite%20+%20React%2018%20+%20TS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/05/25/14_%E6%90%AD%E5%BB%BA%20Vite%20+%20React%2018%20+%20TS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>Vite + React 18 + TS，集成 ESLint 和 Prettier ，开箱即用，无需再从零开始配置。便于统一团队代码风格及规范。</p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>为了尽量减少手动配置，本项目的搭建将尽可能使用已有工具。</p></blockquote><p>每次想建一个项目，都需要从零开始配置？<code>ESLint</code> 和 <code>Prettie</code> 的冲突让人难受？</p><p>使用 <code>Create-React-App</code> 确实能节省一部分配置时间，但是为了有更好的开发体验，感受更快的热更新及打包速度，本次选用了 <a href="https://cn.vitejs.dev/">Vite</a>。</p><h2 id="搭建基础模板"><a href="#搭建基础模板" class="headerlink" title="搭建基础模板"></a>搭建基础模板</h2><h2 id="集成-ESLint-和-Prettier"><a href="#集成-ESLint-和-Prettier" class="headerlink" title="集成 ESLint 和 Prettier"></a>集成 ESLint 和 Prettier</h2><h3 id="各个包的作用"><a href="#各个包的作用" class="headerlink" title="各个包的作用"></a>各个包的作用</h3>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>效率</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Challenges: 4-Technical-Books</title>
    <link href="/2021/08/05/13-Code-Challenges-4-Technical-Books/"/>
    <url>/2021/08/05/13-Code-Challenges-4-Technical-Books/</url>
    
    <content type="html"><![CDATA[<p>领英课程： <code>JavaScript Code Challenges</code> 系列：EP4- <a href="https://www.linkedin.com/learning/javascript-code-challenges/technical-books">Technical Books</a></p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>题目只作简要描述，具体题目请点击上方👆🏻标题跳转。</p></blockquote><p>继承 挑战1（<a href="/2021/07/15/12_Code-Challenges-1-Available-Books/" title="Code Challenges: 1-Available Books">Code Challenges: 1-Available Books</a>）中的 <code>Book</code> 类，并新增一个 <code>edition</code> 属性，使用 <code>getEdition()</code> 方法获取当前版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 挑战1中的 Book 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">availability</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAvailability</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">getAvailability</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Out of stock&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt; <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`Low stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`In stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sell</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;No stock&#x27;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> -= numSold;<br>  &#125;<br><br>  <span class="hljs-title function_">restock</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> += numCopiesStocked;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TechnicalBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies, edition</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(title, author, <span class="hljs-variable constant_">ISBN</span>, numCopies);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> = edition;<br>  &#125;<br><br>  <span class="hljs-title function_">getEdition</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`The current version of this book is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.edition&#125;</span>.`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myTechnicalBook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TechnicalBook</span>(<br>  <span class="hljs-string">&#x27;......&#x27;</span>, <span class="hljs-comment">// 继承原属性</span><br>  <span class="hljs-string">&#x27;2.0&#x27;</span>, <span class="hljs-comment">// edition</span><br>);<br><br>myTechnicalBook.<span class="hljs-title function_">getEdition</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
      <tag>JS Code Challenges</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code Challenges: 1-Available Books</title>
    <link href="/2021/07/15/12_Code-Challenges-1-Available-Books/"/>
    <url>/2021/07/15/12_Code-Challenges-1-Available-Books/</url>
    
    <content type="html"><![CDATA[<p>领英课程： <code>JavaScript Code Challenges</code> 系列：EP1- <a href="https://www.linkedin.com/learning/javascript-code-challenges/available-books">Available Books</a></p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>题目只作简要描述，具体题目请点击上方👆🏻标题跳转。</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>title, author, ISBN, numCopies</code></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>getAvailability()</code>：根据书本的库存返回对应提示</p><p><code>sell(numSold)</code>：售出指定数量书本，若无传递参数，则为默认为1</p><p><code>restock(numCopies)</code>：入库数量，若无传递参数，则为默认为5</p><h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><ol><li>使用类</li><li>使用 getter 方法</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">availability</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAvailability</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">getAvailability</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Out of stock&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt; <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`Low stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`In stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sell</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;No stock&#x27;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> -= numSold;<br>  &#125;<br><br>  <span class="hljs-title function_">restock</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> += numCopiesStocked;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Book</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sell</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>  ...<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">restock</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>  ...<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAvailability</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
      <tag>JS Code Challenges</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个sleep函数</title>
    <link href="/2021/05/25/11_%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/25/11_%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>从ES5、ES6+的角度实现一个sleep函数。</p><span id="more"></span><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h2><p>主要方式包括：Promise（常用）、Async&#x2F;Await（常用）、Generator（较少使用）。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = time =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br><br><span class="hljs-comment">// 1秒后，打印‘Promise’</span><br><span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = time =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">output</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Async/Await---Start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Async/Await---End&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 先直接打印 Async/Await---Start，1秒后打印 Async/Await---End</span><br><span class="hljs-title function_">output</span>(); <br></code></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">sleepGenerator</span>(<span class="hljs-params">time</span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br>&#125;<br><br><span class="hljs-comment">// 1秒后，打印‘Generator’</span><br><span class="hljs-title function_">sleepGenerator</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Generator&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><p>ES5主要通过setTimeout回调函数的方式实现。</p><h3 id="使用回调"><a href="#使用回调" class="headerlink" title="使用回调"></a>使用回调</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">callback, time</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(callback, time);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;回调函数错误&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">output</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;回调&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 1秒后，打印‘回调’</span><br><span class="hljs-title function_">sleep</span>(output, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期跳槽面试记录</title>
    <link href="/2021/05/13/10_%E8%BF%91%E6%9C%9F%E8%B7%B3%E6%A7%BD%E9%9D%A2%E8%AF%95%E6%9C%89%E6%84%9F/"/>
    <url>/2021/05/13/10_%E8%BF%91%E6%9C%9F%E8%B7%B3%E6%A7%BD%E9%9D%A2%E8%AF%95%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>最近一两周在投简历面试，面了3家不同风格的公司：腾讯、外企、创业公司。简单谈下整体感受，做个记录📝</p><span id="more"></span><h2 id="跳槽原因"><a href="#跳槽原因" class="headerlink" title="跳槽原因"></a>跳槽原因</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>其实我在现公司工作的时间不长，也就八个月。</p><p>当初毕业后选择现公司的一个很大原因就是面试流程非常规范、感觉公司前景很好。</p><p>当初面试面了5轮，公司用的技术栈是React，但我只接触过Vue。经过面试，公司愿意给我机会。还记得在CTO面时，CTO表示公司不怎么招应届生，只招有经验的工程师，因为公司节奏快，需要的是能够快速上手干活的人，希望我做好准备。</p><p>入职后，果不其然，公司节奏非常快。在我入职的第二天，导师就要求我上手写项目，于是我就开始了一边看React官网一边写项目的奇妙经历。</p><p>同时，也认识到了自己的知识在“学到”和“实践”之间有较大差距，很多知识自己是知道，但是没能很好地应用起来，于是就开启了白天工作、晚上回家继续学习的生活。</p><p>后来，在走过各种曲折的路后，感觉自己回到正轨了，各种业务也能够比较从容地应对。</p><h3 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h3><p>由于公司经营的不是很好，员工们的待遇也跟不上了，发生了较大规模的离职潮。二十多人前端组来说，几个月时间，走了近一半人。</p><p>而我所在业务线，也多人离职，前端只剩我一个，我一个刚毕业没几个月的菜鸡，竟然得扛这个业务线的前端大旗。也是在这段时间，我从0到1独立开发了多个的功能模块。期间，我感觉压力也非常大，当然也成长了非常多，例如我开始更多地考虑项目的代码质量及风格、项目的可扩展性、组件复用、性能等多方面。非常幸运的是，我扛过来了。</p><h3 id="爆发"><a href="#爆发" class="headerlink" title="爆发"></a>爆发</h3><p>而真正让我萌生离职想法的，是接手某个屎山项目以后，似乎多个存在已久的问题都同时冒头了。</p><p>我接手的屎山项目，有非常多的自爆式写法，完全是为了跑路不顾一切写出来的代码，甚至出现“这么做我也没办法”的注释，完美诠释“高耦合低内聚”，导致牵一发动全身，后续迭代举步维艰。于是我主动跟业务线领导反映了这个情况，但他并没有放在心上，反而表达了一种是我经验不足之类的意思。我感受到了失望。</p><p>由于原来写这些代码的人都跑路了，这座屎山落到我头上，压得我喘不过气。明明是一些非常简单的功能，却受制于原代码而难以实现。曾想过重构重写，但前端哪里还够人手呢？反馈又得不到有效回应，于是每天早上醒来不想去上班，出现了 <a href="https://baike.baidu.com/item/%E8%81%8C%E4%B8%9A%E5%80%A6%E6%80%A0/8254445?fr=aladdin">burnout</a> 的症状。</p><p>由于离职的人多了，导致人手不够，导致手上的工作越来越多，而开发时间却越压越短。多次出现评估开发时间后被砍时间的情况。</p><p>再加上后来业务线领导说，怕我们工作不饱和，所以周报要多写字，在给我看了一篇上千字的模范作文周报后，我也觉得是时候说再见了。</p><p>跳过这个沉重的话题，开启新篇章~~😎</p><hr><h2 id="面试时间线"><a href="#面试时间线" class="headerlink" title="面试时间线"></a>面试时间线</h2><table><thead><tr><th>时间</th><th>进度</th></tr></thead><tbody><tr><td>4月30号早上</td><td>外企HR英语面</td></tr><tr><td>4月30号下午</td><td>创业公司技术面 + HR面</td></tr><tr><td>五一假期</td><td>旅行🚄、学习📖</td></tr><tr><td>5月6号</td><td>腾讯技术面</td></tr><tr><td>5月8号</td><td>外企技术面</td></tr><tr><td>5月11号早上</td><td>外企manager面</td></tr><tr><td>5月11号下午</td><td>创业公司CTO面</td></tr><tr><td>5月11号晚上</td><td>创业公司CEO面</td></tr><tr><td>5月12号</td><td>外企Offer、创业公司Offer</td></tr></tbody></table><h2 id="腾讯（凉）"><a href="#腾讯（凉）" class="headerlink" title="腾讯（凉）"></a>腾讯（凉）</h2><p>问题几乎都在围绕原理、源码，挺有深度。</p><p>估计面试官的内心是这样的👇🏻</p><p><img src="/images/stickers/shutUp.jpg" alt="就这水平你还敢来面试?"></p><p>面试官挺冷酷的，我也凉的透透的😂</p><hr><h2 id="外企（Offer）"><a href="#外企（Offer）" class="headerlink" title="外企（Offer）"></a>外企（Offer）</h2><p>面试体验直接打满分💯！</p><p>我是先在Boss直聘上投的简历。投递后，HR会先简单了解你的英文水平、是否能够全英面试、是否接受做coding task等，我 <del>瑟瑟发抖</del> 信心满满地表示：可以。😎</p><h3 id="一面：HR面（4月30号）"><a href="#一面：HR面（4月30号）" class="headerlink" title="一面：HR面（4月30号）"></a>一面：HR面（4月30号）</h3><p>HR会简单考察下我的英文水平，让我用英文做个自我介绍、再进行一些问题的问答等。</p><p>由于这是本次跳槽的第一场面试，我感觉自己说的磕磕绊绊，一度以为自己凉了😭。不过幸好通过了，然后HR就发了coding task，并提醒做好英文简历一并提交。</p><p>coding task比较简单，应该主要是考察代码风格吧。最难的是写英文简历，写的头疼😂。</p><h3 id="二面：技术面（5月8号）"><a href="#二面：技术面（5月8号）" class="headerlink" title="二面：技术面（5月8号）"></a>二面：技术面（5月8号）</h3><p>先自我介绍。</p><p>然后在线coding，一道考察位运算的算法题。题目要求线性复杂度、并且不能用额外空间，而我写的是O(n²)复杂度所以我并没有满足需求。后来面试官还问了几种排序，讲插入排序的思想。</p><p>然后从数据结构、网络、前端基础、React、Git、敏捷开发等都问了一遍，考察范围非常广，总历时1.5小时。</p><h3 id="三面：manager面（5月11号）"><a href="#三面：manager面（5月11号）" class="headerlink" title="三面：manager面（5月11号）"></a>三面：manager面（5月11号）</h3><p>自我介绍，然后聊天。</p><p>manager非常会鼓励人，循循善诱。最后问我期望薪资，我说了个范围X-Y，然后manager直接给我开了Y，非常惊喜🤩。</p><h3 id="Offer-Call（5月11号）"><a href="#Offer-Call（5月11号）" class="headerlink" title="Offer Call（5月11号）"></a>Offer Call（5月11号）</h3><p>讲了薪资福利、背调事项等，确定入职时间。</p><hr><h2 id="创业公司（Offer）"><a href="#创业公司（Offer）" class="headerlink" title="创业公司（Offer）"></a>创业公司（Offer）</h2><p>公司融资融了几个亿，发展应该是比较迅速的，前端所用技术栈是Typescript + React。</p><h3 id="一面：技术面-hr面（4月30号）"><a href="#一面：技术面-hr面（4月30号）" class="headerlink" title="一面：技术面 + hr面（4月30号）"></a>一面：技术面 + hr面（4月30号）</h3><p>一上来直接考察非常高级高端的技术问题、猝不及防😂。后面回到常规问题。最后面试官把电脑推过来，让我完成一道算法题，完成后，到了HR面。</p><p>HR面主要介绍公司情况、聊以往薪资、问期望薪资等。</p><h3 id="二面：CTO面（5月11号下午）"><a href="#二面：CTO面（5月11号下午）" class="headerlink" title="二面：CTO面（5月11号下午）"></a>二面：CTO面（5月11号下午）</h3><p>CTO是个超级大佬，但不会让人觉的不可靠近，反而非常nice🤩。或许这就是大佬吧。</p><p>主要内容就是在线coding，给定一个需要实现的功能，用React实现，之前技术面编程是有IDE的，这次是用空白文本编程，CTO还打趣说他就是这样过来的哈哈哈。</p><p>花了不少时间在格式调整上😄，然后代码写完，CTO表示可以，便问了期望薪资。</p><h3 id="三面CEO面（5月11号晚上）"><a href="#三面CEO面（5月11号晚上）" class="headerlink" title="三面CEO面（5月11号晚上）"></a>三面CEO面（5月11号晚上）</h3><p>得益于HR小姐姐的快速推进，刚面完CTO面就联系我，问我今晚是否有空进行终面，虽然很累（一天3场面试😭），但是抵不住HR小姐姐的热情，便答应了。</p><p>终面主要考察职业规划、思考之类的。</p><h3 id="Offer-Call（5月12号）"><a href="#Offer-Call（5月12号）" class="headerlink" title="Offer Call（5月12号）"></a>Offer Call（5月12号）</h3><p>HR小姐姐非常热情，开门见山直接开了一个非常有竞争力的薪资😱，非常惊喜，并表示非常希望我能加入公司。同时得知我打算接外企Offer后，晓之以理，动之以情地劝了我挺久🥺。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我最终接了外企Offer，一是整个面试流程体验非常棒。其次，薪资及各方面福利也是非常满意。还有就是外企很人性化的制度吸引了我。</p><p>所以后面的面试也推掉啦~准备入职外企❤️🥰🤩</p><p>本次面试之旅就告一段落了，这次的时间跨度其实也就一周多的时间，没想到会这么快结束战斗，感觉还是挺意外的。</p><p>最后，希望下个月顺利入职外企~~😄</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用栈实现队列</title>
    <link href="/2021/04/29/09_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/29/09_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>LeetCode 232 用栈实现队列 (JavaScript版😎)</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。</p><p>pop() – 从队列首部移除元素。</p><p>peek() – 返回队列首部的元素。</p><p>iSEmpty() – 返回队列是否为空。</p></blockquote><p>说明：</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-title function_">peek</span>(); <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-title function_">empty</span>(); <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></table></figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyQueue</span>(<span class="hljs-params">contents = []</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [...contents];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span> = [];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将元素 x 推入队列。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将队头元素推出，并返回该值。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> res;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>();<br><br>  <span class="hljs-comment">// 由于上面的 stack 已经全部 pop 出到 tempStack,</span><br>  <span class="hljs-comment">// 所以，需要在拿到目标值 res 后，将所有值重新推入 stack。</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取队头元素。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">peek</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断列队是否为空。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isEmpty</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取队列长度。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">size</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 class 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">contents = []</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [...contents];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);<br>  &#125;<br>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> res;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/images/algorithms/leetcode-232-result.png" alt="结果测试"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown实用技巧</title>
    <link href="/2021/04/24/08_Markdown%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/04/24/08_Markdown%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>早有耳闻<strong>Markdown</strong>，然而我一直没什么机会真正的接触它。但自开始写博博客以来，我便和它形影不离，才感叹：相见恨晚！🤩</p><span id="more"></span><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没开始写博客之前，我更习惯在云笔记上写些想法、心得或随想。相较博客而言，在自己的笔记里可以放飞自我，不用在意格式，也不用在意排版，感觉只要只要记下了最核心的“内容”，便足矣。😂</p><p>那既然要写博客，可不能写的这么放飞自我，否则读者的表情…👇</p><p><img src="/images/stickers/WTF.jpeg" alt="这写的是啥"></p><p>于是，我“被迫”有了真正使用 Markdown 的机会。😎</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>下面简要介绍下基本语法~</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>一个#是一级标题，二个#是二级标题，以此类推。共支持六级标题。</p><p>注：#后要跟个空格再写文字哦🥺</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="加粗（本羊用的最多🤩）"><a href="#加粗（本羊用的最多🤩）" class="headerlink" title="加粗（本羊用的最多🤩）"></a>加粗（本羊用的最多🤩）</h4><p>文字左右分别用两个*号包起来</p><p>效果：<strong>我加粗了</strong></p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>文字左右分别用一个*号包起来</p><p>效果：<em>我歪了</em></p><h4 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h4><p>文字左右分别用三个*号包起来</p><p>效果：<em><strong>我又粗又斜</strong></em></p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>文字左右分别用两个~~号包起来</p><p>效果：<del>懒惰（bushi）</del> 科技，是第一生产力！👏</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>例如本文开头关于 Markdown 的描述，就是用的引用（不知道为啥我觉得这个很酷😎）</p><p>使用方法：<code>&gt;</code> 接引用。&gt;可以无限嵌套哦。效果如下：</p><blockquote><p>为何我的眼里常含泪水，因为我对前端爱得深沉。——羊本羊</p></blockquote><h3 id="本文-Markdown-展示"><a href="#本文-Markdown-展示" class="headerlink" title="本文 Markdown 展示"></a>本文 Markdown 展示</h3><h3 id="分隔线（还没用到过🥲）"><a href="#分隔线（还没用到过🥲）" class="headerlink" title="分隔线（还没用到过🥲）"></a>分隔线（还没用到过🥲）</h3><p>连续三个或以上的 - 或 *</p><hr><p>效果：👆</p><h3 id="图片（我的最爱！😍）"><a href="#图片（我的最爱！😍）" class="headerlink" title="图片（我的最爱！😍）"></a>图片（我的最爱！😍）</h3><p>写博客当然得加上图片，理由如下：</p><ol><li>补充说明</li><li>增加文章丰富性</li><li>我想用表情包！🤩</li></ol><p><code>![alt属性文本](图片地址 &#39;可选标题&#39;)</code></p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。效果：</p><p><img src="/images/stickers/what.png" alt="啥？"></p><h3 id="超链接（常用😘）"><a href="#超链接（常用😘）" class="headerlink" title="超链接（常用😘）"></a>超链接（常用😘）</h3><p><code>[超链接名](超链接地址 &quot;可选超链接title&quot;)</code></p><blockquote><p>tips: hexo中需变量：<code>&#123;% post_link 效率神器——Alfred %&#125;</code></p></blockquote><p>效果：</p><a href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/" title="效率神器——Alfred">效率神器——Alfred</a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p><code>- + *</code> 均可</p><p>如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 小明<br><span class="hljs-bullet">-</span> 小美<br><span class="hljs-bullet">-</span> 小羊<br></code></pre></td></tr></table></figure><p>效果：</p><ul><li>小明</li><li>小美</li><li>小羊</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 小明<br><span class="hljs-bullet">2.</span> 小美<br><span class="hljs-bullet">3.</span> 小羊<br></code></pre></td></tr></table></figure><p>效果：</p><ol><li>小明</li><li>小美</li><li>小羊</li></ol><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>在上一级与下一级间以3个空格作为开头即可，效果：</p><ol><li>小明<ol><li>明之子</li><li>明之女</li></ol></li><li>小美<ol><li>美之子</li><li>美之女</li></ol></li><li>小羊<ol><li>羊之子</li><li>羊之女</li></ol></li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</code>，用法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><p>设置表格的对齐方式：</p><ol><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ol><p>以 <a href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Oh-My-Zsh中Git的常用快捷键">Oh-My-Zsh中Git的常用快捷键</a> 这篇文章用到的为例，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">快捷键|完整写法<br>|:-|:-|<br>g|git<br>gaa|git add .<br>gcmsg|git commit -m<br>gcb|git checkout -b<br>gst|git status<br>gf|git fetch<br>gl|git pull<br>gup|git pull --rebase<br>grb|git rebase<br>gsta|git stash save<br>gstp|git stash pop<br>gcp|git cherry-pick<br>mg|git merge<br>gp|git push<br></code></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">快捷键</th><th align="left">完整写法</th></tr></thead><tbody><tr><td align="left">g</td><td align="left">git</td></tr><tr><td align="left">gaa</td><td align="left">git add .</td></tr><tr><td align="left">gcmsg</td><td align="left">git commit -m</td></tr><tr><td align="left">gcb</td><td align="left">git checkout -b</td></tr><tr><td align="left">gst</td><td align="left">git status</td></tr><tr><td align="left">gf</td><td align="left">git fetch</td></tr><tr><td align="left">gl</td><td align="left">git pull</td></tr><tr><td align="left">gup</td><td align="left">git pull –rebase</td></tr><tr><td align="left">grb</td><td align="left">git rebase</td></tr><tr><td align="left">gsta</td><td align="left">git stash save</td></tr><tr><td align="left">gstp</td><td align="left">git stash pop</td></tr><tr><td align="left">gcp</td><td align="left">git cherry-pick</td></tr><tr><td align="left">mg</td><td align="left">git merge</td></tr><tr><td align="left">gp</td><td align="left">git push</td></tr></tbody></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`单行代码`</span><br></code></pre></td></tr></table></figure><h4 id="代码块（用的很多😘）"><a href="#代码块（用的很多😘）" class="headerlink" title="代码块（用的很多😘）"></a>代码块（用的很多😘）</h4><p>用法如图：</p><p><img src="/images/markdown-block.png" alt="代码块"></p><blockquote><p>tips: &#96;&#96;&#96;后跟js代表当前是JavaScript的代码块，方便高亮。</p></blockquote><p>效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Demo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，平常用的 Markdown 语法主要是以上介绍的这些，已经足够应付日常的写作~</p><p>如果以后有用到其他的语法，我会继续补充本文章滴~😎</p><p>对了，补充一个 VS Code 插件 <code>Markdown All in One</code>， 可以实时预览~</p><p><img src="/images/markdown-profile.png" alt="Markdown All in One 插件实时预览"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率神器——Alfred</title>
    <link href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/"/>
    <url>/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如Alfred官方所述：Alfred是一款屡获殊荣的macOS应用程序，可通过热键，关键字，文本扩展等功能提高您的效率。搜索Mac和网页的内容，并通过自定义操作来控制Mac来提高生产力。😍</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Alfred与Mac自带的“聚焦”有何区别呢？简单来说，Alfred就是一个更强大的“聚焦”。</p><p>本文将介绍本羊自己用的比较多的功能，如粘贴板、终端、搜索文件、搜索文件内部内容等。</p><p>直接按下 <code>⌥ + 空格</code> 唤出 Alfred，基本操作就不多介绍了，直接开始！！</p><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ol><li><p>剪贴板（强烈推荐！！🤩）</p><p>电脑换成MacBook以后，我发现macOS上竟然没有那个极其方便的功能 —— <strong>剪切板😱</strong>！！</p><p>在Windows系统上，可以一次性复制多个项，然后只需按下 <code>Win + V</code> 唤出剪切板，即可方便快捷地进行批量粘贴操作。</p><p>而macOS没有该功能！！😩 作为一名 <del>Ctrl CV工程师</del> 需要经常用到该功能的程序员，当然不可接受。而Alfred，让你不用额外安装剪切板软件，即可实现该功能。🤩</p><p>使用方法：<code>⌥ + ⌘ + C</code></p><p><img src="/images/alfred/clipboard.png" alt="剪切板"></p><p>支持文本、图片~</p></li><li><p>搜索</p><ol><li><p>浏览器搜索（支持检索浏览器历史记录、书签、搜索引擎）</p><p><img src="/images/alfred/browser-search.png" alt="浏览器搜索"></p></li><li><p>本地搜索（文件搜索、文件内部内容搜索）</p><p>文件搜索： <code>&#39;</code>（或者在设置里直接设置成空格），接内容即可检索文件。</p><p><img src="/images/alfred/file-search.png" alt="文件搜索"></p><p>文件内部内容搜索： <code>in</code> 接内容即可检索文件。例如，我这篇文章的摘要包含了“<strong>屡获殊荣</strong>”四个字，因此本文件也被检索到了🤩</p><p><img src="/images/alfred/in-search.png" alt="文件内容搜索"></p></li><li><p>其他自定义搜索（如在指定网站搜索，例如YouTube、MDN、StackOverflow）</p><p><img src="/images/alfred/YouTube-search.png" alt="油管搜索李子柒🤩"></p></li></ol></li><li><p>自定义文本片（Snippet）</p><p>需要经常输入指定内容？太长不想手打？<strong>自定义文本片</strong> 了解一下😎。</p><p><img src="/images/alfred/snp-setting.png" alt="用法非常简单"></p><p>用法：<code>snip 关键词</code> ，输入关键字后，会自动弹出自定义内容。日常用法：每次写东西前习惯标个今天日期，可以自定义 <code>&#123;date&#125;</code> 即可代表今天。使用时，只需 <code>snip today</code> 然后回车，自动生成2021-04-22🤩</p><p><img src="/images/alfred/snp-id.png" alt="身份证太长不想输咋办"></p></li><li><p>直接输入终端命令</p><p>不想每次打开终端再输入命令执行咋办？直接 <code>&gt;命令</code> 了解一下🤩</p><p><img src="/images/alfred/alfred-terminal.png" alt="直接执行命令"></p><p><img src="/images/alfred/terminal-date.png" alt="效果"></p><p>注意，Alfred默认使用默认终端，若想使用 <code>iterm</code> ，可以在Alfred里选Terminal-“自定义”，配置如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs AppleScript"><span class="hljs-keyword">on</span> alfred_script(q)<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;iTerm2&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;iTerm&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">run script</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">      on run &#123;q&#125;</span><br><span class="hljs-string">        tell application \&quot;iTerm\&quot;</span><br><span class="hljs-string">          activate</span><br><span class="hljs-string">          try</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">            set onlywindow to true</span><br><span class="hljs-string">          on error</span><br><span class="hljs-string">            create window with default profile</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">            set onlywindow to true</span><br><span class="hljs-string">          end try</span><br><span class="hljs-string">          tell the first window</span><br><span class="hljs-string">            if onlywindow is false then</span><br><span class="hljs-string">              create tab with default profile</span><br><span class="hljs-string">            end if</span><br><span class="hljs-string">            tell current session to write text q</span><br><span class="hljs-string">          end tell</span><br><span class="hljs-string">        end tell</span><br><span class="hljs-string">      end run</span><br><span class="hljs-string">    &quot;</span> <span class="hljs-keyword">with</span> parameters &#123;q&#125;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">run script</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">      on run &#123;q&#125;</span><br><span class="hljs-string">        tell application \&quot;iTerm\&quot;</span><br><span class="hljs-string">          activate</span><br><span class="hljs-string">          try</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">          on error</span><br><span class="hljs-string">            create window with default profile</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">          end try</span><br><span class="hljs-string">          tell the first window</span><br><span class="hljs-string">            tell current session to write text q</span><br><span class="hljs-string">          end tell</span><br><span class="hljs-string">        end tell</span><br><span class="hljs-string">      end run</span><br><span class="hljs-string">    &quot;</span> <span class="hljs-keyword">with</span> parameters &#123;q&#125;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><span class="hljs-keyword">end</span> alfred_script<br></code></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多其他常用功能及强大的Workflow日后继续补充，更多使用方法可参考 <a href="https://www.alfredapp.com/">Alfred官方</a>~😎</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>效率</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法-JavaScript实现</title>
    <link href="/2021/04/10/06_%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/10/06_%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>前几天偶尔看到了一些排序算法的动态图，觉得非常生动且有助于理解。而自己也有一段时间没接触过各种算法了，因此决定整理一下，将他们拾起来 📝</p><span id="more"></span><h3 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h3><ol><li><p>稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p></li><li><p>非稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</p></li><li><p>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p></li><li><p>非原地排序：需要利用额外的数组来辅助排序。</p></li><li><p>时间复杂度：一个算法执行所消耗的时间。</p></li><li><p>空间复杂度：运行完一个算法所需的内存大小。</p></li></ol><p><img src="/images/algorithms/sort-table.jpg" alt="对比图"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>每次比较如果发现较小的元素在后面，就交换两个相邻的元素</p><p>每轮循环比较后，该轮最后一个值就是该轮最大的值（即大的沉底，小的浮起）</p></blockquote><p><img src="/images/algorithms/bubble.gif" alt="冒泡排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// 每轮都会排好一个</span><br>      <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br>        [array[j], array[j + <span class="hljs-number">1</span>]] = [array[j + <span class="hljs-number">1</span>], array[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序是冒泡排序的改进。</p><p>选择排序先并不急于调换位置，而是每轮看哪个数最小就记下该数所在的位置minIndex，等该轮扫描完毕，再让最小值和当前指定值对换，这样一来每一轮比较都只需要换一次位置。</p><p>缺点：不是稳定排序。</p></blockquote><p><img src="/images/algorithms/select.gif" alt="选择排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> minIndex;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    minIndex = i; <span class="hljs-comment">// 假设本轮的第一个值为最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; array.<span class="hljs-property">length</span>; j++) &#123; <span class="hljs-comment">// 默认第一个已排好</span><br>      <span class="hljs-keyword">if</span> (array[j] &lt; array[minIndex]) &#123;<br>        minIndex = j<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i !== minIndex) &#123;  <span class="hljs-comment">//如果该最小值和原最小值不同，则交换其值</span><br>      [array[i], array[minIndex]] = [array[minIndex], array[i]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>重点：部分有序。将无序部分和有序部分进行比较，然后插入对应位置。</p><p>首先要实现局部有序：直接把第一个元素看成有序。</p><p>数据规模越小、数据有序程度越高，越高效（移动少）</p></blockquote><p><img src="/images/algorithms/insert.gif" alt="插入排序"></p><p>代码实现：</p><p>方法1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort1</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    temp = array[i]; <span class="hljs-comment">// 每轮取出当前值，避免被覆盖。</span><br>    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>  &amp;&amp; array[j] &gt; temp) &#123;<br>      array[j + <span class="hljs-number">1</span>] = array[j];<br>      j--;<br>    &#125;<br>    array[j + <span class="hljs-number">1</span>] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort2</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp, i, j;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    temp = array[i];<br>    <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (array[j] &gt; temp) &#123;<br>        array[j + <span class="hljs-number">1</span>] = array[j];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 务必跳出该轮循环，避免往下执行</span><br>      &#125;<br>    &#125;<br>    array[j + <span class="hljs-number">1</span>] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>希尔排序是插入排序的改进。</p><p>当数据规模较大时或有序程度不高时，插入排序的元素移动次数较多，插入效率不高。为了解决这个问题，希尔排序出现了。</p><p>希尔排序把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高。</p></blockquote><p><strong>实现过程</strong>：先让数组中任意间隔为 gap 的元素有序，刚开始 gap 的大小可以是 gap &#x3D; n &#x2F; 2，接着让 gap &#x3D; n &#x2F; 4，让 gap 一直缩小，当 gap &#x3D; 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p><img src="/images/algorithms/Shell.gif" alt="希尔排序"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shellSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = array.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> gap = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//gap不断减小</span><br><br>    <span class="hljs-comment">// 相当于一个有间隔的插入排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i += gap) &#123;<br>      temp = array[i];<br>      <span class="hljs-keyword">let</span> j = i;<br>      <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; array[j - gap] &gt; temp) &#123;<br>        array[j] = array[j - gap];<br>        j -= gap;<br>      &#125;<br>      array[j] = temp;<br>    &#125;<br><br>    gap = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(gap / <span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序的基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p><img src="/images/algorithms/quick.gif" alt="快速排序"></p><p>代码实现：</p><p>简单版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr = []</span>) &#123;<br>  <span class="hljs-comment">// 当数组长度小于等于1时，直接返回数组</span><br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">const</span> left = [];<br>  <span class="hljs-keyword">const</span> right = [];<br>  <span class="hljs-keyword">const</span> pivot = arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 比指定值大的，推进右数组，否则推进左数组</span><br>    arr[i] &gt; pivot ? right.<span class="hljs-title function_">push</span>(arr[i]) : left.<span class="hljs-title function_">push</span>(arr[i]);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quickSort</span>(left), pivot, ...<span class="hljs-title function_">quickSort</span>(right)];<br>&#125;<br></code></pre></td></tr></table></figure><p>标准版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr = []</span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac必备神器——Homebrew</title>
    <link href="/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/"/>
    <url>/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/</url>
    
    <content type="html"><![CDATA[<p>你是否曾经：想安装某个软件，却发现 App Store 没有上架该软件（例如VS Code）🤬，然后需要进行：打开搜索引擎搜索进入官网、下载、安装、删除安装包……一系列烦人操作？如果是，看万这篇文章，相信你会直呼“<strong>相见恨晚🥺</strong>”</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <a href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/" title="MacBook前端开发必备清单">MacBook前端开发必备清单</a> 中，本羊简要介绍了下 HomeBrew ，如果你没看过那篇文章，这里本羊再当一遍复读机：</p><blockquote><p><a href="https://brew.sh/index_zh-cn">Homebrew</a> 是一款用于 macOS 的开源的软件包管理器，能够帮助你快速下载软件。</p></blockquote><p>   <strong>那为什么要选Homebrew？</strong></p><p>   一般情况下，在 Mac 上安装软件程序，通常是在 Mac App Store 搜索，然后安装。但是，对于不在 Mac App Store 上架的软件，你需要：</p><ol><li><p>先在搜索引擎中搜索，找到官网，</p></li><li><p>然后打开下载页面下载，</p></li><li><p>最后再将下载的安装包拖到「软件程序」文件夹或执行安装。</p></li><li><p>清理安装包</p></li></ol><p>   这也太麻烦了吧😅😅😅</p><p>   而使用Homebrew，你只需要在终端输入一行命令，就可以解决包括查找、下载和安装软件的一系列步骤。</p><p>   例如安装Chrome浏览器，你只需在终端输入：</p><p>   <code>brew install google-chrome</code></p><p>   例如安装git：</p><p>   <code>brew install git</code></p><p>   是不是非常简单快捷？👏👏👏 不多啰嗦，直奔主题吧！</p><h2 id="安装及用法"><a href="#安装及用法" class="headerlink" title="安装及用法"></a>安装及用法</h2><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>在终端输入：</p><p><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在以前，安装软件需要特意注明 <code>install cask</code> ，现在可以直接 <code>install</code> 想要安装的软件即可：</p><p><code>brew install 软件名</code></p><p>以安装强大的 IINA 播放器为例子，如下图：</p><p><img src="/images/brew-install.jpg" alt="安装 IINA"></p><p>tips: 安装的软件位于 usr&#x2F;local&#x2F;Caskroom 目录下。</p><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p><code>brew uninstall iina</code></p><p><img src="/images/brew-uninstall.jpg" alt="卸载 IINA"></p><h3 id="显示所有的已安装的软件"><a href="#显示所有的已安装的软件" class="headerlink" title="显示所有的已安装的软件"></a>显示所有的已安装的软件</h3><p><code>brew list</code></p><h3 id="升级homebrew-（从github下载最新版本）"><a href="#升级homebrew-（从github下载最新版本）" class="headerlink" title="升级homebrew （从github下载最新版本）"></a>升级homebrew （从github下载最新版本）</h3><p><code>brew update</code></p><p>更多 brew 命令及可安装的软件可查看 <a href="https://brew.sh/index_zh-cn">Homebrew</a> 官网。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>安装 Homebrew 以后，大幅提高了软件管理效率，告别了</p><blockquote><p>“要安装，请拖动此图标……”</p></blockquote><p>再也不再需要像以前一样进行繁琐的操作了~🥳</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>当 App Store 的微信版本还停留在2.6时，谁又想到在 Homebrew 上微信已经更新了3.0版本呢？😎</p><p><code>brew install wechat</code></p><p><img src="/images/wechat-tips.jpg" alt="微信 3.0"></p><p>既然是3.0版本，那就可以直接在电脑上刷朋友圈了！🤣</p><p><img src="/images/wechat-moment.jpg" alt="微信 朋友圈"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oh-My-Zsh中Git的常用快捷键</title>
    <link href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>每次使用Git都要输入太多重复内容？Oh-My-Zsh的Git捷键帮到你~🤩</p><span id="more"></span><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>下面将展示 Oh-My-Zsh 中 Git 的快捷键，第一部分的“常用快捷键”已经涵盖了日常大部分使用场景。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th>快捷键</th><th align="left">完整写法</th></tr></thead><tbody><tr><td>g</td><td align="left">git</td></tr><tr><td>gaa</td><td align="left">git add .</td></tr><tr><td>gcmsg</td><td align="left">git commit -m</td></tr><tr><td>gcb</td><td align="left">git checkout -b</td></tr><tr><td>gst</td><td align="left">git status</td></tr><tr><td>gf</td><td align="left">git fetch</td></tr><tr><td>gl</td><td align="left">git pull</td></tr><tr><td>gup</td><td align="left">git pull –rebase</td></tr><tr><td>grb</td><td align="left">git rebase</td></tr><tr><td>gsta</td><td align="left">git stash save</td></tr><tr><td>gstp</td><td align="left">git stash pop</td></tr><tr><td>gcp</td><td align="left">git cherry-pick</td></tr><tr><td>mg</td><td align="left">git merge</td></tr><tr><td>gp</td><td align="left">git push</td></tr></tbody></table><h3 id="完整版快捷键"><a href="#完整版快捷键" class="headerlink" title="完整版快捷键"></a>完整版快捷键</h3><p>上面的常用快捷键已经涵盖日常大部分使用场景，如果你还需要更详尽的信息，可以查看Oh-My-Zsh官方GitHub的Git插件源码：</p><p><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/git.plugin.zsh">git.plugin.zsh</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终端体验提升计划-iTerm2 + Oh-My-Zsh</title>
    <link href="/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/"/>
    <url>/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/</url>
    
    <content type="html"><![CDATA[<p>如何让你的终端用起来顺手又炫酷？看完本文，将让你的终端体验大幅提升😎</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/" title="MacBook前端开发必备清单">MacBook前端开发必备清单</a> 中展示了MacBook前端开发的必备清单，本文将介绍其一： <strong>iTerm2 + Oh-My-Zsh</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p><a href="https://iterm2.com/">iTerm2</a></p><blockquote><p>iTerm2是默认终端的替代品，也是目前Mac系统下最好用的终端工具，集颜值和效率于一身。</p></blockquote></li><li><p><a href="https://ohmyz.sh/">Oh-My-Zsh</a></p><blockquote><p>Oh My Zsh 是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。 它基于Zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。它能让你用了直呼： <strong>“Oh My ZSH!” 🤣👏</strong> （它官网的确是这么说的哈哈哈哈）</p></blockquote></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>iTerm2</p><p>安装：</p><p>可以使用上一篇博客提到的Homebrew来安装：<code>brew install iterm2</code></p><p>也可以直接到 <a href="https://iterm2.com/">iTerm2</a> 官网下载</p></li><li><p>Oh-My-Zsh</p><p>安装：</p><p><code>sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></p></li></ol><h2 id="配置及使用"><a href="#配置及使用" class="headerlink" title="配置及使用"></a>配置及使用</h2><p>配置主题的前提：</p><blockquote><ol><li>安装了 zsh</li><li>安装了 powerline 字体</li><li>安装方法参考：<a href="https://github.com/powerline/fonts">https://github.com/powerline/fonts</a></li></ol></blockquote><ol><li><p>iTerm2</p><p>先设置字体：</p><p>进入偏好设置 -&gt; Profiles -&gt; Text -&gt; Font -&gt; 选择 <code>Meslo LG S for PowerLine</code></p></li><li><p>Oh-My-Zsh</p></li></ol><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>   打开zsh配置：<code>vim ~/.zshrc</code></p><p>   修改主题：<code>ZSH_THEME=&quot;agnoster&quot;</code> 个人觉得agnoster主题最好看😍</p><p>   生效：<code>source ~/.zshrc</code></p><p>   <img src="/images/theme-show.png" alt="agnoster主题展示及自动补全插件"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件有自带的Git，让你可以使用简写，如：</p><p><code>gaa</code> 就是 <code>git add --all</code></p><p>更多常用git快捷键可以看 <a href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Oh-My-Zsh中Git的常用快捷键">Oh-My-Zsh中Git的常用快捷键</a></p><p>此外，还强烈建议装上以下的插件：</p><ol><li><p>zsh-autosuggestion，命令建议和补全</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cd ~/.oh-my-zsh/custom/plugins/<br>git clone https://github.com/zsh-users/zsh-autosuggestions<br></code></pre></td></tr></table></figure></li><li><p>zsh-syntax-highlighting，代码高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cd ~/.oh-my-zsh/custom/plugins/<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git<br></code></pre></td></tr></table></figure></li><li><p>z， 快速跳转到对应目录，让你不再疯狂输入cd</p><p>只要你输入过该路径，以后你便可以直接使用 <code>z 该目录</code> 直接进入该目录，如下：</p></li></ol><p>  <img src="/images/z.jpg" alt="z快速跳转"></p><p>   由于 <code>z</code> 是 zsh 内置的，所以只需在 plugins中加入 z 即可</p><p>输入 <code>vim ~/.zshrc</code> 进入 .zshrc ，按 <code>i</code> 进入编辑状态，找到plugins，输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">plugins=(<br>  git<br>  zsh-autosuggestions<br>  zsh-syntax-highlighting<br>  z<br>)<br></code></pre></td></tr></table></figure><p>然后在文件的最后一行添加：</p><p><code>source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></p><p>输入完成后，点击键盘<code>esc</code>键退出编辑模式，然后输入<code>:wq</code> 保存并退出，最后执行命令 <code>source ~/.zshrc</code> 使刚才的修改生效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上步骤，你拥有了：</p><ol><li>非常好看的终端</li><li>提高效率的插件：代码高亮、自动补全、快速路径跳转、Git命令快捷键</li></ol><p>快去试试吧😎</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacBook前端开发必备清单</title>
    <link href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/"/>
    <url>/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>当你使用一台MacBook进行前端开发时，有哪些软件或工具是 <strong>“装机必备”</strong>？</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本羊现在用的是16寸MacBook Pro，于2020年初购买，那为什么现在会想写一篇MacBook装机清单的博客呢？因为我上个月电脑主板突然坏了，然后去授权店修了2个星期，除了少数放在桌面的文件能被iCloud恢复，其余存储的内容全没了😭😭😭（以后一定要做好备份）。</p><p>然后我就得重新配置电脑的开发环境，于是就有了这一篇博客：MacBook前端开发必备清单。</p><p>目前电脑的系统是Big Sur 11.2.3，并已安装下面推荐的必备清单并运行良好，现在电脑用起来十分舒服。</p><p><strong>OK，正文开始！</strong></p><h2 id="前端开发必备清单"><a href="#前端开发必备清单" class="headerlink" title="前端开发必备清单"></a>前端开发必备清单</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p><code>Git、Node、Yarn</code></p><p>最最基本必备的</p></li><li><p><code>VS Code</code></p><p>强推！刚入门前端的时候用的是Webstorm。一次偶然的机会用到了VS Code，一秒沦陷，各种插件太舒服了！如果一定要我从这么多插件中只选3样，那我必须推荐（太热门的就不特意推荐了哈哈哈）：</p><p><strong>Image preview</strong></p><p><strong>Git Graph</strong></p><p><strong>别名路径跳转</strong></p><p>PS: 一定要开启设置同步（登录后能自动同步设置、插件等），所以我能轻松在我个人笔记本和公司台式之间反复横跳开发。</p></li><li><p><code>Chrome</code></p><p>最强大的浏览器（没有之一😎），强烈推荐登录谷歌账号、安装扩展，强烈推荐以下扩展：</p><p><strong>Infinity Pro</strong>：超好看的首页</p><p><strong>uBlock Origin</strong>：过滤一切广告及干扰，让你清爽网上冲浪</p><p><strong>OneTab</strong>：有时候浏览器必须打开很多标签，但又不想关掉，OneTab就是必备的了，很方便，一键收纳标签，节省内存</p></li><li><p><code>Charles</code></p><p>抓包工具，方便移动端调试。</p></li></ol><h3 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h3><ol><li><p>iTerm2 和 oh-my-zsh</p><p>此神仙组合能让你的终端好用一万倍🤩🤩🤩，详细配置文章看这里：</p><a href="/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/" title="终端体验提升计划-iTerm2 + Oh-My-Zsh">终端体验提升计划-iTerm2 + Oh-My-Zsh</a></li><li><p><a href="https://brew.sh/index_zh-cn">Homebrew</a></p><p>HomeBrew 是一款用于 macOS 的开源的软件包管理器，能够帮助你快速下载软件。</p><p><strong>那为什么要选Homebrew？</strong></p><p>一般情况下，在 Mac 上安装软件程序，通常是在 Mac App Store 搜索，然后安装。但是，对于不在 Mac App Store 上架的软件，你需要：</p><ol><li><p>先在搜索引擎中搜索，找到官网，</p></li><li><p>然后打开下载页面下载，</p></li><li><p>最后再将下载的安装包拖到「软件程序」文件夹或执行安装。</p></li><li><p>清理安装包</p></li></ol><p>这也太麻烦了吧😅😅😅</p><p>而使用Homebrew，你只需要在终端输入一行命令，就可以解决包括查找、下载和安装软件的一系列步骤。</p><p>例如安装Chrome浏览器，你只需在终端输入：</p><p><code>brew install google-chrome</code></p><p>例如安装git：</p><p><code>brew install git</code></p><p>是不是非常简单快捷？👏👏👏</p><p>Homebrew的具体说明请看这里：</p><a href="/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/" title="Mac必备神器——Homebrew">Mac必备神器——Homebrew</a></li><li><p>Alfred</p><p>Alfred 是一款能让你提高效率的神器，它比Mac自带的“聚焦”有更强大的功能。它能：帮你快速打开网页、快速进行自定义搜索、查看剪贴板历史、快速查询单词等等。</p><p>Alfred 提供的功能虽然很多，但目的只有一个 —— 减少我们工作中的一些重复动作，提升我们的工作效率。</p><p>具体安装及使用请看这里：<a href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/" title="效率神器——Alfred">效率神器——Alfred</a></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的“必备清单”只是我个人的推荐，你可以根据自己喜好自行选择。例如上面的</p><blockquote><p>进阶配置</p></blockquote><p>如果不愿意折腾，其实可以忽略。平常使用原生终端及Mac自带的“聚焦”也足矣。但是如果你想提高开发体验，提交效率，那我还是建议你安装😋😋😋</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>记录</tag>
      
      <tag>前端</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建指南（Hexo）</title>
    <link href="/2021/03/28/01_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/03/28/01_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><em><strong>如何搭建一个属于自己的在线博客呢？自动打包和部署如何实现？</strong></em> 🤩🤩🤩</p><span id="more"></span><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>在大学某一天，无意间看到了别人的博客网站，这个网站记录了他的学习历程、技术分享文章及日常感想等。当时我觉得这也太酷了吧，于是就萌生了一个搭建个属于自己的博客的想法~</p><p>想法虽然萌生了，但是我并没有立刻行动，一来是当时自己还是个学生，直接被服务器价格劝退了（当时也不知道 Github Pages 怎么用）；二是其实自己平常也有做笔记、做心得记录的习惯，只不过用的是云笔记，记录的知识点也比较任性杂乱（毕竟不用给他人阅读哈哈哈😂）。这样一来二去便作罢了。</p><p><img src="/images/stickers/WTF.jpeg" alt="当我看到服务器价格时"></p><p>但今天，我突然回想起来自己曾经的想法，这想法直接把我从床上拎起来，仿佛在催促我：“赶紧去把这个想法圆了！”</p><p>于是，我动手了。</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><p>本次搭建博客对比了 Hexo、VuePress、Gatsby 3款框架，最终选择了Hexo，因为<strong>主题多</strong>！🤩</p><p>首先确保电脑已经安装 node、npm、git，及已经注册了GitHub账号（需要用Github Pages），这里不赘述。</p><h4 id="安装Hexo脚手架"><a href="#安装Hexo脚手架" class="headerlink" title="安装Hexo脚手架"></a>安装Hexo脚手架</h4><p><code>sudo npm install hexo-cli -g</code> (若是window系统，则不用加sudo命令)</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p><code>hexo init blog</code></p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p><code>npm install</code></p><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><code>hexo server</code></p><p>此时，项目已经能正常展示。</p><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>但是，默认主题并不好看，配一个符合自己审美的主题，例如我的是 <strong>Fluid</strong> (Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令)</p><p><code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 <strong>_config.fluid.yml</strong> ，将主题的 [_config.yml]。</p><p>打开 <strong>_config.yml</strong> 文件，可根据安装的主题修改对应的主题名称（theme）、语言（language）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h5 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h5><p>首次使用主题的「关于页」需要手动创建：</p><p><code>hexo new page about</code></p><p>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-03-28 20:54:55</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><h3 id="使用-GitHub-Pages-实现博客在线访问"><a href="#使用-GitHub-Pages-实现博客在线访问" class="headerlink" title="使用 GitHub Pages 实现博客在线访问"></a>使用 <strong>GitHub Pages</strong> 实现博客在线访问</h3><h4 id="用GitHub部署站点有2种方式"><a href="#用GitHub部署站点有2种方式" class="headerlink" title="用GitHub部署站点有2种方式"></a>用GitHub部署站点有2种方式</h4><ol><li><p><code>https://[username].github.io</code> （适合博客😎）</p><p>优点：路径足够短</p><p>注意：仓库名必须为 <code>[username].github.io</code>；打包产物分支 <strong>master</strong></p></li><li><p><code>https://[username].github.io/[repo]</code> (适合作为开源项目或者Demo的展示页面)</p><p>优点：可以自定义仓库名称repo</p><p>注意：打包产物分支 <strong>gh-pages</strong></p></li></ol><p>建好仓库以后，使用Git初始化本地项目，并推送到远程仓库。</p><h4 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h4><ol><li><p>首先，我们需要安装一个依赖：<code>hexo-deployer-git</code>，它能帮助我们将代码部署到一个具体的分支。</p></li><li><p>安装好后，打开 <strong>_config.yml</strong> 文件，拉到底部，修改deploy配置，如下图 <img src="/images/deploy-setting.png" alt="deploy配置"></p></li><li><p>执行命令 <code>npm run deploy</code></p></li><li><p>打开GitHub，可以看到打包产物已经被提交到master分支上</p></li><li><p>打开仓库Setting，找到GitHub Pages，可以看到你部署的站点</p></li><li><p>点击链接，发现博客可以在线访问了！🥳🥳🥳</p></li></ol><h3 id="GitHub-Actions-自动化部署"><a href="#GitHub-Actions-自动化部署" class="headerlink" title="GitHub Actions 自动化部署"></a><strong>GitHub Actions</strong> 自动化部署</h3><p>好了，经过以上操作，我们已经拥有了一个属于自己的在线博客站点。</p><p>但是！有一个问题：<strong>我不想每次写完博客都要自己手动打包部署怎么办</strong>🥺？</p><p>正所谓，<del>懒是第一生产力（bushi）</del>，科技是第一生产力，GitHub Actions 帮助你。</p><p>我们可以利用 GitHub Actions 的<strong>自动打包和代码部署</strong>功能。</p><p>在此做自动化部署之前，由于master分支已经被占用，所以我们本地新建一个blog分支，提交代码并push到远程仓库。</p><h4 id="实现自动化部署步骤"><a href="#实现自动化部署步骤" class="headerlink" title="实现自动化部署步骤"></a>实现自动化部署步骤</h4><ol><li>根目录下创建 .github 文件夹，进入该文件夹并创建 workflows 文件夹</li><li>在 workflows 文件夹里创建一个 deploy.yml 文件，内部具体配置代码可以看这里：<a href="../../.github/workflows/deploy.yml">deploy.yml</a></li><li>提交代码，并push到远程仓库</li></ol><p>执行完Git push后，打开GitHub，可以看到blog分支右侧出现了一个小黄点，它代表 GitHub Actions 正在被触发，随后，博客被自动更新。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了！经过以上步骤，以后我们在blog分支上写完博客，本地无需执行打包和部署，只需提交代码，然后Git push即可，博客内容会被<strong>自动更新👏👏👏</strong></p><p>本羊的第一篇博客完工！<strong>🤣🤣🤣</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>博客</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
