<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024，Python爬虫系统入门与多领域实战</title>
    <link href="/2024/06/12/2024%EF%BC%8CPython%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E4%B8%8E%E5%A4%9A%E9%A2%86%E5%9F%9F%E5%AE%9E%E6%88%98/"/>
    <url>/2024/06/12/2024%EF%BC%8CPython%E7%88%AC%E8%99%AB%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E4%B8%8E%E5%A4%9A%E9%A2%86%E5%9F%9F%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>在网络爬虫和数据抓取领域，Python的<code>requests</code>库和<code>XPath</code>语法是非常重要的工具。<code>requests</code>库用于发送HTTP请求，从网页上获取数据；<code>XPath</code>则是一种查询语言，用于在XML或HTML文档中查找信息。本教程将详细介绍这两个工具的使用方法及其在实际开发中的应用。</p><h2 id="第一部分：Requests库"><a href="#第一部分：Requests库" class="headerlink" title="第一部分：Requests库"></a>第一部分：Requests库</h2><h3 id="1-1-Requests库简介"><a href="#1-1-Requests库简介" class="headerlink" title="1.1 Requests库简介"></a>1.1 Requests库简介</h3><p><code>requests</code>是Python的一个HTTP库，允许你发送HTTP请求，使用简单、易于理解的API接口。与Python内置的<code>urllib</code>相比，<code>requests</code>更加直观且功能丰富。</p><h3 id="1-2-安装Requests库"><a href="#1-2-安装Requests库" class="headerlink" title="1.2 安装Requests库"></a>1.2 安装Requests库</h3><p>你可以使用pip安装<code>requests</code>库：</p><div class="code-wrapper"><pre><code class="hljs bash">pip install requests</code></pre></div><h3 id="1-3-发送基本的HTTP请求"><a href="#1-3-发送基本的HTTP请求" class="headerlink" title="1.3 发送基本的HTTP请求"></a>1.3 发送基本的HTTP请求</h3><h4 id="1-3-1-GET请求"><a href="#1-3-1-GET请求" class="headerlink" title="1.3.1 GET请求"></a>1.3.1 GET请求</h4><p>GET请求用于从服务器获取数据。以下是一个简单的GET请求示例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsresponse = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<span class="hljs-built_in">print</span>(response.status_code)  <span class="hljs-comment"># 打印响应状态码</span><span class="hljs-built_in">print</span>(response.text)  <span class="hljs-comment"># 打印响应内容</span></code></pre></div><h4 id="1-3-2-POST请求"><a href="#1-3-2-POST请求" class="headerlink" title="1.3.2 POST请求"></a>1.3.2 POST请求</h4><p>POST请求用于向服务器提交数据。以下是一个简单的POST请求示例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsdata = &#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;response = requests.post(<span class="hljs-string">&#x27;https://httpbin.org/post&#x27;</span>, data=data)<span class="hljs-built_in">print</span>(response.status_code)<span class="hljs-built_in">print</span>(response.json())  <span class="hljs-comment"># 将响应内容解析为JSON格式</span></code></pre></div><h3 id="1-4-请求头和参数"><a href="#1-4-请求头和参数" class="headerlink" title="1.4 请求头和参数"></a>1.4 请求头和参数</h3><p>在发送请求时，你可能需要设置请求头或添加查询参数。</p><h4 id="1-4-1-设置请求头"><a href="#1-4-1-设置请求头" class="headerlink" title="1.4.1 设置请求头"></a>1.4.1 设置请求头</h4><div class="code-wrapper"><pre><code class="hljs python">headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;my-app/0.0.1&#x27;</span>&#125;response = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>, headers=headers)<span class="hljs-built_in">print</span>(response.status_code)</code></pre></div><h4 id="1-4-2-添加查询参数"><a href="#1-4-2-添加查询参数" class="headerlink" title="1.4.2 添加查询参数"></a>1.4.2 添加查询参数</h4><div class="code-wrapper"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-string">&#x27;requests+language:python&#x27;</span>&#125;response = requests.get(<span class="hljs-string">&#x27;https://api.github.com/search/repositories&#x27;</span>, params=params)<span class="hljs-built_in">print</span>(response.json())</code></pre></div><h3 id="1-5-处理响应"><a href="#1-5-处理响应" class="headerlink" title="1.5 处理响应"></a>1.5 处理响应</h3><p><code>requests</code>库提供了多种方法来处理HTTP响应。</p><h4 id="1-5-1-响应状态码"><a href="#1-5-1-响应状态码" class="headerlink" title="1.5.1 响应状态码"></a>1.5.1 响应状态码</h4><div class="code-wrapper"><pre><code class="hljs python">response = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<span class="hljs-built_in">print</span>(response.status_code)  <span class="hljs-comment"># 200表示成功</span></code></pre></div><h4 id="1-5-2-响应内容"><a href="#1-5-2-响应内容" class="headerlink" title="1.5.2 响应内容"></a>1.5.2 响应内容</h4><div class="code-wrapper"><pre><code class="hljs python">response = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<span class="hljs-comment"># 以文本形式获取响应内容</span><span class="hljs-built_in">print</span>(response.text)<span class="hljs-comment"># 以JSON格式获取响应内容</span><span class="hljs-built_in">print</span>(response.json())</code></pre></div><h4 id="1-5-3-响应头"><a href="#1-5-3-响应头" class="headerlink" title="1.5.3 响应头"></a>1.5.3 响应头</h4><div class="code-wrapper"><pre><code class="hljs python">response = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>)<span class="hljs-built_in">print</span>(response.headers)</code></pre></div><h3 id="1-6-超时和错误处理"><a href="#1-6-超时和错误处理" class="headerlink" title="1.6 超时和错误处理"></a>1.6 超时和错误处理</h3><h4 id="1-6-1-设置超时"><a href="#1-6-1-设置超时" class="headerlink" title="1.6.1 设置超时"></a>1.6.1 设置超时</h4><p>你可以使用<code>timeout</code>参数设置请求的超时时间：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    response = requests.get(<span class="hljs-string">&#x27;https://api.github.com&#x27;</span>, timeout=<span class="hljs-number">5</span>)    <span class="hljs-built_in">print</span>(response.status_code)<span class="hljs-keyword">except</span> requests.Timeout:    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求超时&#x27;</span>)</code></pre></div><h4 id="1-6-2-错误处理"><a href="#1-6-2-错误处理" class="headerlink" title="1.6.2 错误处理"></a>1.6.2 错误处理</h4><p>使用<code>requests</code>库处理HTTP错误非常简单：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    response = requests.get(<span class="hljs-string">&#x27;https://api.github.com/notfound&#x27;</span>)    response.raise_for_status()<span class="hljs-keyword">except</span> requests.HTTPError <span class="hljs-keyword">as</span> err:    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;HTTP error occurred: <span class="hljs-subst">&#123;err&#125;</span>&#x27;</span>)<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Other error occurred: <span class="hljs-subst">&#123;err&#125;</span>&#x27;</span>)</code></pre></div><h2 id="第二部分：XPath语法"><a href="#第二部分：XPath语法" class="headerlink" title="第二部分：XPath语法"></a>第二部分：XPath语法</h2><h3 id="2-1-XPath简介"><a href="#2-1-XPath简介" class="headerlink" title="2.1 XPath简介"></a>2.1 XPath简介</h3><p>XPath（XML Path Language）是一种用于在XML文档中查找信息的语言。XPath不仅可以在XML中使用，还可以在HTML中应用，非常适合用于网络爬虫数据提取。</p><h3 id="2-2-安装XPath工具"><a href="#2-2-安装XPath工具" class="headerlink" title="2.2 安装XPath工具"></a>2.2 安装XPath工具</h3><p>为了在Python中使用XPath，你需要安装<code>lxml</code>库：</p><div class="code-wrapper"><pre><code class="hljs bash">pip install lxml</code></pre></div><h3 id="2-3-XPath基础语法"><a href="#2-3-XPath基础语法" class="headerlink" title="2.3 XPath基础语法"></a>2.3 XPath基础语法</h3><h4 id="2-3-1-基本表达式"><a href="#2-3-1-基本表达式" class="headerlink" title="2.3.1 基本表达式"></a>2.3.1 基本表达式</h4><p>XPath表达式用来在XML或HTML文档中选择节点。以下是一些基本的XPath表达式：</p><div class="code-wrapper"><pre><code class="hljs xpath">/       # 从根节点选择//      # 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置.       # 选择当前节点..      # 选择当前节点的父节点@       # 选择属性</code></pre></div><h4 id="2-3-2-具体示例"><a href="#2-3-2-具体示例" class="headerlink" title="2.3.2 具体示例"></a>2.3.2 具体示例</h4><p>假设有以下HTML文档：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>以下是一些XPath表达式及其结果：</p><div class="code-wrapper"><pre><code class="hljs xpath">/html/body/div/h1   # 选择<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>节点</span><span class="language-xml">//p[@class=&#x27;content&#x27;]  # 选择class属性为content的</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>节点</span><span class="language-xml">//a/@href  # 选择</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>节点的href属性</span></code></pre></div><h3 id="2-4-在Python中使用XPath"><a href="#2-4-在Python中使用XPath" class="headerlink" title="2.4 在Python中使用XPath"></a>2.4 在Python中使用XPath</h3><p>你可以使用<code>lxml</code>库的<code>etree</code>模块来解析HTML文档并使用XPath查询。</p><h4 id="2-4-1-解析HTML文档"><a href="#2-4-1-解析HTML文档" class="headerlink" title="2.4.1 解析HTML文档"></a>2.4.1 解析HTML文档</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etreehtml = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">&lt;html&gt;</span><span class="hljs-string">  &lt;body&gt;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;h1&gt;Title&lt;/h1&gt;</span><span class="hljs-string">      &lt;p class=&quot;content&quot;&gt;Paragraph&lt;/p&gt;</span><span class="hljs-string">      &lt;a href=&quot;https://example.com&quot;&gt;Link&lt;/a&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">  &lt;/body&gt;</span><span class="hljs-string">&lt;/html&gt;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>tree = etree.HTML(html)</code></pre></div><h4 id="2-4-2-使用XPath查询"><a href="#2-4-2-使用XPath查询" class="headerlink" title="2.4.2 使用XPath查询"></a>2.4.2 使用XPath查询</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 选择&lt;h1&gt;节点的文本</span>h1_text = tree.xpath(<span class="hljs-string">&#x27;/html/body/div/h1/text()&#x27;</span>)<span class="hljs-built_in">print</span>(h1_text)  <span class="hljs-comment"># [&#x27;Title&#x27;]</span><span class="hljs-comment"># 选择class属性为content的&lt;p&gt;节点的文本</span>p_text = tree.xpath(<span class="hljs-string">&#x27;//p[@class=&quot;content&quot;]/text()&#x27;</span>)<span class="hljs-built_in">print</span>(p_text)  <span class="hljs-comment"># [&#x27;Paragraph&#x27;]</span><span class="hljs-comment"># 选择&lt;a&gt;节点的href属性</span>a_href = tree.xpath(<span class="hljs-string">&#x27;//a/@href&#x27;</span>)<span class="hljs-built_in">print</span>(a_href)  <span class="hljs-comment"># [&#x27;https://example.com&#x27;]</span></code></pre></div><h3 id="2-5-复杂查询示例"><a href="#2-5-复杂查询示例" class="headerlink" title="2.5 复杂查询示例"></a>2.5 复杂查询示例</h3><h4 id="2-5-1-示例HTML文档"><a href="#2-5-1-示例HTML文档" class="headerlink" title="2.5.1 示例HTML文档"></a>2.5.1 示例HTML文档</h4><p>假设有以下更复杂的HTML文档：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title 1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title 2<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span>&gt;</span>Link 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title 3<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>Paragraph 3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.org&quot;</span>&gt;</span>Link 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="2-5-2-查询所有标题和段落"><a href="#2-5-2-查询所有标题和段落" class="headerlink" title="2.5.2 查询所有标题和段落"></a>2.5.2 查询所有标题和段落</h4><div class="code-wrapper"><pre><code class="hljs python">html = <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">&lt;html&gt;</span><span class="hljs-string">  &lt;body&gt;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;h1&gt;Title 1&lt;/h1&gt;</span><span class="hljs-string">      &lt;p class=&quot;content&quot;&gt;Paragraph 1&lt;/p&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;h1&gt;Title 2&lt;/h1&gt;</span><span class="hljs-string">      &lt;p class=&quot;content&quot;&gt;Paragraph 2&lt;/p&gt;</span><span class="hljs-string">      &lt;a href=&quot;https://example.com&quot;&gt;Link 1&lt;/a&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">      &lt;h1&gt;Title 3&lt;/h1&gt;</span><span class="hljs-string">      &lt;p class=&quot;content&quot;&gt;Paragraph 3&lt;/p&gt;</span><span class="hljs-string">      &lt;a href=&quot;https://example.org&quot;&gt;Link 2&lt;/a&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">  &lt;/body&gt;</span><span class="hljs-string">&lt;/html&gt;</span><span class="hljs-string">&#x27;&#x27;&#x27;</span>tree = etree.HTML(html)<span class="hljs-comment"># 查询所有&lt;h1&gt;和&lt;p&gt;的文本</span>titles = tree.xpath(<span class="hljs-string">&#x27;//h1/text()&#x27;</span>)paragraphs = tree.xpath(<span class="hljs-string">&#x27;//p[@class=&quot;content&quot;]/text()&#x27;</span>)<span class="hljs-built_in">print</span>(titles)  <span class="hljs-comment"># [&#x27;Title 1&#x27;, &#x27;Title 2&#x27;, &#x27;Title 3&#x27;]</span><span class="hljs-built_in">print</span>(paragraphs)  <span class="hljs-comment"># [&#x27;Paragraph 1&#x27;, &#x27;Paragraph 2&#x27;, &#x27;Paragraph 3&#x27;]</span></code></pre></div><h4 id="2-5-3-查询所有链接的URL和文本"><a href="#2-5-3-查询所有链接的URL和文本" class="headerlink" title="2.5.3 查询所有链接的URL和文本"></a>2.5.3 查询所有链接的URL和文本</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 查询所有&lt;a&gt;节点的href属性和文本</span>links = tree.xpath(<span class="hljs-string">&#x27;//a&#x27;</span>)link_info = [(link.xpath(<span class="hljs-string">&#x27;@href&#x27;</span>)[<span class="hljs-number">0</span>], link.xpath(<span class="hljs-string">&#x27;text()&#x27;</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links]<span class="hljs-built_in">print</span>(link_info)  <span class="hljs-comment"># [(&#x27;https://example.com&#x27;, &#x27;Link 1&#x27;), (&#x27;https://example.org&#x27;, &#x27;Link 2&#x27;)]</span></code></pre></div><h3 id="2-6-结合Requests和XPath进行网络爬虫"><a href="#2-6-结合Requests和XPath进行网络爬虫" class="headerlink" title="2.6 结合Requests和XPath进行网络爬虫"></a>2.6 结合Requests和XPath进行网络爬虫</h3><h4 id="2-6-1-示例：爬取一个网页的标题和段落"><a href="#2-6-1-示例：爬取一个网页的标题和段落" class="headerlink" title="2.6.1 示例：爬取一个网页的标题和段落"></a>2.6.1 示例：爬取一个网页的标题和段落</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etreeurl = <span class="hljs-string">&#x27;https://example.com&#x27;</span><span class="hljs-comment"># 发送GET请求</span>response = requests.get(url)<span class="hljs-comment"># 解析HTML文档</span>tree = etree.HTML(response.text)<span class="hljs-comment"># 查询所有&lt;h1&gt;和&lt;p&gt;的文本</span>titles = tree.xpath(<span class="hljs-string">&#x27;//h1/text()&#x27;</span>)paragraphs = tree.xpath(<span class="hljs-string">&#x27;//p[@class=&quot;content&quot;]/text()&#x27;</span>)<span class="hljs-built_in">print</span>(titles)<span class="hljs-built_in">print</span>(paragraphs)</code></pre></div><h4 id="2-6-2-示例：爬取一个网页的所有链接"><a href="#2-6-2-示例：爬取一个网页的所有链接" class="headerlink" title="2.6.2 示例：爬取一个网页的所有链接"></a>2.6.2 示例：爬取一个网页的所有链接</h4><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 查询所有&lt;a&gt;节点的href属性和文本</span>links = tree.xpath(<span class="hljs-string">&#x27;//a&#x27;</span>)link_info = [(link.xpath(<span class="hljs-string">&#x27;@href&#x27;</span>)[<span class="hljs-number">0</span>], link.xpath(<span class="hljs-string">&#x27;text()&#x27;</span>)[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links]<span class="hljs-built_in">print</span>(link_info)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud+Netty集群实战千万级 IM系统</title>
    <link href="/2024/06/12/SpringCloud-Netty%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%88%98%E5%8D%83%E4%B8%87%E7%BA%A7-IM%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/12/SpringCloud-Netty%E9%9B%86%E7%BE%A4%E5%AE%9E%E6%88%98%E5%8D%83%E4%B8%87%E7%BA%A7-IM%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>构建Docker环境与Redis分布式开发</p><p>在现代软件开发中，容器技术和分布式缓存已经成为重要的组成部分。Docker作为一种轻量级的容器技术，使得开发者能够快速部署和管理应用程序。而Redis作为高性能的分布式缓存数据库，广泛应用于各种场景中。本教程将详细介绍如何构建Docker环境，并在Docker中进行Redis的分布式开发。</p><h2 id="Docker环境的构建"><a href="#Docker环境的构建" class="headerlink" title="Docker环境的构建"></a>Docker环境的构建</h2><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker是一个开源的应用容器引擎，允许开发者将应用及其依赖打包成一个轻量级的、可移植的容器。容器可以在任何安装了Docker的机器上运行，确保应用运行环境的一致性。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>以下是如何在不同操作系统上安装Docker的步骤：</p><h4 id="在Ubuntu上安装Docker"><a href="#在Ubuntu上安装Docker" class="headerlink" title="在Ubuntu上安装Docker"></a>在Ubuntu上安装Docker</h4><ol><li><p>更新现有的软件包索引：</p><div class="code-wrapper"><pre><code class="hljs sh">sudo apt-get update</code></pre></div></li><li><p>安装必要的包：</p><div class="code-wrapper"><pre><code class="hljs sh">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</code></pre></div></li><li><p>添加Docker的官方GPG密钥：</p><div class="code-wrapper"><pre><code class="hljs sh">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre></div></li><li><p>添加Docker APT源：</p><div class="code-wrapper"><pre><code class="hljs sh">sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span></code></pre></div></li><li><p>更新软件包索引并安装Docker：</p><div class="code-wrapper"><pre><code class="hljs sh">sudo apt-get updatesudo apt-get install docker-ce</code></pre></div></li><li><p>启动并配置Docker服务：</p><div class="code-wrapper"><pre><code class="hljs sh">sudo systemctl start dockersudo systemctl <span class="hljs-built_in">enable</span> docker</code></pre></div></li></ol><h4 id="在Windows上安装Docker"><a href="#在Windows上安装Docker" class="headerlink" title="在Windows上安装Docker"></a>在Windows上安装Docker</h4><ol><li>下载并安装Docker Desktop：<a href="https://www.docker.com/products/docker-desktop">Docker官网</a></li><li>安装完成后，启动Docker Desktop，并根据提示完成配置。</li></ol><h3 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h3><ul><li><p><strong>查看Docker版本：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker --version</code></pre></div></li><li><p><strong>运行Hello World容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run hello-world</code></pre></div></li><li><p><strong>列出本地所有容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker ps -a</code></pre></div></li><li><p><strong>列出本地所有镜像：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker images</code></pre></div></li><li><p><strong>启动容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker start [container_id]</code></pre></div></li><li><p><strong>停止容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker stop [container_id]</code></pre></div></li><li><p><strong>删除容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker <span class="hljs-built_in">rm</span> [container_id]</code></pre></div></li><li><p><strong>删除镜像：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker rmi [image_id]</code></pre></div></li></ul><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>Dockerfile是一个文本文件，包含了构建Docker镜像所需的指令。下面是一个简单的例子：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用官方的Python基础镜像</span><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>-slim<span class="hljs-comment"># 设置工作目录</span><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><span class="hljs-comment"># 复制当前目录内容到容器中的/app目录</span><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><span class="hljs-comment"># 安装依赖</span><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir -r requirements.txt</span><span class="hljs-comment"># 暴露应用运行的端口</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><span class="hljs-comment"># 定义运行命令</span><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span></code></pre></div><h3 id="构建与运行Docker镜像"><a href="#构建与运行Docker镜像" class="headerlink" title="构建与运行Docker镜像"></a>构建与运行Docker镜像</h3><ol><li><p><strong>构建镜像：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker build -t my-python-app .</code></pre></div></li><li><p><strong>运行镜像：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run -p 5000:5000 my-python-app</code></pre></div></li></ol><h2 id="Redis分布式开发"><a href="#Redis分布式开发" class="headerlink" title="Redis分布式开发"></a>Redis分布式开发</h2><h3 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h3><p>Redis是一个开源的内存数据结构存储，用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。</p><h3 id="Redis单机模式"><a href="#Redis单机模式" class="headerlink" title="Redis单机模式"></a>Redis单机模式</h3><p>Redis单机模式是最基本的部署方式，适用于小型项目或开发环境。可以通过以下步骤在Docker中运行Redis单机模式：</p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name my-redis -d redis</code></pre></div><h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>Redis主从复制用于提高读取性能和数据高可用性。主从复制的基本原理是将数据从主节点同步到一个或多个从节点。</p><ol><li><p><strong>启动主节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name redis-master -d redis</code></pre></div></li><li><p><strong>启动从节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name redis-slave --<span class="hljs-built_in">link</span> redis-master:master -d redis redis-server --slaveof master 6379</code></pre></div></li></ol><h3 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h3><p>Redis哨兵用于监控Redis主从集群的运行状态，并在主节点故障时自动进行主从切换。</p><ol><li><p><strong>配置哨兵文件<code>sentinel.conf</code>：</strong></p><div class="code-wrapper"><pre><code class="hljs conf">sentinel monitor mymaster 127.0.0.1 6379 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 10000sentinel parallel-syncs mymaster 1</code></pre></div></li><li><p><strong>运行哨兵容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run -d --name redis-sentinel --<span class="hljs-built_in">link</span> redis-master:master --<span class="hljs-built_in">link</span> redis-slave:slave redis redis-sentinel /path/to/sentinel.conf</code></pre></div></li></ol><h3 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h3><p>Redis集群模式通过数据分片提高Redis的可扩展性和高可用性。一个Redis集群包含多个主节点，每个主节点负责一部分数据，同时每个主节点有一个或多个从节点。</p><ol><li><p><strong>创建网络：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker network create redis-cluster</code></pre></div></li><li><p><strong>启动Redis节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run -d --name redis-node1 --net redis-cluster redis redis-server --cluster-enabled <span class="hljs-built_in">yes</span> --cluster-config-file nodes.conf --cluster-node-timeout 5000docker run -d --name redis-node2 --net redis-cluster redis redis-server --cluster-enabled <span class="hljs-built_in">yes</span> --cluster-config-file nodes.conf --cluster-node-timeout 5000docker run -d --name redis-node3 --net redis-cluster redis redis-server --cluster-enabled <span class="hljs-built_in">yes</span> --cluster-config-file nodes.conf --cluster-node-timeout 5000</code></pre></div></li><li><p><strong>初始化集群：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it redis-node1 redis-cli --cluster create redis-node1:6379 redis-node2:6379 redis-node3:6379 --cluster-replicas 1</code></pre></div></li></ol><h2 id="Redis与Docker的集成"><a href="#Redis与Docker的集成" class="headerlink" title="Redis与Docker的集成"></a>Redis与Docker的集成</h2><h3 id="使用Docker运行Redis"><a href="#使用Docker运行Redis" class="headerlink" title="使用Docker运行Redis"></a>使用Docker运行Redis</h3><p>通过Docker运行Redis可以简化Redis的部署和管理。可以使用Docker Hub上的官方Redis镜像快速启动Redis实例。</p><h3 id="在Docker中配置Redis主从复制"><a href="#在Docker中配置Redis主从复制" class="headerlink" title="在Docker中配置Redis主从复制"></a>在Docker中配置Redis主从复制</h3><ol><li><p><strong>启动主节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name redis-master -d redis</code></pre></div></li><li><p><strong>启动从节点并配置复制：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name redis-slave1 --<span class="hljs-built_in">link</span> redis-master:master -d redis redis-server --slaveof master 6379docker run --name redis-slave2 --<span class="hljs-built_in">link</span> redis-master:master -d redis redis-server --slaveof master 6379</code></pre></div></li></ol><h3 id="在Docker中配置Redis哨兵模式"><a href="#在Docker中配置Redis哨兵模式" class="headerlink" title="在Docker中配置Redis哨兵模式"></a>在Docker中配置Redis哨兵模式</h3><ol><li><p><strong>配置并启动主从节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run --name redis-master -d redisdocker run --name redis-slave1 --<span class="hljs-built_in">link</span> redis-master:master -d redis redis-server --slaveof master 6379docker run --name redis-slave2 --<span class="hljs-built_in">link</span> redis-master:master -d redis redis-server --slaveof master 6379</code></pre></div></li><li><p><strong>创建并配置哨兵配置文件<code>sentinel.conf</code>：</strong></p><div class="code-wrapper"><pre><code class="hljs conf">sentinel monitor mymaster redis-master 6379 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 10000sentinel parallel-syncs mymaster 1</code></pre></div></li><li><p><strong>运行哨兵容器：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker run -d --name redis-sentinel1 --<span class="hljs-built_in">link</span> redis-master:master redis redis-sentinel /path/to/sentinel.confdocker run -d --name redis-sentinel2 --<span class="hljs-built_in">link</span> redis-master:master redis redis-sentinel /path/to/sentinel.confdocker run -d --name redis-sentinel3 --<span class="hljs-built_in">link</span> redis-master:master redis redis-sentinel /path/to/sentinel.conf</code></pre></div></li></ol><h3 id="在Docker中配置Redis集群模式"><a href="#在Docker中配置Redis集群模式" class="headerlink" title="在Docker中配置Redis集群模式"></a>在Docker中配置Redis集群模式</h3><ol><li><p><strong>创建Docker网络：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker network create redis-cluster</code></pre></div></li><li><p><strong>启动集群节点：</strong></p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> `<span class="hljs-built_in">seq</span> 7000 7005`; <span class="hljs-keyword">do</span>    docker run -d -p <span class="hljs-variable">$port</span>:6379 --name redis-<span class="hljs-variable">$port</span> --net redis-cluster redis redis-server --cluster-enabled <span class="hljs-built_in">yes</span> --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly <span class="hljs-built_in">yes</span><span class="hljs-keyword">done</span></code></pre></div></li><li><p><strong>初始化集群：</strong></p><div class="code-wrapper"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it redis-7000 redis-cli --cluster create redis-7000:6379 redis-7001:6379 redis-7002:6379 redis-7003:6379 redis-7004:6379 redis-7005:6379 --cluster-replicas 1</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PMP项目管理认证 一站式通关课程</title>
    <link href="/2024/06/12/PMP%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A4%E8%AF%81-%E4%B8%80%E7%AB%99%E5%BC%8F%E9%80%9A%E5%85%B3%E8%AF%BE%E7%A8%8B/"/>
    <url>/2024/06/12/PMP%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E8%AE%A4%E8%AF%81-%E4%B8%80%E7%AB%99%E5%BC%8F%E9%80%9A%E5%85%B3%E8%AF%BE%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>项目管理知识体系（PMBOK）</p><p>项目管理知识体系（PMBOK）是由项目管理协会（PMI）编制的，用于指导项目管理实践的标准框架。PMBOK定义了项目管理的标准、指南和术语，涵盖了项目管理的关键领域和过程。本教程将介绍PMBOK的基本概念和核心内容，帮助读者掌握项目管理的基本知识和技能。</p><h2 id="PMBOK的结构与内容"><a href="#PMBOK的结构与内容" class="headerlink" title="PMBOK的结构与内容"></a>PMBOK的结构与内容</h2><p>PMBOK的内容结构分为五个过程组、十个知识领域和四十九个过程。这些过程相互关联，贯穿于项目的生命周期。下面将详细介绍每个部分的内容。</p><h3 id="1-五个过程组"><a href="#1-五个过程组" class="headerlink" title="1. 五个过程组"></a>1. 五个过程组</h3><h4 id="1-1-启动过程组"><a href="#1-1-启动过程组" class="headerlink" title="1.1 启动过程组"></a>1.1 启动过程组</h4><p>启动过程组涉及定义新项目或新阶段的工作，包括获得批准和确定项目范围。主要过程有：</p><ul><li>制定项目章程</li><li>制定初步范围说明书</li></ul><h4 id="1-2-规划过程组"><a href="#1-2-规划过程组" class="headerlink" title="1.2 规划过程组"></a>1.2 规划过程组</h4><p>规划过程组的目标是建立项目的详细计划，指导项目执行和控制。主要过程有：</p><ul><li>制定项目管理计划</li><li>计划范围管理</li><li>规划进度管理</li><li>规划成本管理</li><li>规划质量管理</li><li>规划资源管理</li><li>规划沟通管理</li><li>规划风险管理</li><li>规划采购管理</li><li>规划相关方管理</li></ul><h4 id="1-3-执行过程组"><a href="#1-3-执行过程组" class="headerlink" title="1.3 执行过程组"></a>1.3 执行过程组</h4><p>执行过程组的目标是完成项目管理计划中定义的工作，以实现项目目标。主要过程有：</p><ul><li>指导与管理项目工作</li><li>管理项目知识</li><li>管理质量</li><li>获取资源</li><li>管理项目团队</li><li>管理沟通</li><li>实施风险应对</li><li>进行采购</li><li>管理相关方参与</li></ul><h4 id="1-4-监控过程组"><a href="#1-4-监控过程组" class="headerlink" title="1.4 监控过程组"></a>1.4 监控过程组</h4><p>监控过程组涉及跟踪、审查和调整项目进展，以确保项目目标的实现。主要过程有：</p><ul><li>监控项目工作</li><li>实施整体变更控制</li><li>确认范围</li><li>控制范围</li><li>控制进度</li><li>控制成本</li><li>控制质量</li><li>控制资源</li><li>监控沟通</li><li>监控风险</li><li>控制采购</li><li>监控相关方参与</li></ul><h4 id="1-5-收尾过程组"><a href="#1-5-收尾过程组" class="headerlink" title="1.5 收尾过程组"></a>1.5 收尾过程组</h4><p>收尾过程组的目标是完成项目或阶段的正式验收和结束。主要过程有：</p><ul><li>结束项目或阶段</li><li>结束采购</li></ul><h3 id="2-十个知识领域"><a href="#2-十个知识领域" class="headerlink" title="2. 十个知识领域"></a>2. 十个知识领域</h3><h4 id="2-1-项目整合管理"><a href="#2-1-项目整合管理" class="headerlink" title="2.1 项目整合管理"></a>2.1 项目整合管理</h4><p>项目整合管理涉及识别、定义、组合、统一和协调各种项目管理活动的过程。包括：</p><ul><li>制定项目章程</li><li>制定项目管理计划</li><li>指导与管理项目工作</li><li>管理项目知识</li><li>监控项目工作</li><li>实施整体变更控制</li><li>结束项目或阶段</li></ul><h4 id="2-2-项目范围管理"><a href="#2-2-项目范围管理" class="headerlink" title="2.2 项目范围管理"></a>2.2 项目范围管理</h4><p>项目范围管理的目标是确保项目包含所有必需的工作，并且仅包含这些工作。包括：</p><ul><li>规划范围管理</li><li>收集需求</li><li>定义范围</li><li>创建WBS（工作分解结构）</li><li>确认范围</li><li>控制范围</li></ul><h4 id="2-3-项目进度管理"><a href="#2-3-项目进度管理" class="headerlink" title="2.3 项目进度管理"></a>2.3 项目进度管理</h4><p>项目进度管理的目标是确保项目在预定时间内完成。包括：</p><ul><li>规划进度管理</li><li>定义活动</li><li>排列活动顺序</li><li>估算活动持续时间</li><li>制定进度计划</li><li>控制进度</li></ul><h4 id="2-4-项目成本管理"><a href="#2-4-项目成本管理" class="headerlink" title="2.4 项目成本管理"></a>2.4 项目成本管理</h4><p>项目成本管理的目标是确保项目在批准的预算内完成。包括：</p><ul><li>规划成本管理</li><li>估算成本</li><li>制定预算</li><li>控制成本</li></ul><h4 id="2-5-项目质量管理"><a href="#2-5-项目质量管理" class="headerlink" title="2.5 项目质量管理"></a>2.5 项目质量管理</h4><p>项目质量管理的目标是确保项目满足所需的质量标准。包括：</p><ul><li>规划质量管理</li><li>管理质量</li><li>控制质量</li></ul><h4 id="2-6-项目资源管理"><a href="#2-6-项目资源管理" class="headerlink" title="2.6 项目资源管理"></a>2.6 项目资源管理</h4><p>项目资源管理的目标是识别、获取和管理项目所需的资源。包括：</p><ul><li>规划资源管理</li><li>估算活动资源</li><li>获取资源</li><li>管理团队</li><li>控制资源</li></ul><h4 id="2-7-项目沟通管理"><a href="#2-7-项目沟通管理" class="headerlink" title="2.7 项目沟通管理"></a>2.7 项目沟通管理</h4><p>项目沟通管理的目标是确保项目信息的有效生成、收集、分发、存储、检索、管理、控制、监控和最终处置。包括：</p><ul><li>规划沟通管理</li><li>管理沟通</li><li>监控沟通</li></ul><h4 id="2-8-项目风险管理"><a href="#2-8-项目风险管理" class="headerlink" title="2.8 项目风险管理"></a>2.8 项目风险管理</h4><p>项目风险管理的目标是识别、分析和应对项目中的风险。包括：</p><ul><li>规划风险管理</li><li>识别风险</li><li>实施定性风险分析</li><li>实施定量风险分析</li><li>规划风险应对</li><li>实施风险应对</li><li>监控风险</li></ul><h4 id="2-9-项目采购管理"><a href="#2-9-项目采购管理" class="headerlink" title="2.9 项目采购管理"></a>2.9 项目采购管理</h4><p>项目采购管理的目标是购买或获取项目所需的产品、服务或成果。包括：</p><ul><li>规划采购管理</li><li>实施采购</li><li>控制采购</li><li>结束采购</li></ul><h4 id="2-10-项目相关方管理"><a href="#2-10-项目相关方管理" class="headerlink" title="2.10 项目相关方管理"></a>2.10 项目相关方管理</h4><p>项目相关方管理的目标是识别所有相关方，了解他们的需求和期望，并通过沟通和管理相关方参与，确保项目的成功。包括：</p><ul><li>识别相关方</li><li>规划相关方参与</li><li>管理相关方参与</li><li>监控相关方参与</li></ul><h2 id="项目管理的核心概念"><a href="#项目管理的核心概念" class="headerlink" title="项目管理的核心概念"></a>项目管理的核心概念</h2><h3 id="1-项目和运营的区别"><a href="#1-项目和运营的区别" class="headerlink" title="1. 项目和运营的区别"></a>1. 项目和运营的区别</h3><p>项目是为创造独特的产品、服务或成果而进行的临时性工作，而运营是持续进行的业务活动。项目有明确的开始和结束时间，运营则是连续的、重复性的活动。</p><h3 id="2-项目生命周期"><a href="#2-项目生命周期" class="headerlink" title="2. 项目生命周期"></a>2. 项目生命周期</h3><p>项目生命周期包括项目启动、规划、执行、监控和收尾五个阶段。每个阶段都有特定的目标和任务，项目经理需要根据项目的具体情况灵活应用。</p><h3 id="3-项目干系人"><a href="#3-项目干系人" class="headerlink" title="3. 项目干系人"></a>3. 项目干系人</h3><p>项目干系人是指对项目有利益关系或会受到项目结果影响的个人或组织。项目经理需要识别所有干系人，了解他们的需求和期望，并通过有效沟通和管理来满足他们的需求。</p><h3 id="4-项目管理三重约束"><a href="#4-项目管理三重约束" class="headerlink" title="4. 项目管理三重约束"></a>4. 项目管理三重约束</h3><p>项目管理三重约束是指项目的时间、成本和范围三者之间的关系。这三者互相影响，项目经理需要在这三者之间找到平衡，以确保项目成功。</p><h2 id="四、PMBOK的应用"><a href="#四、PMBOK的应用" class="headerlink" title="四、PMBOK的应用"></a>四、PMBOK的应用</h2><h3 id="1-项目启动"><a href="#1-项目启动" class="headerlink" title="1. 项目启动"></a>1. 项目启动</h3><p>项目启动阶段的关键是制定项目章程，明确项目的目标、范围、关键干系人及其职责。项目经理需要确保项目章程得到相关方的批准，为项目的顺利开展奠定基础。</p><h3 id="2-项目规划"><a href="#2-项目规划" class="headerlink" title="2. 项目规划"></a>2. 项目规划</h3><p>项目规划阶段是制定详细的项目管理计划的过程。项目经理需要与团队和干系人合作，确定项目的范围、进度、成本、质量、资源、沟通、风险、采购和干系人管理计划。</p><h3 id="3-项目执行"><a href="#3-项目执行" class="headerlink" title="3. 项目执行"></a>3. 项目执行</h3><p>项目执行阶段是按照项目管理计划完成项目工作的过程。项目经理需要协调团队，确保资源的合理使用，解决项目中的问题，确保项目目标的实现。</p><h3 id="4-项目监控"><a href="#4-项目监控" class="headerlink" title="4. 项目监控"></a>4. 项目监控</h3><p>项目监控阶段是跟踪项目进展，确保项目按计划进行，并在必要时进行调整的过程。项目经理需要定期审查项目状态，识别偏差，实施变更控制，确保项目保持在正确的轨道上。</p><h3 id="5-项目收尾"><a href="#5-项目收尾" class="headerlink" title="5. 项目收尾"></a>5. 项目收尾</h3><p>项目收尾阶段是完成所有项目工作，获得项目最终验收，并进行项目总结和评估的过程。项目经理需要确保所有工作按预期完成，项目交付成果得到验收，并总结项目经验，为未来项目提供参考。</p><h2 id="五、PMBOK的实践与案例分析"><a href="#五、PMBOK的实践与案例分析" class="headerlink" title="五、PMBOK的实践与案例分析"></a>五、PMBOK的实践与案例分析</h2><p>通过实际案例分析，深入理解PMBOK的应用。以下是一个典型的项目案例分析，展示了PMBOK在实际项目中的应用。</p><h3 id="案例背景"><a href="#案例背景" class="headerlink" title="案例背景"></a>案例背景</h3><p>某公司计划开发一款新软件产品，以提升市场竞争力。项目包括需求分析、设计、开发、测试和发布五个阶段。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="1-启动阶段"><a href="#1-启动阶段" class="headerlink" title="1. 启动阶段"></a>1. 启动阶段</h4><p>项目经理制定了项目章程，明确了项目目标、范围和关键干系人。项目章程得到高层管理的批准，项目正式启动。</p><h4 id="2-规划阶段"><a href="#2-规划阶段" class="headerlink" title="2. 规划阶段"></a>2. 规划阶段</h4><p>项目经理与团队合作，制定了详细的项目管理计划，包括范围管理计划、进度管理计划、成本管理计划、质量管理计划、资源管理计划、沟通管理计划、风险管理计划和采购管理计划。</p><h4 id="3-执行阶段"><a href="#3-执行阶段" class="headerlink" title="3. 执行阶段"></a>3. 执行阶段</h4><p>项目团队按照计划开展工作，项目经理负责协调资源，解决问题，确保项目按计划进行。过程中，项目经理与团队保持密切沟通，及时反馈和调整。</p><h4 id="4-监控阶段"><a href="#4-监控阶段" class="headerlink" title="4. 监控阶段"></a>4. 监控阶段</h4><p>项目经理定期审查项目进展，使用各种工具和技术监控项目状态。发现问题及时采取纠正措施，确保项目按计划完成。</p><h4 id="5-收尾阶段"><a href="#5-收尾阶段" class="headerlink" title="5. 收尾阶段"></a>5. 收尾阶段</h4><p>项目经理组织项目验收，确保所有工作按预期完成，项目交付成果得到客户认可。项目总结会议上，团队总结了项目经验和教训，为未来项目提供参考。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕课-商业数据分析师</title>
    <link href="/2024/06/12/%E6%85%95%E8%AF%BE-%E5%95%86%E4%B8%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88/"/>
    <url>/2024/06/12/%E6%85%95%E8%AF%BE-%E5%95%86%E4%B8%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>Tableau与Power BI、Python开发</p><p>随着数据分析和可视化工具的广泛应用，Tableau和Power BI已成为行业标准的分析工具，而Python则作为数据科学的主流编程语言，广泛用于数据处理、分析和机器学习。本教程旨在介绍Tableau、Power BI与Python的基本使用方法及其在数据分析中的应用。</p><h2 id="第一部分：Tableau"><a href="#第一部分：Tableau" class="headerlink" title="第一部分：Tableau"></a>第一部分：Tableau</h2><h3 id="1-1-Tableau简介"><a href="#1-1-Tableau简介" class="headerlink" title="1.1 Tableau简介"></a>1.1 Tableau简介</h3><p>Tableau是一款强大的数据可视化工具，能够帮助用户快速创建各种交互式图表和仪表板。其直观的拖放界面使得用户无需编写代码即可进行复杂的数据分析和可视化。</p><h3 id="1-2-Tableau的基本操作"><a href="#1-2-Tableau的基本操作" class="headerlink" title="1.2 Tableau的基本操作"></a>1.2 Tableau的基本操作</h3><p><strong>1.2.1 数据连接</strong></p><ol><li>打开Tableau Desktop，点击“连接”面板，选择数据源（如Excel、CSV、SQL数据库等）。</li><li>选择数据文件或数据库，加载数据表。</li></ol><p><strong>1.2.2 数据准备</strong></p><ol><li>连接数据后，可以在“数据源”选项卡中预览和编辑数据。</li><li>使用数据联接、数据清理和数据转换功能来准备数据。</li></ol><p><strong>1.2.3 创建可视化</strong></p><ol><li>在“工作表”选项卡中，拖放字段到行和列架构以创建图表。</li><li>选择合适的图表类型（如折线图、柱状图、散点图等）。</li><li>使用“标记”卡片调整图表的颜色、大小、标签等。</li></ol><p>** 1.2.4 仪表板与故事**</p><ol><li>创建单个图表后，可以将多个图表组合到一个仪表板中。</li><li>使用“仪表板”选项卡，将图表拖放到仪表板画布上，调整布局。</li><li>创建故事，讲述数据背后的故事，通过添加多个仪表板或图表来讲述数据分析的过程。</li></ol><h3 id="1-3-高级功能"><a href="#1-3-高级功能" class="headerlink" title="1.3 高级功能"></a>1.3 高级功能</h3><p><strong>1.3.1 计算字段</strong></p><ol><li>在数据面板中，右键点击数据表，选择“创建计算字段”。</li><li>编写计算公式，创建新的字段用于复杂分析。</li></ol><p><strong>1.3.2 参数</strong></p><ol><li>在数据面板中，右键点击数据表，选择“创建参数”。</li><li>设置参数的名称、数据类型和允许值。</li><li>在图表中使用参数，增加交互性。</li></ol><p><strong>1.3.3 地图可视化</strong></p><ol><li>使用地理数据字段（如国家、城市等）创建地图。</li><li>在“行”或“列”架构中拖放地理数据字段，自动生成地图。</li></ol><h2 id="第二部分：Power-BI"><a href="#第二部分：Power-BI" class="headerlink" title="第二部分：Power BI"></a>第二部分：Power BI</h2><h3 id="2-1-Power-BI简介"><a href="#2-1-Power-BI简介" class="headerlink" title="2.1 Power BI简介"></a>2.1 Power BI简介</h3><p>Power BI是微软推出的一款商业智能工具，能够将数据转化为有意义的洞察。其强大的数据连接能力和丰富的可视化选项，使其成为商业数据分析的理想选择。</p><h3 id="2-2-Power-BI的基本操作"><a href="#2-2-Power-BI的基本操作" class="headerlink" title="2.2 Power BI的基本操作"></a>2.2 Power BI的基本操作</h3><p><strong>2.2.1 数据连接</strong></p><ol><li>打开Power BI Desktop，点击“获取数据”。</li><li>选择数据源（如Excel、SQL Server、Web等），加载数据。</li></ol><p><strong>2.2.2 数据准备</strong></p><ol><li>在“查询编辑器”中，使用“转换”功能进行数据清理和转换。</li><li>合并、追加查询，创建所需的数据结构。</li></ol><p><strong>2.2.3 创建可视化</strong></p><ol><li>在“报表”视图中，拖放字段到画布上，自动生成图表。</li><li>使用“可视化”面板选择和定制图表类型（如折线图、柱状图、饼图等）。</li><li>调整图表的格式和交互选项。</li></ol><p><strong>2.2.4 仪表板</strong></p><ol><li>创建单个图表后，可以将多个图表组合到一个页面中。</li><li>使用“页面”选项卡管理和布局图表。</li></ol><h3 id="2-3-高级功能"><a href="#2-3-高级功能" class="headerlink" title="2.3 高级功能"></a>2.3 高级功能</h3><p><strong>2.3.1 DAX（数据分析表达式）</strong></p><ol><li>使用DAX创建计算列和度量值。</li><li>编写DAX公式，实现复杂的计算和数据分析。</li></ol><p><strong>2.3.2 R与Python脚本</strong></p><ol><li>在Power BI中，嵌入R和Python脚本进行高级数据分析和可视化。</li><li>在“可视化”面板中选择“R可视化”或“Python可视化”，编写脚本。</li></ol><p><strong>2.3.3 Power Query</strong></p><ol><li>使用Power Query进行高级数据连接和转换。</li><li>通过M语言编写高级查询，实现复杂的数据操作。</li></ol><h2 id="第三部分：Python"><a href="#第三部分：Python" class="headerlink" title="第三部分：Python"></a>第三部分：Python</h2><h3 id="3-1-Python简介"><a href="#3-1-Python简介" class="headerlink" title="3.1 Python简介"></a>3.1 Python简介</h3><p>Python是一种高层次编程语言，以其简洁和易读性著称。Python在数据科学领域的广泛应用，使其成为数据分析、机器学习和可视化的理想工具。</p><h3 id="3-2-Python的基本操作"><a href="#3-2-Python的基本操作" class="headerlink" title="3.2 Python的基本操作"></a>3.2 Python的基本操作</h3><p><strong>3.2.1 数据处理</strong></p><ol><li>使用Pandas库进行数据处理和分析。</li><li>导入Pandas库：<code>import pandas as pd</code></li><li>加载数据：<code>df = pd.read_csv(&#39;data.csv&#39;)</code></li></ol><p><strong>3.2.2 数据清洗</strong></p><ol><li>检查缺失值：<code>df.isnull().sum()</code></li><li>填充缺失值：<code>df.fillna(value, inplace=True)</code></li><li>删除缺失值：<code>df.dropna(inplace=True)</code></li></ol><p><strong>3.2.3 数据分析</strong></p><ol><li>描述性统计：<code>df.describe()</code></li><li>分组统计：<code>df.groupby(&#39;column&#39;).mean()</code></li></ol><p><strong>3.2.4 数据可视化</strong></p><ol><li>使用Matplotlib和Seaborn库进行数据可视化。</li><li>导入库：<code>import matplotlib.pyplot as plt</code>，<code>import seaborn as sns</code></li><li>创建图表：<code>plt.plot(df[&#39;column&#39;])</code></li></ol><h3 id="3-3-高级功能"><a href="#3-3-高级功能" class="headerlink" title="3.3 高级功能"></a>3.3 高级功能</h3><p><strong>3.3.1 机器学习</strong></p><ol><li>使用Scikit-learn库进行机器学习建模。</li><li>导入库：<code>from sklearn.model_selection import train_test_split</code></li><li>数据分割：<code>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)</code></li><li>训练模型：<code>model = SomeModel().fit(X_train, y_train)</code></li></ol><p><strong>3.3.2 深度学习</strong></p><ol><li>使用TensorFlow和Keras库进行深度学习建模。</li><li>导入库：<code>import tensorflow as tf</code>，<code>from tensorflow import keras</code></li><li>创建模型：<code>model = keras.Sequential([...])</code></li><li>编译模型：<code>model.compile(optimizer=&#39;adam&#39;, loss=&#39;sparse_categorical_crossentropy&#39;)</code></li><li>训练模型：<code>model.fit(X_train, y_train, epochs=10)</code></li></ol><p><strong>3.3.3 数据可视化</strong></p><ol><li>高级可视化：使用Plotly库创建交互式图表。</li><li>导入库：<code>import plotly.express as px</code></li><li>创建交互式图表：<code>fig = px.scatter(df, x=&#39;column1&#39;, y=&#39;column2&#39;)</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「慕慕体系」LLM应用开发平台特训营</title>
    <link href="/2024/06/12/LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E7%89%B9%E8%AE%AD%E8%90%A5/"/>
    <url>/2024/06/12/LLM%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0%E7%89%B9%E8%AE%AD%E8%90%A5/</url>
    
    <content type="html"><![CDATA[<p>随着大语言模型（Large Language Models, LLM）的应用日益广泛，如何高效地部署和管理这些模型成为一个重要的课题。LLMOps（Large Language Model Operations）平台旨在通过自动化和优化模型管理过程，提高模型在生产环境中的可用性和效率。而 Prompt 引擎作为 LLMOps 平台的重要组成部分，负责生成和优化提示（prompt），以提升模型的表现和应用效果。</p><p>慕LLM应用开发平台特训营 , 核心代码，注释必读</p><blockquote><p>&#x2F;&#x2F; download：<code>3w ukoou com</code></p></blockquote><h2 id="一、LLMOps-平台概述"><a href="#一、LLMOps-平台概述" class="headerlink" title="一、LLMOps 平台概述"></a>一、LLMOps 平台概述</h2><h3 id="1-1-什么是-LLMOps"><a href="#1-1-什么是-LLMOps" class="headerlink" title="1.1 什么是 LLMOps"></a>1.1 什么是 LLMOps</h3><p>LLMOps 是一套旨在自动化和优化大语言模型管理的技术和实践，类似于 DevOps 之于软件开发和 MLOps 之于机器学习。它包括模型的部署、监控、更新、日志管理和优化等功能，目标是简化模型的生命周期管理，提升效率和可靠性。</p><h3 id="1-2-LLMOps-平台的核心功能"><a href="#1-2-LLMOps-平台的核心功能" class="headerlink" title="1.2 LLMOps 平台的核心功能"></a>1.2 LLMOps 平台的核心功能</h3><ul><li><strong>模型部署</strong>：支持不同版本的模型快速部署，兼容多种运行环境。</li><li><strong>模型监控</strong>：实时监控模型的性能、资源使用情况及用户反馈。</li><li><strong>日志管理</strong>：记录模型的输入、输出及运行状态，方便调试和审计。</li><li><strong>自动化更新</strong>：支持模型的自动更新与回滚机制。</li><li><strong>优化管理</strong>：提供模型的性能优化工具和推荐策略。</li></ul><h3 id="1-3-LLMOps-平台的架构"><a href="#1-3-LLMOps-平台的架构" class="headerlink" title="1.3 LLMOps 平台的架构"></a>1.3 LLMOps 平台的架构</h3><p>慕课LLM应用开发平台特训营中LLMOps 平台的架构通常包括以下几个模块：</p><ul><li><strong>模型管理模块</strong>：负责模型的版本控制、打包和部署。</li><li><strong>监控模块</strong>：实现模型运行状态的监控和告警。</li><li><strong>日志模块</strong>：用于记录模型的操作日志。</li><li><strong>自动化模块</strong>：支持模型的自动化更新、回滚和优化。</li><li><strong>用户界面模块</strong>：提供用户交互界面，支持可视化操作。</li></ul><h2 id="二、Prompt-引擎模块开发"><a href="#二、Prompt-引擎模块开发" class="headerlink" title="二、Prompt 引擎模块开发"></a>二、Prompt 引擎模块开发</h2><p>Prompt 引擎是 LLMOps 平台的关键模块，负责生成和优化提示词，以改善模型的输出效果。开发一个高效的 Prompt 引擎，需要考虑其生成策略、优化算法以及与 LLMOps 平台的集成。</p><h3 id="2-1-需求分析"><a href="#2-1-需求分析" class="headerlink" title="2.1 需求分析"></a>2.1 需求分析</h3><p>在开发 Prompt 引擎之前，需要明确其主要功能需求：</p><ul><li><strong>提示生成</strong>：自动生成适合不同任务的提示词。</li><li><strong>提示优化</strong>：根据反馈和数据，优化提示词以提高模型表现。</li><li><strong>上下文管理</strong>：支持多轮对话中的上下文跟踪和提示调整。</li><li><strong>用户自定义</strong>：允许用户自定义和微调提示词。</li><li><strong>性能评估</strong>：提供提示词效果的自动评估工具。</li></ul><h3 id="2-2-架构设计"><a href="#2-2-架构设计" class="headerlink" title="2.2 架构设计"></a>2.2 架构设计</h3><p>Prompt 引擎的架构设计需要兼顾生成、优化和评估的功能，同时保持模块化和可扩展性。</p><h4 id="2-2-1-模块划分"><a href="#2-2-1-模块划分" class="headerlink" title="2.2.1 模块划分"></a>2.2.1 模块划分</h4><ul><li><strong>提示生成模块</strong>：负责根据任务要求和上下文生成初步的提示词。</li><li><strong>提示优化模块</strong>：使用反馈数据和优化算法改进提示词。</li><li><strong>上下文管理模块</strong>：跟踪对话上下文并调整提示词。</li><li><strong>用户交互模块</strong>：支持用户输入自定义提示词和配置参数。</li><li><strong>评估模块</strong>：评估提示词对模型输出的影响，提供性能报告。</li></ul><h4 id="2-2-2-数据流设计"><a href="#2-2-2-数据流设计" class="headerlink" title="2.2.2 数据流设计"></a>2.2.2 数据流设计</h4><ol><li><strong>输入数据</strong>：接收用户输入、任务要求及对话上下文。</li><li><strong>提示生成</strong>：生成初步的提示词。</li><li><strong>提示优化</strong>：利用反馈数据调整提示词。</li><li><strong>上下文管理</strong>：根据上下文更新提示词。</li><li><strong>输出数据</strong>：输出优化后的提示词及评估结果。</li></ol><h3 id="2-3-技术实现"><a href="#2-3-技术实现" class="headerlink" title="2.3 技术实现"></a>2.3 技术实现</h3><p>在实现 Prompt 引擎时，主要涉及提示生成算法、优化策略、上下文管理和接口开发等。</p><h4 id="2-3-1-提示生成算法"><a href="#2-3-1-提示生成算法" class="headerlink" title="2.3.1 提示生成算法"></a>2.3.1 提示生成算法</h4><p>提示生成算法是 Prompt 引擎的核心，它需要根据不同任务生成合适的提示词。常见的提示生成算法包括模板法、规则法和学习法：</p><ul><li><strong>模板法</strong>：使用预定义的模板生成提示，适合固定格式的任务。</li><li><strong>规则法</strong>：基于规则或逻辑生成提示，适合结构化任务。</li><li><strong>学习法</strong>：利用机器学习模型生成提示，适合复杂和变化的任务。</li></ul><p>例如，模板法可以根据不同场景定义如下的提示模板：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_template_prompt</span>(<span class="hljs-params">task_type</span>):    templates = &#123;        <span class="hljs-string">&quot;translation&quot;</span>: <span class="hljs-string">&quot;Translate the following text to &#123;language&#125;: &#123;text&#125;&quot;</span>,        <span class="hljs-string">&quot;summarization&quot;</span>: <span class="hljs-string">&quot;Summarize the following content: &#123;text&#125;&quot;</span>,        <span class="hljs-string">&quot;question_answering&quot;</span>: <span class="hljs-string">&quot;Answer the question based on the text: &#123;text&#125;. Question: &#123;question&#125;&quot;</span>    &#125;    <span class="hljs-keyword">return</span> templates.get(task_type, <span class="hljs-string">&quot;Provide the required information: &#123;text&#125;&quot;</span>)</code></pre></div><h4 id="2-3-2-提示优化策略"><a href="#2-3-2-提示优化策略" class="headerlink" title="2.3.2 提示优化策略"></a>2.3.2 提示优化策略</h4><p>提示优化可以通过多种策略实现，包括基于反馈的数据驱动优化和基于算法的搜索优化：</p><ul><li><strong>反馈优化</strong>：根据用户反馈和模型输出结果，不断调整提示词。可以利用强化学习或贝叶斯优化方法。</li><li><strong>搜索优化</strong>：通过搜索算法（如遗传算法、粒子群优化等）在提示词空间中找到最优提示。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">optimize_prompt</span>(<span class="hljs-params">prompt, feedback_data</span>):    <span class="hljs-comment"># 简单示例：基于反馈数据调整提示词</span>    <span class="hljs-keyword">if</span> feedback_data[<span class="hljs-string">&quot;success&quot;</span>]:        <span class="hljs-keyword">return</span> prompt    <span class="hljs-keyword">else</span>:        <span class="hljs-comment"># 增加更多指导信息</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Please provide a detailed answer: <span class="hljs-subst">&#123;prompt&#125;</span>&quot;</span></code></pre></div><h4 id="2-3-3-上下文管理"><a href="#2-3-3-上下文管理" class="headerlink" title="2.3.3 上下文管理"></a>2.3.3 上下文管理</h4><p>上下文管理是多轮对话中的关键，需跟踪对话状态并动态调整提示词。可以使用状态机或内存网络来实现上下文跟踪。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextManager</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        self.context = []    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_context</span>(<span class="hljs-params">self, new_info</span>):        self.context.append(new_info)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_context</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>.join(self.context)</code></pre></div><h4 id="2-3-4-接口开发"><a href="#2-3-4-接口开发" class="headerlink" title="2.3.4 接口开发"></a>2.3.4 接口开发</h4><p>慕课LLM应用开发平台特训营中Prompt 引擎需要与 LLMOps 平台及外部应用交互，这要求开发标准化的接口，支持数据输入输出和配置管理。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonifyapp = Flask(__name__)<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/generate_prompt&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_prompt</span>():    data = request.json    task_type = data.get(<span class="hljs-string">&#x27;task_type&#x27;</span>)    text = data.get(<span class="hljs-string">&#x27;text&#x27;</span>)    prompt = generate_template_prompt(task_type).<span class="hljs-built_in">format</span>(text=text)    <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&quot;prompt&quot;</span>: prompt&#125;)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    app.run(debug=<span class="hljs-literal">True</span>)</code></pre></div><h3 id="2-4-测试与部署"><a href="#2-4-测试与部署" class="headerlink" title="2.4 测试与部署"></a>2.4 测试与部署</h3><h4 id="2-4-1-测试"><a href="#2-4-1-测试" class="headerlink" title="2.4.1 测试"></a>2.4.1 测试</h4><p>测试 Prompt 引擎时，需要验证提示生成、优化和上下文管理的正确性及稳定性。测试策略包括单元测试、集成测试和用户测试。</p><ul><li><strong>单元测试</strong>：验证各个功能模块的正确性。</li><li><strong>集成测试</strong>：验证模块间的交互和数据流。</li><li><strong>用户测试</strong>：基于真实用户场景进行验证和反馈收集。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPromptEngine</span>(unittest.TestCase):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_generate_prompt</span>(<span class="hljs-params">self</span>):        prompt = generate_template_prompt(<span class="hljs-string">&quot;translation&quot;</span>).<span class="hljs-built_in">format</span>(language=<span class="hljs-string">&quot;French&quot;</span>, text=<span class="hljs-string">&quot;Hello&quot;</span>)        self.assertIn(<span class="hljs-string">&quot;Translate&quot;</span>, prompt)        self.assertIn(<span class="hljs-string">&quot;French&quot;</span>, prompt)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_optimize_prompt</span>(<span class="hljs-params">self</span>):        optimized_prompt = optimize_prompt(<span class="hljs-string">&quot;Translate this text.&quot;</span>, &#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">False</span>&#125;)        self.assertIn(<span class="hljs-string">&quot;detailed&quot;</span>, optimized_prompt)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    unittest.main()</code></pre></div><h4 id="2-4-2-部署"><a href="#2-4-2-部署" class="headerlink" title="2.4.2 部署"></a>2.4.2 部署</h4><p>Prompt 引擎部署需要考虑性能和扩展性，通常可以选择云服务、容器化技术（如 Docker）或函数计算平台。</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile 示例</span><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>-slim<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><span class="hljs-keyword">COPY</span><span class="language-bash"> . /app</span><span class="hljs-keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;app.py&quot;</span>]</span></code></pre></div><h2 id="三、LLMOps-平台集成"><a href="#三、LLMOps-平台集成" class="headerlink" title="三、LLMOps 平台集成"></a>三、LLMOps 平台集成</h2><p>Prompt 引擎与 LLMOps 平台的集成是确保其有效运行的重要步骤。集成过程中，需要处理以下方面：</p><h3 id="3-1-API-集成"><a href="#3-1-API-集成" class="headerlink" title="3.1 API 集成"></a>3.1 API 集成</h3><p>通过标准化 API，与 LLMOps 平台进行数据和功能的交互。这可以通过 RESTful API 或 GraphQL 实现，确保 Prompt 引擎的输入输出与平台的要求一致。</p><h3 id="3-2-日志和监控"><a href="#3-2-日志和监控" class="headerlink" title="3.2 日志和监控"></a>3.2 日志和监控</h3><p>慕课LLM应用开发平台特训营中集成日志和监控功能，使 LLMOps 平台可以跟踪 Prompt 引擎的运行状态和性能，便于调试和优化。</p><h3 id="3-3-安全性和权限管理"><a href="#3-3-安全性和权限管理" class="headerlink" title="3.3 安全性和权限管理"></a>3.3 安全性和权限管理</h3><p>确保 Prompt 引擎与 LLMOps 平台之间的通信安全，防止数据泄露或非法访问。可以采用身份验证、数据加密等技术。</p><h2 id="四、优化和改进"><a href="#四、优化和改进" class="headerlink" title="四、优化和改进"></a>四、优化和改进</h2><p>Prompt 引擎的性能和效果会直接影响 LLMOps 平台的整体表现，因此需要持续优化和改进：</p><h3 id="4-1-数据驱动的改进"><a href="#4-1-数据驱动的改进" class="headerlink" title="4.1 数据驱动的改进"></a>4.1 数据驱动的改进</h3><p>基于收集的用户反馈和数据，持续改进提示生成和优化算法，提升提示的准确性和适用性。</p><h3 id="4-2-算法优化"><a href="#4-2-算法优化" class="headerlink" title="4.2 算法优化"></a>4.2 算法优化</h3><p>引入更先进的优化算法，如深度学习模型、强化学习等，提高提示生成和优化的智能性。</p><h3 id="4-3-用户体验提升"><a href="#4-3-用户体验提升" class="headerlink" title="4.3 用户体验提升"></a>4.3 用户体验提升</h3><p>改善用户交互界面，使提示配置和调整更加直观，增强用户的控制能力和使用体验。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI人工智能</tag>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕K前端高级工程师（大前端）- 全栈开发、AI赋能指南</title>
    <link href="/2024/06/06/%E6%85%95ke%E4%BD%93%E7%B3%BB%E5%89%8D%E7%AB%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%89-%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E3%80%81AI%E8%B5%8B%E8%83%BD%E6%8C%87%E5%8D%97/"/>
    <url>/2024/06/06/%E6%85%95ke%E4%BD%93%E7%B3%BB%E5%89%8D%E7%AB%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%89-%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E3%80%81AI%E8%B5%8B%E8%83%BD%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>全栈开发是指同时掌握前端与后端技术的开发方式，多端开发则涵盖Web、移动端和桌面端。全栈多端开发旨在提高开发效率，实现跨平台应用。前端全栈开发者不仅要熟练掌握HTML、CSS、JavaScript，还需要掌握现代前端框架、Node.js以及各种构建工具。</p><blockquote><p>“夏讠果”： pan–baidu–com&#x2F;s&#x2F;1_76lIW6L_nnDJ-hnOwZTJw 提取码: 6zf2</p></blockquote><h2 id="二、Web前端开发"><a href="#二、Web前端开发" class="headerlink" title="二、Web前端开发"></a>二、Web前端开发</h2><h3 id="2-1-HTML与CSS基础"><a href="#2-1-HTML与CSS基础" class="headerlink" title="2.1 HTML与CSS基础"></a>2.1 HTML与CSS基础</h3><p>HTML（HyperText Markup Language）是构建Web页面的骨架，CSS（Cascading Style Sheets）用于美化页面。以下是基本示例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My Web Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">        <span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">font-family</span>: Arial, sans-serif;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-tag">h1</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;</span><span class="language-css">        &#125;</span><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;</span><span class="language-css">        &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to My Web Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a sample paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="2-2-JavaScript与现代前端框架"><a href="#2-2-JavaScript与现代前端框架" class="headerlink" title="2.2 JavaScript与现代前端框架"></a>2.2 JavaScript与现代前端框架</h3><p>JavaScript用于为Web页面添加交互性。以下是一个简单的JavaScript示例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);    button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button clicked!&#x27;</span>);    &#125;);&#125;);</code></pre></div><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>React是一个用于构建用户界面的JavaScript库。以下是一个React组件示例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, React!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a simple React component.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );&#125;<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre></div><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><p>Vue.js是一个渐进式JavaScript框架，适用于构建现代Web应用。以下是一个简单的Vue.js示例：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><span class="language-javascript">  <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">&#125;);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h4 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h4><p>Angular是一个平台，用于构建动态Web应用。以下是一个简单的Angular组件示例：</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<span class="hljs-meta">@Component</span>(&#123;  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-root&#x27;</span>,  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h1&gt;Hello, Angular!&lt;/h1&gt;`</span>,  <span class="hljs-attr">styles</span>: [<span class="hljs-string">`h1 &#123; color: #007bff; &#125;`</span>]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> &#123; &#125;</code></pre></div><h3 id="2-3-前端构建工具与模块化"><a href="#2-3-前端构建工具与模块化" class="headerlink" title="2.3 前端构建工具与模块化"></a>2.3 前端构建工具与模块化</h3><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><p>Webpack是一个模块打包工具，用于打包JavaScript模块。以下是一个简单的Webpack配置示例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,        <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    &#125;,    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]            &#125;        ]    &#125;&#125;;</code></pre></div><h4 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h4><p>Babel是一个JavaScript编译器，用于将ES6+代码转换为向后兼容的JavaScript版本。以下是一个Babel配置示例：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h2 id="三、移动端开发"><a href="#三、移动端开发" class="headerlink" title="三、移动端开发"></a>三、移动端开发</h2><h3 id="3-1-响应式设计与媒体查询"><a href="#3-1-响应式设计与媒体查询" class="headerlink" title="3.1 响应式设计与媒体查询"></a>3.1 响应式设计与媒体查询</h3><p>响应式设计是为了适应不同屏幕尺寸的设计方法。媒体查询是实现响应式设计的关键技术。</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">font-family</span>: Arial, sans-serif;&#125;<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;    <span class="hljs-selector-tag">body</span> &#123;        <span class="hljs-attribute">background-color</span>: lightblue;    &#125;&#125;</code></pre></div><h3 id="3-2-React-Native和Flutter"><a href="#3-2-React-Native和Flutter" class="headerlink" title="3.2 React Native和Flutter"></a>3.2 React Native和Flutter</h3><h4 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h4><p>React Native允许使用React构建原生移动应用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">View</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>, <span class="hljs-attr">justifyContent:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, <span class="hljs-attr">alignItems:</span> &#x27;<span class="hljs-attr">center</span>&#x27; &#125;&#125;&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Hello, React Native!<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>    );&#125;</code></pre></div><h4 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h4><p>Flutter是Google的UI工具包，用于构建跨平台应用。</p><div class="code-wrapper"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> MaterialApp(      home: Scaffold(        appBar: AppBar(          title: Text(<span class="hljs-string">&#x27;Hello, Flutter!&#x27;</span>),        ),        body: Center(          child: Text(<span class="hljs-string">&#x27;Hello, Flutter!&#x27;</span>),        ),      ),    );  &#125;&#125;</code></pre></div><h2 id="四、桌面端开发"><a href="#四、桌面端开发" class="headerlink" title="四、桌面端开发"></a>四、桌面端开发</h2><h3 id="4-1-Electron框架简介"><a href="#4-1-Electron框架简介" class="headerlink" title="4.1 Electron框架简介"></a>4.1 Electron框架简介</h3><p>Electron是一个用于构建跨平台桌面应用的框架。它使用Web技术（HTML、CSS、JavaScript）来构建应用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span> () &#123;  <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;    <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,    <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,    <span class="hljs-attr">webPreferences</span>: &#123;      <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>    &#125;  &#125;);  win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>);&#125;app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(createWindow);</code></pre></div><h3 id="4-2-跨平台桌面应用开发"><a href="#4-2-跨平台桌面应用开发" class="headerlink" title="4.2 跨平台桌面应用开发"></a>4.2 跨平台桌面应用开发</h3><p>Electron允许开发者使用Web技术来构建桌面应用，支持Windows、Mac和Linux平台。以下是一个简单的Electron应用结构：</p><div class="code-wrapper"><pre><code class="hljs stylus">my-electron-app/├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>├── package<span class="hljs-selector-class">.json</span>├── index<span class="hljs-selector-class">.html</span>└── renderer.js</code></pre></div><h2 id="五、全栈开发"><a href="#五、全栈开发" class="headerlink" title="五、全栈开发"></a>五、全栈开发</h2><h3 id="5-1-Node-js与Express"><a href="#5-1-Node-js与Express" class="headerlink" title="5.1 Node.js与Express"></a>5.1 Node.js与Express</h3><p>Node.js是一个基于V8引擎的JavaScript运行时，Express是一个用于构建Web应用的Node.js框架。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello, World!&#x27;</span>);&#125;);app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running at http://localhost:<span class="hljs-subst">$&#123;port&#125;</span>`</span>);&#125;);</code></pre></div><h3 id="5-2-数据库集成与API开发"><a href="#5-2-数据库集成与API开发" class="headerlink" title="5.2 数据库集成与API开发"></a>5.2 数据库集成与API开发</h3><p>使用MongoDB与Mongoose进行数据库集成，开发RESTful API。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// models/User.js</span><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>(&#123;    <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,    <span class="hljs-attr">email</span>: <span class="hljs-title class_">String</span>&#125;);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);</code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// server.js</span><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./models/User&#x27;</span>);mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/myapp&#x27;</span>, &#123; <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span> &#125;);<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(req.<span class="hljs-property">body</span>);    <span class="hljs-keyword">await</span> user.<span class="hljs-title function_">save</span>();    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">201</span>).<span class="hljs-title function_">send</span>(user);&#125;);app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;    <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>();    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">send</span>(users);&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);&#125;);</code></pre></div><h2 id="六、前端AI赋能"><a href="#六、前端AI赋能" class="headerlink" title="六、前端AI赋能"></a>六、前端AI赋能</h2><h3 id="6-1-自然语言处理"><a href="#6-1-自然语言处理" class="headerlink" title="6.1 自然语言处理"></a>6.1 自然语言处理</h3><p>利用AI进行自然语言处理，提升用户体验和交互。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openaiopenai.api_key = <span class="hljs-string">&#x27;your-api-key&#x27;</span>response = openai.Completion.create(  engine=<span class="hljs-string">&quot;davinci&quot;</span>,  prompt=<span class="hljs-string">&quot;Translate the following English text to French: &#x27;Hello, how are you?&#x27;&quot;</span>,  max_tokens=<span class="hljs-number">60</span>)<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].text.strip())</code></pre></div><h3 id="6-2-图像识别与处理"><a href="#6-2-图像识别与处理" class="headerlink" title="6.2 图像识别与处理"></a>6.2 图像识别与处理</h3><p>使用AI进行图像识别与处理，实现更智能的功能。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Imagemodel = tf.keras.applications.MobileNetV2(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">True</span>)image = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path_to_image.jpg&#x27;</span>)image = image.resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))image_array = np.array(image)image_array = np.expand_dims(image_array, axis=<span class="hljs-number">0</span>)image_array = tf.keras.applications.mobilenet_v2.preprocess_input(image_array)predictions = model.predict(image_array)<span class="hljs-built_in">print</span>(tf.keras.applications.mobilenet_v2.decode_predictions(predictions, top=<span class="hljs-number">3</span>)[<span class="hljs-number">0</span>])</code></pre></div><h3 id="6-3-AI生成代码与自动化测试"><a href="#6-3-AI生成代码与自动化测试" class="headerlink" title="6.3 AI生成代码与自动化测试"></a>6.3 AI生成代码与自动化测试</h3><p>利用AI生成代码和自动化测试，提高开发效率和质量。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openaiprompt = <span class="hljs-string">&quot;Generate a Python function to sort a list of numbers.&quot;</span>response = openai.Completion.create(engine=<span class="hljs-string">&quot;davinci-codex&quot;</span>, prompt=prompt, max_tokens=<span class="hljs-number">100</span>)<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].text.strip())</code></pre></div><h2 id="七、案例分析与项目实战"><a href="#七、案例分析与项目实战" class="headerlink" title="七、案例分析与项目实战"></a>七、案例分析与项目实战</h2><h3 id="7-1-项目概述"><a href="#7-1-项目概述" class="headerlink" title="7.1 项目概述"></a>7.1 项目概述</h3><p>假设我们要开发一个跨平台的任务管理应用，支持Web、移动端和桌面端。该应用应包括用户注册与登录、任务创建与管理、任务提醒等功能。</p><h3 id="7-2-前端实现"><a href="#7-2-前端实现" class="headerlink" title="7.2 前端实现"></a>7.2 前端实现</h3><h4 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h4><p>使用React开发Web前端。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> [tasks, setTasks] = <span class="hljs-title function_">useState</span>([]);    <span class="hljs-keyword">const</span> [newTask, setNewTask] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>(response.<span class="hljs-property">data</span>))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;, []);    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params"></span>) =&gt; &#123;        axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>, &#123; <span class="hljs-attr">description</span>: newTask &#125;)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>([...tasks, response.<span class="hljs-property">data</span>]))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Task Manager<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;newTask&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setNewTask(e.target.value)&#125; /&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addTask&#125;</span>&gt;</span>Add Task<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">                &#123;tasks.map(task =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;task._id&#125;</span>&gt;</span>&#123;task.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;</code></pre></div><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><p>使用React Native开发移动端。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">TextInput</span>, <span class="hljs-title class_">Button</span>, <span class="hljs-title class_">FlatList</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> [tasks, setTasks] = <span class="hljs-title function_">useState</span>([]);    <span class="hljs-keyword">const</span> [newTask, setNewTask] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>(response.<span class="hljs-property">data</span>))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;, []);    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params"></span>) =&gt; &#123;        axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>, &#123; <span class="hljs-attr">description</span>: newTask &#125;)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>([...tasks, response.<span class="hljs-property">data</span>]))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">padding:</span> <span class="hljs-attr">20</span> &#125;&#125;&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Task Manager<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;newTask&#125;</span> <span class="hljs-attr">onChangeText</span>=<span class="hljs-string">&#123;setNewTask&#125;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;New Task&quot;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Add Task&quot;</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">&#123;addTask&#125;</span> /&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">FlatList</span></span></span><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">data</span>=<span class="hljs-string">&#123;tasks&#125;</span></span></span><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">keyExtractor</span>=<span class="hljs-string">&#123;item</span> =&gt;</span> item._id&#125;</span><span class="language-xml">                renderItem=&#123;(&#123; item &#125;) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>&#123;item.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>&#125;</span><span class="language-xml">            /&gt;</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>    );&#125;</code></pre></div><h4 id="桌面端"><a href="#桌面端" class="headerlink" title="桌面端"></a>桌面端</h4><p>使用Electron开发桌面端。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;        <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,        <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,        <span class="hljs-attr">webPreferences</span>: &#123;            <span class="hljs-attr">preload</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;preload.js&#x27;</span>)        &#125;    &#125;);    win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>);&#125;app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(createWindow);</code></pre></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Task Manager<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;renderer.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// renderer.js</span><span class="hljs-keyword">const</span> &#123; ipcRenderer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react&#x27;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactDOM</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-dom&#x27;</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> [tasks, setTasks] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>([]);    <span class="hljs-keyword">const</span> [newTask, setNewTask] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>);    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>(response.<span class="hljs-property">data</span>))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;, []);    <span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params"></span>) =&gt; &#123;        axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>, &#123; <span class="hljs-attr">description</span>: newTask &#125;)            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> <span class="hljs-title function_">setTasks</span>([...tasks, response.<span class="hljs-property">data</span>]))            .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));    &#125;;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Task Manager<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;newTask&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setNewTask(e.target.value)&#125; /&gt;</span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;addTask&#125;</span>&gt;</span>Add Task<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">                &#123;tasks.map(task =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;task._id&#125;</span>&gt;</span>&#123;task.description&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );&#125;<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>));</code></pre></div><h3 id="7-3-后端实现"><a href="#7-3-后端实现" class="headerlink" title="7.3 后端实现"></a>7.3 后端实现</h3><p>使用Node.js和Express开发后端API，提供任务管理功能。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/taskmanager&#x27;</span>, &#123; <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span> &#125;);<span class="hljs-keyword">const</span> <span class="hljs-title class_">Task</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Task&#x27;</span>, &#123; <span class="hljs-attr">description</span>: <span class="hljs-title class_">String</span> &#125;);<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;    <span class="hljs-keyword">const</span> tasks = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Task</span>.<span class="hljs-title function_">find</span>();    res.<span class="hljs-title function_">json</span>(tasks);&#125;);app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/tasks&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(req.<span class="hljs-property">body</span>);    <span class="hljs-keyword">await</span> task.<span class="hljs-title function_">save</span>();    res.<span class="hljs-title function_">status</span>(<span class="hljs-number">201</span>).<span class="hljs-title function_">json</span>(task);&#125;);app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);&#125;);</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕ke前端高级工程师（大前端）</title>
    <link href="/2024/06/06/%E6%85%95ke%E5%89%8D%E7%AB%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%89/"/>
    <url>/2024/06/06/%E6%85%95ke%E5%89%8D%E7%AB%AF%E9%AB%98%E7%BA%A7%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E5%A4%A7%E5%89%8D%E7%AB%AF%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>前端开发涉及多个核心技术，包括HTML、CSS、JavaScript以及各种前端框架和工具。掌握这些核心技术，开发者可以创建功能强大且用户友好的Web应用。在现代Web开发中，前端技术栈不断演进，以提供更强大的功能和更好的用户体验。</p><blockquote><p>“夏讠果”： pan–baidu–com&#x2F;s&#x2F;1_76lIW6L_nnDJ-hnOwZTJw 提取码: 6zf2</p></blockquote><h2 id="一、HTML-超文本标记语言"><a href="#一、HTML-超文本标记语言" class="headerlink" title="一、HTML (超文本标记语言)"></a>一、HTML (超文本标记语言)</h2><p>HTML 是构建Web页面的基础语言，用于定义页面的结构和内容。</p><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><strong>标签</strong>：HTML 由一系列标签组成，每个标签描述一种内容或页面元素。</li><li><strong>属性</strong>：标签可以包含属性，用于提供额外的信息或配置。</li></ul><h3 id="1-2-常用标签"><a href="#1-2-常用标签" class="headerlink" title="1.2 常用标签"></a>1.2 常用标签</h3><ul><li>**<code>&lt;div&gt;</code>**：定义一个块级元素。</li><li>**<code>&lt;span&gt;</code>**：定义一个内联元素。</li><li>**<code>&lt;a&gt;</code>**：定义一个超链接。</li><li>**<code>&lt;img&gt;</code>**：定义一个图像。</li><li>**<code>&lt;form&gt;</code>**：定义一个表单。</li></ul><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTML Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome to My Website<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://example.com&quot;</span>&gt;</span>Visit Example<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="二、CSS-层叠样式表"><a href="#二、CSS-层叠样式表" class="headerlink" title="二、CSS (层叠样式表)"></a>二、CSS (层叠样式表)</h2><p>CSS 用于控制HTML元素的外观和布局，使页面更加美观和用户友好。</p><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li><strong>选择器</strong>：用于选择HTML元素。</li><li><strong>属性和值</strong>：定义元素的样式属性及其值。</li></ul><h3 id="2-2-常用属性"><a href="#2-2-常用属性" class="headerlink" title="2.2 常用属性"></a>2.2 常用属性</h3><ul><li><strong>颜色和背景</strong>：<code>color</code>, <code>background-color</code></li><li><strong>布局</strong>：<code>margin</code>, <code>padding</code>, <code>display</code>, <code>position</code></li><li><strong>字体</strong>：<code>font-family</code>, <code>font-size</code>, <code>font-weight</code></li></ul><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">font-family</span>: Arial, sans-serif;    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;&#125;<span class="hljs-selector-tag">h1</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#007bff</span>;&#125;<span class="hljs-selector-tag">a</span> &#123;    <span class="hljs-attribute">color</span>: <span class="hljs-number">#007bff</span>;    <span class="hljs-attribute">text-decoration</span>: none;&#125;</code></pre></div><h2 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a>三、JavaScript</h2><p>JavaScript 是一种高级编程语言，用于实现网页的动态功能。</p><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><ul><li><strong>变量和数据类型</strong>：<code>let</code>, <code>const</code>, <code>number</code>, <code>string</code>, <code>boolean</code></li><li><strong>函数</strong>：定义和调用函数。</li><li><strong>事件</strong>：响应用户操作，如点击、提交等。</li></ul><h3 id="3-2-DOM-操作"><a href="#3-2-DOM-操作" class="headerlink" title="3.2 DOM 操作"></a>3.2 DOM 操作</h3><ul><li><strong>选择元素</strong>：<code>document.getElementById()</code>, <code>document.querySelector()</code></li><li><strong>修改内容</strong>：<code>element.innerHTML</code>, <code>element.textContent</code></li><li><strong>事件监听</strong>：<code>element.addEventListener()</code></li></ul><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);    button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Button was clicked!&#x27;</span>);    &#125;);&#125;);</code></pre></div><h2 id="四、前端框架和库"><a href="#四、前端框架和库" class="headerlink" title="四、前端框架和库"></a>四、前端框架和库</h2><h3 id="4-1-React"><a href="#4-1-React" class="headerlink" title="4.1 React"></a>4.1 React</h3><p>React 是一个用于构建用户界面的JavaScript库，特别适用于构建单页应用。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">return</span> (        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, React!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a simple React component.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );&#125;<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre></div><h3 id="4-2-Vue-js"><a href="#4-2-Vue-js" class="headerlink" title="4.2 Vue.js"></a>4.2 Vue.js</h3><p>Vue.js 是一个渐进式JavaScript框架，用于构建用户界面。</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;</span>&gt;&lt;/script&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">data</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;)</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h3 id="4-3-Angular"><a href="#4-3-Angular" class="headerlink" title="4.3 Angular"></a>4.3 Angular</h3><p>Angular 是一个平台，用于构建动态Web应用。</p><div class="code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;<span class="hljs-meta">@Component</span>(&#123;  <span class="hljs-attr">selector</span>: <span class="hljs-string">&#x27;app-root&#x27;</span>,  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;h1&gt;Hello, Angular!&lt;/h1&gt;`</span>,  <span class="hljs-attr">styles</span>: [<span class="hljs-string">`h1 &#123; color: #007bff; &#125;`</span>]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> &#123; &#125;</code></pre></div><h2 id="五、前端构建工具"><a href="#五、前端构建工具" class="headerlink" title="五、前端构建工具"></a>五、前端构建工具</h2><h3 id="5-1-Webpack"><a href="#5-1-Webpack" class="headerlink" title="5.1 Webpack"></a>5.1 Webpack</h3><p>Webpack 是一个模块打包工具，用于打包JavaScript模块。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,    <span class="hljs-attr">output</span>: &#123;        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,        <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>    &#125;,    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-attr">rules</span>: [            &#123;                <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,                <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]            &#125;        ]    &#125;&#125;;</code></pre></div><h3 id="5-2-Babel"><a href="#5-2-Babel" class="headerlink" title="5.2 Babel"></a>5.2 Babel</h3><p>Babel 是一个JavaScript编译器，用于将ES6+代码转换为向后兼容的JavaScript版本。</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h3 id="5-3-NPM"><a href="#5-3-NPM" class="headerlink" title="5.3 NPM"></a>5.3 NPM</h3><p>NPM 是JavaScript包管理器，用于管理项目的依赖包。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装依赖包</span>npm install axios</code></pre></div><h2 id="六、版本控制系统"><a href="#六、版本控制系统" class="headerlink" title="六、版本控制系统"></a>六、版本控制系统</h2><h3 id="6-1-Git"><a href="#6-1-Git" class="headerlink" title="6.1 Git"></a>6.1 Git</h3><p>Git 是一个分布式版本控制系统，用于管理项目的源代码。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化Git仓库</span>git init<span class="hljs-comment"># 添加文件到暂存区</span>git add .<span class="hljs-comment"># 提交文件到本地仓库</span>git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><span class="hljs-comment"># 推送到远程仓库</span>git remote add origin https://github.com/user/repo.gitgit push -u origin master</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI全流程落地实战：从设计-开发-测试到运营一站式搞定</title>
    <link href="/2024/06/04/AI%E5%85%A8%E6%B5%81%E7%A8%8B%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E8%AE%BE%E8%AE%A1-%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95%E5%88%B0%E8%BF%90%E8%90%A5%E4%B8%80%E7%AB%99%E5%BC%8F%E6%90%9E%E5%AE%9A/"/>
    <url>/2024/06/04/AI%E5%85%A8%E6%B5%81%E7%A8%8B%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%E8%AE%BE%E8%AE%A1-%E5%BC%80%E5%8F%91-%E6%B5%8B%E8%AF%95%E5%88%B0%E8%BF%90%E8%90%A5%E4%B8%80%E7%AB%99%E5%BC%8F%E6%90%9E%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>在当前的AI时代，构建知识库与编写代码已变得更加高效和智能化。利用现代AI技术，个人开发者和小型团队也能快速建立起复杂的系统和应用。本教程将介绍如何构建AI知识库，以及如何通过AI辅助编写代码，从而提高开发效率和产品质量。</p><h2 id="一、AI构建知识库"><a href="#一、AI构建知识库" class="headerlink" title="一、AI构建知识库"></a>一、AI构建知识库</h2><p>知识库是一种存储和管理知识的系统，通常用于支持信息检索、数据分析和决策支持。在AI的帮助下，知识库可以更智能地管理和利用数据。以下是构建AI知识库的步骤：</p><h3 id="1-1-需求分析与设计"><a href="#1-1-需求分析与设计" class="headerlink" title="1.1 需求分析与设计"></a>1.1 需求分析与设计</h3><p>首先，需要明确知识库的目标和功能需求。这包括确定知识库的应用领域、数据来源、用户群体以及预期功能。例如，构建一个医疗知识库需要涵盖医学文献、药品信息、患者记录等数据，并提供快速检索和诊断支持功能。</p><h3 id="1-2-数据收集与整理"><a href="#1-2-数据收集与整理" class="headerlink" title="1.2 数据收集与整理"></a>1.2 数据收集与整理</h3><p>数据是知识库的核心。需要从各种来源收集相关数据，并进行清洗、分类和结构化处理。常见的数据来源包括数据库、文档、API接口和网络爬虫等。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用Python进行简单的数据收集示例</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>(<span class="hljs-params">api_url</span>):    response = requests.get(api_url)    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:        <span class="hljs-keyword">return</span> response.json()    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>data = fetch_data(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)</code></pre></div><h3 id="1-3-数据存储与管理"><a href="#1-3-数据存储与管理" class="headerlink" title="1.3 数据存储与管理"></a>1.3 数据存储与管理</h3><p>选择合适的存储技术来管理数据。常见的选择包括关系型数据库（如MySQL、PostgreSQL）、NoSQL数据库（如MongoDB、Cassandra）以及图数据库（如Neo4j）。根据数据的特性和查询需求选择合适的存储方案。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用MongoDB进行数据存储示例</span><span class="hljs-keyword">from</span> pymongo <span class="hljs-keyword">import</span> MongoClientclient = MongoClient(<span class="hljs-string">&#x27;mongodb://localhost:27017/&#x27;</span>)db = client[<span class="hljs-string">&#x27;knowledge_base&#x27;</span>]collection = db[<span class="hljs-string">&#x27;medical_data&#x27;</span>]<span class="hljs-comment"># 插入数据</span>collection.insert_many(data)</code></pre></div><h3 id="1-4-数据处理与分析"><a href="#1-4-数据处理与分析" class="headerlink" title="1.4 数据处理与分析"></a>1.4 数据处理与分析</h3><p>利用AI和机器学习技术对数据进行处理和分析。常见的处理任务包括自然语言处理（NLP）、数据挖掘、图像识别等。可以使用诸如TensorFlow、PyTorch等框架来构建和训练模型。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用TensorFlow进行简单的文本分类示例</span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.text <span class="hljs-keyword">import</span> Tokenizer<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="hljs-keyword">import</span> pad_sequences<span class="hljs-comment"># 假设已有训练数据</span>texts = [<span class="hljs-string">&quot;Example text 1&quot;</span>, <span class="hljs-string">&quot;Example text 2&quot;</span>]labels = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]tokenizer = Tokenizer(num_words=<span class="hljs-number">10000</span>)tokenizer.fit_on_texts(texts)sequences = tokenizer.texts_to_sequences(texts)padded_sequences = pad_sequences(sequences, maxlen=<span class="hljs-number">100</span>)model = tf.keras.Sequential([    tf.keras.layers.Embedding(<span class="hljs-number">10000</span>, <span class="hljs-number">128</span>, input_length=<span class="hljs-number">100</span>),    tf.keras.layers.GlobalAveragePooling1D(),    tf.keras.layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>)])model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])model.fit(padded_sequences, labels, epochs=<span class="hljs-number">10</span>)</code></pre></div><h3 id="1-5-知识检索与展示"><a href="#1-5-知识检索与展示" class="headerlink" title="1.5 知识检索与展示"></a>1.5 知识检索与展示</h3><p>构建高效的检索系统，支持用户快速查询和获取所需信息。可以使用Elasticsearch等搜索引擎技术来实现全文检索和高级查询功能。同时，设计友好的用户界面来展示知识库内容，提高用户体验。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用Elasticsearch进行数据检索示例</span><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Client</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@elastic/elasticsearch&#x27;</span>)<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(&#123; <span class="hljs-attr">node</span>: <span class="hljs-string">&#x27;http://localhost:9200&#x27;</span> &#125;)<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">query</span>) &#123;  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">search</span>(&#123;    <span class="hljs-attr">index</span>: <span class="hljs-string">&#x27;knowledge_base&#x27;</span>,    <span class="hljs-attr">body</span>: &#123;      <span class="hljs-attr">query</span>: &#123;        <span class="hljs-attr">match</span>: &#123; <span class="hljs-attr">content</span>: query &#125;      &#125;    &#125;  &#125;)  <span class="hljs-keyword">return</span> result.<span class="hljs-property">hits</span>.<span class="hljs-property">hits</span>&#125;<span class="hljs-title function_">search</span>(<span class="hljs-string">&#x27;medical data&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>)</code></pre></div><h2 id="二、AI编码"><a href="#二、AI编码" class="headerlink" title="二、AI编码"></a>二、AI编码</h2><p>AI不仅可以用于构建知识库，还能大幅提高编写代码的效率和质量。以下是AI辅助编码的步骤：</p><h3 id="2-1-需求分析与设计"><a href="#2-1-需求分析与设计" class="headerlink" title="2.1 需求分析与设计"></a>2.1 需求分析与设计</h3><p>明确项目的目标和功能需求，确定要开发的模块和接口。这一步骤与传统软件开发类似，但可以利用AI进行自动化需求分析和生成初步设计文档。</p><h3 id="2-2-自动代码生成"><a href="#2-2-自动代码生成" class="headerlink" title="2.2 自动代码生成"></a>2.2 自动代码生成</h3><p>利用AI工具自动生成代码。例如，使用OpenAI的Codex或GitHub Copilot等工具，可以根据自然语言描述自动生成相应的代码段。这极大地提高了开发效率，特别是对于常见的编程任务和模板化代码。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用OpenAI Codex自动生成Python代码示例</span><span class="hljs-keyword">import</span> openaiopenai.api_key = <span class="hljs-string">&#x27;your-api-key&#x27;</span>prompt = <span class="hljs-string">&quot;Write a Python function to sort a list of numbers.&quot;</span>response = openai.Completion.create(engine=<span class="hljs-string">&quot;davinci-codex&quot;</span>, prompt=prompt, max_tokens=<span class="hljs-number">100</span>)<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].text.strip())</code></pre></div><h3 id="2-3-代码优化与重构"><a href="#2-3-代码优化与重构" class="headerlink" title="2.3 代码优化与重构"></a>2.3 代码优化与重构</h3><p>AI可以帮助分析和优化现有代码，提供重构建议，提高代码质量和性能。通过静态代码分析工具（如SonarQube）和AI驱动的代码审查工具，可以自动检测代码中的潜在问题并提供修复建议。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用SonarQube进行代码质量分析示例</span><span class="hljs-comment"># 假设已经安装并配置好SonarQube</span><span class="hljs-keyword">import</span> subprocesssubprocess.run([<span class="hljs-string">&quot;sonar-scanner&quot;</span>])</code></pre></div><h3 id="2-4-测试生成与自动化"><a href="#2-4-测试生成与自动化" class="headerlink" title="2.4 测试生成与自动化"></a>2.4 测试生成与自动化</h3><p>AI可以自动生成测试用例，提高测试覆盖率和效率。例如，使用AI工具自动生成单元测试和集成测试代码，确保代码的正确性和稳定性。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 使用AI生成单元测试示例</span><span class="hljs-keyword">import</span> openaiprompt = <span class="hljs-string">&quot;Generate a unit test for the following Python function:\n\n&quot;</span> \         <span class="hljs-string">&quot;def add(a, b):\n    return a + b\n&quot;</span>response = openai.Completion.create(engine=<span class="hljs-string">&quot;davinci-codex&quot;</span>, prompt=prompt, max_tokens=<span class="hljs-number">100</span>)<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].text.strip())</code></pre></div><h3 id="2-5-部署与运维"><a href="#2-5-部署与运维" class="headerlink" title="2.5 部署与运维"></a>2.5 部署与运维</h3><p>AI可以优化应用的部署和运维流程。通过使用容器化技术（如Docker、Kubernetes）和CI&#x2F;CD工具（如Jenkins、GitHub Actions），结合AI进行自动化部署和监控，提高系统的可靠性和可维护性。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># 使用GitHub Actions进行自动化部署示例</span><span class="hljs-attr">name:</span> <span class="hljs-string">CI/CD</span> <span class="hljs-string">Pipeline</span><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>]<span class="hljs-attr">jobs:</span>  <span class="hljs-attr">build:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>    <span class="hljs-attr">steps:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Python</span>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-python@v2</span>      <span class="hljs-attr">with:</span>        <span class="hljs-attr">python-version:</span> <span class="hljs-string">&#x27;3.x&#x27;</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        python -m pip install --upgrade pip</span><span class="hljs-string">        pip install -r requirements.txt</span><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">tests</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        pytest</span><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">production</span>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><span class="hljs-string">        docker build -t myapp .</span><span class="hljs-string">        docker run -d -p 80:80 myapp</span></code></pre></div><p>AI全流程落地实战：从设计-开发-测试到运营一站式搞定,AI在数据处理、代码生成、测试和部署等方面提供了强大的支持，极大地提高了开发效率和产品质量。掌握这些技术，能够帮助开发者从0到1独立完成复杂的商业项目，成为一人抵一个团队的超级个体。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Security+OAuth2 精讲，打造企业级认证与授权2024</title>
    <link href="/2024/05/31/Spring-Security-OAuth2-%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%832024/"/>
    <url>/2024/05/31/Spring-Security-OAuth2-%E7%B2%BE%E8%AE%B2%EF%BC%8C%E6%89%93%E9%80%A0%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%832024/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多端全栈项目实战：大型商业级代驾业务全流程落地2024</title>
    <link href="/2024/05/31/%E5%A4%9A%E7%AB%AF%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E5%A4%A7%E5%9E%8B%E5%95%86%E4%B8%9A%E7%BA%A7%E4%BB%A3%E9%A9%BE%E4%B8%9A%E5%8A%A1%E5%85%A8%E6%B5%81%E7%A8%8B%E8%90%BD%E5%9C%B02024/"/>
    <url>/2024/05/31/%E5%A4%9A%E7%AB%AF%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E5%A4%A7%E5%9E%8B%E5%95%86%E4%B8%9A%E7%BA%A7%E4%BB%A3%E9%A9%BE%E4%B8%9A%E5%8A%A1%E5%85%A8%E6%B5%81%E7%A8%8B%E8%90%BD%E5%9C%B02024/</url>
    
    <content type="html"><![CDATA[<h1 id="多端全栈开发介绍"><a href="#多端全栈开发介绍" class="headerlink" title="多端全栈开发介绍"></a>多端全栈开发介绍</h1><p>多端全栈开发是一种涵盖前端、后端以及不同平台（如Web、移动端、桌面端）开发的综合性开发方式。它旨在通过统一的开发框架和工具链，提高开发效率和代码复用率，同时提供一致的用户体验。以下是多端全栈开发的主要组成部分和优点。</p><h2 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h2><p>前端开发涉及用户界面的设计和实现。多端开发常用的框架和库包括：</p><ul><li><strong>React</strong>：一个用于构建用户界面的JavaScript库，广泛应用于Web和移动端开发。</li><li><strong>Vue.js</strong>：一个渐进式JavaScript框架，适用于构建现代Web应用。</li><li><strong>Angular</strong>：一个平台，用于构建高效的Web应用。</li></ul><p>这些框架通常结合HTML、CSS和JavaScript，实现动态和响应式的用户界面。</p><h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><p>后端开发负责处理业务逻辑、数据库交互和服务器端操作。常用的后端技术包括：</p><ul><li><strong>Node.js</strong>：一个基于JavaScript的服务器端平台，支持构建高性能、可扩展的网络应用。</li><li><strong>Django</strong>：一个高层次的Python Web框架，鼓励快速开发和干净、实用的设计。</li><li><strong>Spring Boot</strong>：一个基于Java的框架，用于创建独立、生产级的Spring应用程序。</li></ul><p>后端开发还涉及数据库管理，常用的数据库有MySQL、PostgreSQL、MongoDB等。</p><h2 id="多平台开发"><a href="#多平台开发" class="headerlink" title="多平台开发"></a>多平台开发</h2><p>多端全栈开发还包括为不同平台（Web、移动端、桌面端）创建应用。主要技术包括：</p><ul><li><strong>React Native</strong>：用于构建原生移动应用的框架，使用与React相同的代码库。</li><li><strong>Flutter</strong>：一个由Google开发的开源UI软件开发工具包，用于创建跨平台应用。</li><li><strong>Electron</strong>：一个用于构建跨平台桌面应用的框架，使用Web技术（HTML、CSS、JavaScript）。</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>代码复用</strong>：通过统一的技术栈，可以在不同平台之间共享代码，减少重复开发。</li><li><strong>一致的用户体验</strong>：确保应用在不同设备和平台上提供一致的用户体验。</li><li><strong>开发效率</strong>：利用现代开发框架和工具链，提升开发效率，缩短开发周期。</li><li><strong>维护方便</strong>：统一的技术栈和框架使得项目的维护和扩展更加方便。</li></ul><h3 id="Spring-Boot-和-Vue-商业级代驾业务项目开发"><a href="#Spring-Boot-和-Vue-商业级代驾业务项目开发" class="headerlink" title="Spring Boot 和 Vue 商业级代驾业务项目开发"></a>Spring Boot 和 Vue 商业级代驾业务项目开发</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>在开始开发之前，建议你具备以下知识：</p><ul><li><strong>Java 和 Spring Boot 基础</strong>：包括 Spring MVC、Spring Data JPA、Spring Security 等。</li><li><strong>前端基础</strong>：包括 HTML、CSS、JavaScript 以及 Vue.js 框架。</li><li><strong>数据库</strong>：了解基本的 SQL 语法和数据库设计。</li><li><strong>构建工具</strong>：Maven 或 Gradle 的基本使用。</li></ul><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><h5 id="后端（Spring-Boot）"><a href="#后端（Spring-Boot）" class="headerlink" title="后端（Spring Boot）"></a>后端（Spring Boot）</h5><ol><li><p><strong>项目初始化</strong><br>使用 Spring Initializr 创建一个新的 Spring Boot 项目，选择以下依赖：</p><ul><li>Spring Web</li><li>Spring Data JPA</li><li>Spring Security</li><li>MySQL Driver</li><li>Lombok</li></ul></li><li><p><strong>配置数据库</strong><br>在 <code>application.properties</code> 文件中配置 MySQL 数据库连接：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/driver_service</span><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">yourpassword</span><span class="hljs-attr">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span></code></pre></div></li><li><p><strong>创建实体类</strong><br>创建用户、订单和司机等实体类，并使用 JPA 注解进行映射。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// getter 和 setter 方法</span>&#125;</code></pre></div></li><li><p><strong>创建仓库接口</strong><br>使用 Spring Data JPA 创建对应的仓库接口。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;User, Long&gt; &#123;    User <span class="hljs-title function_">findByUsername</span><span class="hljs-params">(String username)</span>;&#125;</code></pre></div></li><li><p><strong>实现服务层</strong><br>编写服务层逻辑，包括用户注册、登录、订单管理等功能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserRepository userRepository;        <span class="hljs-keyword">public</span> User <span class="hljs-title function_">register</span><span class="hljs-params">(User user)</span> &#123;        <span class="hljs-keyword">return</span> userRepository.save(user);    &#125;&#125;</code></pre></div></li><li><p><strong>实现控制器层</strong><br>编写 RESTful 控制器，处理前端请求。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/api/users&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@PostMapping(&quot;/register&quot;)</span>    <span class="hljs-keyword">public</span> ResponseEntity&lt;User&gt; <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(userService.register(user), HttpStatus.CREATED);    &#125;&#125;</code></pre></div></li></ol><h5 id="前端（Vue-js）"><a href="#前端（Vue-js）" class="headerlink" title="前端（Vue.js）"></a>前端（Vue.js）</h5><ol><li><p><strong>项目初始化</strong><br>使用 Vue CLI 创建一个新的 Vue.js 项目。</p><div class="code-wrapper"><pre><code class="hljs bash">vue create driver-service-frontend</code></pre></div></li><li><p><strong>安装依赖</strong><br>安装 axios 进行 HTTP 请求，以及 vue-router 进行路由管理。</p><div class="code-wrapper"><pre><code class="hljs bash">npm install axios vue-router</code></pre></div></li><li><p><strong>配置路由</strong><br>在 <code>src/router/index.js</code> 中配置应用的路由。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Register</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Register&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Login&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;    <span class="hljs-attr">routes</span>: [        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>,            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Register&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Register</span>        &#125;,        &#123;            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Login&#x27;</span>,            <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span>        &#125;    ]&#125;)</code></pre></div></li><li><p><strong>创建组件</strong><br>创建用户注册、登录、主页等组件。</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- Register.vue --&gt;&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;用户注册&lt;/h2&gt;        &lt;form @submit.prevent=&quot;register&quot;&gt;            &lt;div&gt;                &lt;label&gt;用户名:&lt;/label&gt;                &lt;input v-model=&quot;user.username&quot; type=&quot;text&quot; required /&gt;            &lt;/div&gt;            &lt;div&gt;                &lt;label&gt;密码:&lt;/label&gt;                &lt;input v-model=&quot;user.password&quot; type=&quot;password&quot; required /&gt;            &lt;/div&gt;            &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;        &lt;/form&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from &#x27;axios&#x27;export default &#123;    data() &#123;        return &#123;            user: &#123;                username: &#x27;&#x27;,                password: &#x27;&#x27;            &#125;        &#125;    &#125;,    methods: &#123;        async register() &#123;            try &#123;                const response = await axios.post(&#x27;/api/users/register&#x27;, this.user)                console.log(&#x27;注册成功:&#x27;, response.data)            &#125; catch (error) &#123;                console.error(&#x27;注册失败:&#x27;, error)            &#125;        &#125;    &#125;&#125;&lt;/script&gt;</code></pre></div></li><li><p><strong>与后端集成</strong><br>使用 axios 调用后端 API 完成用户注册、登录等操作。</p></li></ol><h4 id="部署与测试"><a href="#部署与测试" class="headerlink" title="部署与测试"></a>部署与测试</h4><ol><li><p><strong>后端部署</strong><br>将 Spring Boot 应用打包成 jar 文件，并部署到服务器上。</p><div class="code-wrapper"><pre><code class="hljs bash">mvn clean packagejava -jar target/driver-service-0.0.1-SNAPSHOT.jar</code></pre></div></li><li><p><strong>前端部署</strong><br>使用 npm 构建 Vue.js 项目，并将生成的静态文件部署到 Web 服务器上。</p><div class="code-wrapper"><pre><code class="hljs bash">npm run build</code></pre></div></li><li><p><strong>测试</strong><br>通过 Postman 或浏览器进行接口测试，确保各项功能正常运行。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Three.js可视化企业实战WEBGL课-2024升级版</title>
    <link href="/2024/05/31/Three-js%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98WEBGL%E8%AF%BE-2024%E5%8D%87%E7%BA%A7%E7%89%88/"/>
    <url>/2024/05/31/Three-js%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98WEBGL%E8%AF%BE-2024%E5%8D%87%E7%BA%A7%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Three-js-重要组件和模块"><a href="#Three-js-重要组件和模块" class="headerlink" title="Three.js 重要组件和模块"></a>Three.js 重要组件和模块</h1><p>Three.js 是一个功能强大的 JavaScript 库，用于在 Web 浏览器中创建和显示动画 3D 图形。它的丰富 API 和模块化设计使得开发者可以轻松构建复杂的 3D 场景和动画效果。本文将详细介绍 Three.js 中的一些重要组件和模块，包括场景、相机、几何体、材质、光源、渲染器和控制器等。</p><h2 id="1-场景-Scene"><a href="#1-场景-Scene" class="headerlink" title="1. 场景 (Scene)"></a>1. 场景 (Scene)</h2><p>场景是 Three.js 的核心组件之一，用于容纳和管理 3D 对象、光源和相机。所有的 3D 对象都必须添加到场景中，才能被渲染器绘制。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();</code></pre></div><h2 id="2-相机-Camera"><a href="#2-相机-Camera" class="headerlink" title="2. 相机 (Camera)"></a>2. 相机 (Camera)</h2><p>相机定义了视图的角度和范围。Three.js 提供了多种相机类型，其中最常用的是透视相机 (PerspectiveCamera) 和正交相机 (OrthographicCamera)。</p><h3 id="2-1-透视相机"><a href="#2-1-透视相机" class="headerlink" title="2.1 透视相机"></a>2.1 透视相机</h3><p>透视相机模仿了人眼的视角，适合大多数 3D 场景。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);</code></pre></div><h3 id="2-2-正交相机"><a href="#2-2-正交相机" class="headerlink" title="2.2 正交相机"></a>2.2 正交相机</h3><p>正交相机不考虑距离缩放，适合二维图表和 UI 元素的渲染。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">OrthographicCamera</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);</code></pre></div><h2 id="3-几何体-Geometry"><a href="#3-几何体-Geometry" class="headerlink" title="3. 几何体 (Geometry)"></a>3. 几何体 (Geometry)</h2><p>几何体定义了 3D 对象的形状和结构。Three.js 提供了多种内置几何体，如立方体、球体、平面、圆柱体等。</p><h3 id="3-1-BoxGeometry"><a href="#3-1-BoxGeometry" class="headerlink" title="3.1 BoxGeometry"></a>3.1 BoxGeometry</h3><p>创建一个立方体几何体：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);</code></pre></div><h3 id="3-2-SphereGeometry"><a href="#3-2-SphereGeometry" class="headerlink" title="3.2 SphereGeometry"></a>3.2 SphereGeometry</h3><p>创建一个球体几何体：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);</code></pre></div><h2 id="4-材质-Material"><a href="#4-材质-Material" class="headerlink" title="4. 材质 (Material)"></a>4. 材质 (Material)</h2><p>材质定义了几何体的表面属性，如颜色、光泽、纹理等。常用的材质包括 MeshBasicMaterial、MeshStandardMaterial 和 MeshPhongMaterial。</p><h3 id="4-1-MeshBasicMaterial"><a href="#4-1-MeshBasicMaterial" class="headerlink" title="4.1 MeshBasicMaterial"></a>4.1 MeshBasicMaterial</h3><p>一种不受光照影响的材质：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);</code></pre></div><h3 id="4-2-MeshStandardMaterial"><a href="#4-2-MeshStandardMaterial" class="headerlink" title="4.2 MeshStandardMaterial"></a>4.2 MeshStandardMaterial</h3><p>一种支持光照和物理属性的材质：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span>, <span class="hljs-attr">roughness</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">metalness</span>: <span class="hljs-number">0.5</span> &#125;);</code></pre></div><h2 id="5-光源-Light"><a href="#5-光源-Light" class="headerlink" title="5. 光源 (Light)"></a>5. 光源 (Light)</h2><p>光源用于照亮场景中的几何体，Three.js 提供了多种光源类型，如环境光 (AmbientLight)、点光源 (PointLight)、平行光 (DirectionalLight) 和聚光灯 (SpotLight)。</p><h3 id="5-1-AmbientLight"><a href="#5-1-AmbientLight" class="headerlink" title="5.1 AmbientLight"></a>5.1 AmbientLight</h3><p>环境光为场景提供整体照明：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0x404040</span>);scene.<span class="hljs-title function_">add</span>(light);</code></pre></div><h3 id="5-2-PointLight"><a href="#5-2-PointLight" class="headerlink" title="5.2 PointLight"></a>5.2 PointLight</h3><p>点光源从一个点向所有方向发射光线：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>);light.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);scene.<span class="hljs-title function_">add</span>(light);</code></pre></div><h2 id="6-渲染器-Renderer"><a href="#6-渲染器-Renderer" class="headerlink" title="6. 渲染器 (Renderer)"></a>6. 渲染器 (Renderer)</h2><p>渲染器负责将场景中的对象绘制到屏幕上。Three.js 提供了 WebGLRenderer，这是最常用的渲染器，支持现代浏览器中的硬件加速。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);</code></pre></div><h2 id="7-控制器-Controls"><a href="#7-控制器-Controls" class="headerlink" title="7. 控制器 (Controls)"></a>7. 控制器 (Controls)</h2><p>控制器用于处理用户输入，如鼠标、键盘等，允许用户交互并控制视图。最常用的是 OrbitControls，允许用户旋转、缩放和平移视图。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;<span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);controls.<span class="hljs-property">enableDamping</span> = <span class="hljs-literal">true</span>;</code></pre></div><h2 id="8-动画循环-Animation-Loop"><a href="#8-动画循环-Animation-Loop" class="headerlink" title="8. 动画循环 (Animation Loop)"></a>8. 动画循环 (Animation Loop)</h2><p>为了创建动画效果，需要在渲染器中添加一个动画循环，不断更新场景并重新渲染。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 更新控制器</span>    controls.<span class="hljs-title function_">update</span>();    <span class="hljs-comment">// 渲染场景</span>    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">animate</span>();</code></pre></div><h2 id="9-纹理-Texture"><a href="#9-纹理-Texture" class="headerlink" title="9. 纹理 (Texture)"></a>9. 纹理 (Texture)</h2><p>纹理用于给几何体表面添加图像或图案。Three.js 提供了 TextureLoader 用于加载纹理图像。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();<span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/texture.jpg&#x27;</span>);<span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">map</span>: texture &#125;);</code></pre></div><h2 id="10-模型加载器-Model-Loader"><a href="#10-模型加载器-Model-Loader" class="headerlink" title="10. 模型加载器 (Model Loader)"></a>10. 模型加载器 (Model Loader)</h2><p>Three.js 支持多种 3D 模型格式，如 GLTF、OBJ 和 FBX，可以使用相应的加载器来加载和显示模型。</p><h3 id="10-1-GLTFLoader"><a href="#10-1-GLTFLoader" class="headerlink" title="10.1 GLTFLoader"></a>10.1 GLTFLoader</h3><p>加载 GLTF 格式的 3D 模型：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GLTFLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/loaders/GLTFLoader.js&#x27;</span>;<span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>();loader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/model.gltf&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">gltf</span>) &#123;    scene.<span class="hljs-title function_">add</span>(gltf.<span class="hljs-property">scene</span>);&#125;);</code></pre></div><h2 id="示例：创建一个完整的-3D-场景"><a href="#示例：创建一个完整的-3D-场景" class="headerlink" title="示例：创建一个完整的 3D 场景"></a>示例：创建一个完整的 3D 场景</h2><p>下面是一个完整的示例，展示了如何使用 Three.js 创建一个简单的 3D 场景，包括相机、几何体、材质、光源、渲染器和控制器。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer, controls;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 创建场景</span>    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    <span class="hljs-comment">// 创建相机</span>    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);    <span class="hljs-comment">// 创建渲染器</span>    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>(&#123; <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> &#125;);    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);    <span class="hljs-comment">// 添加控制器</span>    controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);    controls.<span class="hljs-property">enableDamping</span> = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 添加几何体和材质</span>    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-comment">// 添加光源</span>    <span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0x404040</span>);    scene.<span class="hljs-title function_">add</span>(ambientLight);    <span class="hljs-keyword">const</span> pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>);    pointLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    scene.<span class="hljs-title function_">add</span>(pointLight);    <span class="hljs-comment">// 监听窗口大小变化</span>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, onWindowResize, <span class="hljs-literal">false</span>);    <span class="hljs-comment">// 开始动画循环</span>    <span class="hljs-title function_">animate</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">onWindowResize</span>(<span class="hljs-params"></span>) &#123;    camera.<span class="hljs-property">aspect</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;    camera.<span class="hljs-title function_">updateProjectionMatrix</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 更新控制器</span>    controls.<span class="hljs-title function_">update</span>();    <span class="hljs-comment">// 渲染场景</span>    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">init</span>();</code></pre></div><h1 id="Three-js-可视化实战"><a href="#Three-js-可视化实战" class="headerlink" title="Three.js 可视化实战"></a>Three.js 可视化实战</h1><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-安装-Node-js-和-npm"><a href="#1-1-安装-Node-js-和-npm" class="headerlink" title="1.1 安装 Node.js 和 npm"></a>1.1 安装 Node.js 和 npm</h3><p>首先，需要安装 Node.js 和 npm，可以从 <a href="https://nodejs.org/">Node.js 官网</a> 下载并安装。</p><h3 id="1-2-创建项目文件夹"><a href="#1-2-创建项目文件夹" class="headerlink" title="1.2 创建项目文件夹"></a>1.2 创建项目文件夹</h3><p>创建一个新的项目文件夹，并在其中初始化一个新的 Node.js 项目：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> threejs-visualization<span class="hljs-built_in">cd</span> threejs-visualizationnpm init -y</code></pre></div><h3 id="1-3-安装-Three-js"><a href="#1-3-安装-Three-js" class="headerlink" title="1.3 安装 Three.js"></a>1.3 安装 Three.js</h3><p>在项目中安装 Three.js：</p><div class="code-wrapper"><pre><code class="hljs bash">npm install three</code></pre></div><h3 id="1-4-创建项目结构"><a href="#1-4-创建项目结构" class="headerlink" title="1.4 创建项目结构"></a>1.4 创建项目结构</h3><p>在项目文件夹中创建以下文件和文件夹结构：</p><div class="code-wrapper"><pre><code class="hljs stylus">threejs-visualization/├── index<span class="hljs-selector-class">.html</span>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>└── styles.css</code></pre></div><h2 id="2-编写-HTML-文件"><a href="#2-编写-HTML-文件" class="headerlink" title="2. 编写 HTML 文件"></a>2. 编写 HTML 文件</h2><p>在 <code>index.html</code> 文件中，设置基本的 HTML 结构，并引入 Three.js 和你的 JavaScript 文件：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Three.js Visualization<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/three/build/three.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="3-编写-CSS-文件"><a href="#3-编写-CSS-文件" class="headerlink" title="3. 编写 CSS 文件"></a>3. 编写 CSS 文件</h2><p>在 <code>styles.css</code> 文件中，设置基本的样式：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">overflow</span>: hidden;&#125;<span class="hljs-selector-id">#container</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;&#125;</code></pre></div><h2 id="4-编写-JavaScript-文件"><a href="#4-编写-JavaScript-文件" class="headerlink" title="4. 编写 JavaScript 文件"></a>4. 编写 JavaScript 文件</h2><p>在 <code>main.js</code> 文件中，编写 Three.js 的基本代码，创建一个 3D 场景、相机和渲染器。</p><h3 id="4-1-初始化场景和相机"><a href="#4-1-初始化场景和相机" class="headerlink" title="4.1 初始化场景和相机"></a>4.1 初始化场景和相机</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 创建场景</span>    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    <span class="hljs-comment">// 创建相机</span>    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 创建渲染器</span>    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);&#125;<span class="hljs-title function_">init</span>();</code></pre></div><h3 id="4-2-创建几何体和材质"><a href="#4-2-创建几何体和材质" class="headerlink" title="4.2 创建几何体和材质"></a>4.2 创建几何体和材质</h3><p>在 <code>init</code> 函数中添加一个几何体对象，例如立方体：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCube</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-keyword">return</span> cube;&#125;<span class="hljs-keyword">let</span> cube = <span class="hljs-title function_">addCube</span>();</code></pre></div><h3 id="4-3-添加光源"><a href="#4-3-添加光源" class="headerlink" title="4.3 添加光源"></a>4.3 添加光源</h3><p>为场景添加光源，使得几何体有更好的视觉效果：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addLight</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>);    light.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    scene.<span class="hljs-title function_">add</span>(light);&#125;<span class="hljs-title function_">addLight</span>();</code></pre></div><h3 id="4-4-动画循环"><a href="#4-4-动画循环" class="headerlink" title="4.4 动画循环"></a>4.4 动画循环</h3><p>添加一个动画循环来渲染场景：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 旋转立方体</span>    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.01</span>;    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.01</span>;    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">animate</span>();</code></pre></div><h3 id="4-5-添加坐标轴和数据点"><a href="#4-5-添加坐标轴和数据点" class="headerlink" title="4.5 添加坐标轴和数据点"></a>4.5 添加坐标轴和数据点</h3><p>为了创建一个3D图表，需要添加坐标轴和一些数据点。以下是如何实现的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAxis</span>(<span class="hljs-params">size</span>) &#123;    <span class="hljs-keyword">const</span> axesHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AxesHelper</span>(size);    scene.<span class="hljs-title function_">add</span>(axesHelper);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDataPoints</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">point</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> sphere = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);        sphere.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(point.<span class="hljs-property">x</span>, point.<span class="hljs-property">y</span>, point.<span class="hljs-property">z</span>);        scene.<span class="hljs-title function_">add</span>(sphere);    &#125;);&#125;<span class="hljs-keyword">const</span> data = [    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;,    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> &#125;,    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> &#125;,];<span class="hljs-title function_">createAxis</span>(<span class="hljs-number">5</span>);<span class="hljs-title function_">createDataPoints</span>(data);</code></pre></div><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><p>将以上代码整合到一起，最终的 <code>main.js</code> 文件如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer, cube;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 创建场景</span>    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    <span class="hljs-comment">// 创建相机</span>    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 创建渲染器</span>    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);    <span class="hljs-comment">// 添加立方体</span>    cube = <span class="hljs-title function_">addCube</span>();    <span class="hljs-comment">// 添加光源</span>    <span class="hljs-title function_">addLight</span>();    <span class="hljs-comment">// 添加坐标轴</span>    <span class="hljs-title function_">createAxis</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 添加数据点</span>    <span class="hljs-keyword">const</span> data = [        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> &#125;,    ];    <span class="hljs-title function_">createDataPoints</span>(data);    <span class="hljs-comment">// 开始动画</span>    <span class="hljs-title function_">animate</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addCube</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-keyword">return</span> cube;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addLight</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> light = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>);    light.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    scene.<span class="hljs-title function_">add</span>(light);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createAxis</span>(<span class="hljs-params">size</span>) &#123;    <span class="hljs-keyword">const</span> axesHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AxesHelper</span>(size);    scene.<span class="hljs-title function_">add</span>(axesHelper);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDataPoints</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">point</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> sphere = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);        sphere.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(point.<span class="hljs-property">x</span>, point.<span class="hljs-property">y</span>, point.<span class="hljs-property">z</span>);        scene.<span class="hljs-title function_">add</span>(sphere);    &#125;);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 旋转立方体</span>    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.01</span>;    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.01</span>;    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">init</span>();</code></pre></div><h2 id="6-运行项目"><a href="#6-运行项目" class="headerlink" title="6. 运行项目"></a>6. 运行项目</h2><p>打开命令行，进入项目文件夹，然后运行一个简单的 HTTP 服务器：</p><div class="code-wrapper"><pre><code class="hljs bash">npx http-server</code></pre></div><p>在浏览器中访问 <code>http://localhost:8080</code>，你将看到一个3D图表，其中包含一个旋转的立方体、坐标轴和数据点。</p><h2 id="7-高级应用"><a href="#7-高级应用" class="headerlink" title="7. 高级应用"></a>7. 高级应用</h2><p>通过以上基础知识，你已经学会了如何使用 Three.js 创建一个简单的 3D 图表。接下来，我们将探讨一些高级功能和应用。</p><h3 id="7-1-使用-OrbitControls-实现交互"><a href="#7-1-使用-OrbitControls-实现交互" class="headerlink" title="7.1 使用 OrbitControls 实现交互"></a>7.1 使用 OrbitControls 实现交互</h3><p>Three.js 提供了 <code>OrbitControls</code> 类，使用户可以通过鼠标操作来旋转、缩放和移动视图。以下是如何集成 <code>OrbitControls</code> 的示例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// ...之前的代码...</span>    <span class="hljs-comment">// 添加交互控件</span>    <span class="hljs-keyword">const</span> controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);    controls.<span class="hljs-property">enableDamping</span> = <span class="hljs-literal">true</span>;    <span class="hljs-comment">// 更新动画循环中的控件</span>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title function_">requestAnimationFrame</span>(animate);        <span class="hljs-comment">// 更新控件</span>        controls.<span class="hljs-title function_">update</span>();        <span class="hljs-comment">// 旋转立方体</span>        cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.01</span>;        cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.01</span>;        renderer.<span class="hljs-title function_">render</span>(scene, camera);    &#125;    <span class="hljs-title function_">animate</span>();&#125;</code></pre></div><h3 id="7-2-高级材质和光照"><a href="#7-2-高级材质和光照" class="headerlink" title="7.2 高级材质和光照"></a>7.2 高级材质和光照</h3><p>Three.js 支持多种高级材质和光照效果，使得 3D 对象可以呈现出更加真实的外观。以下示例展示了如何使用 <code>MeshStandardMaterial</code> 和多种光源：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCube</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span>, <span class="hljs-attr">roughness</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">metalness</span>: <span class="hljs-number">0.5</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-keyword">return</span> cube;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addLight</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0x404040</span>);    scene.<span class="hljs-title function_">add</span>(ambientLight);    <span class="hljs-keyword">const</span> spotLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SpotLight</span>(<span class="hljs-number">0xffffff</span>);    spotLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);    scene.<span class="hljs-title function_">add</span>(spotLight);&#125;</code></pre></div><h3 id="7-3-动态数据更新"><a href="#7-3-动态数据更新" class="headerlink" title="7.3 动态数据更新"></a>7.3 动态数据更新</h3><p>通过 WebSocket 或 API 调用实现数据的动态更新，可以使 3D 图表实时反映最新的数据。以下是一个模拟动态数据更新的示例：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDataPoints</span>(<span class="hljs-params">newData</span>) &#123;    <span class="hljs-comment">// 移除旧的数据点</span>    scene.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">isMesh</span> &amp;&amp; child.<span class="hljs-property">geometry</span>.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;SphereGeometry&#x27;</span>) &#123;            scene.<span class="hljs-title function_">remove</span>(child);        &#125;    &#125;);    <span class="hljs-comment">// 添加新的数据点</span>    <span class="hljs-title function_">createDataPoints</span>(newData);&#125;<span class="hljs-comment">// 模拟动态数据更新</span><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> newData = [        &#123; <span class="hljs-attr">x</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">z</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">z</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span>, <span class="hljs-attr">z</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">5</span> &#125;,    ];    <span class="hljs-title function_">updateDataPoints</span>(newData);&#125;, <span class="hljs-number">5000</span>);</code></pre></div><h1 id="Geometry-进阶详解：作用、原理、意义与优化"><a href="#Geometry-进阶详解：作用、原理、意义与优化" class="headerlink" title="Geometry 进阶详解：作用、原理、意义与优化"></a>Geometry 进阶详解：作用、原理、意义与优化</h1><p>在 Three.js 中，Geometry 是构建 3D 对象的基础，通过定义顶点、面和其它属性来描述 3D 形状。本篇文章将深入探讨 Three.js 中 Geometry 的作用、原理、意义以及如何优化几何体的性能。</p><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>Geometry 在 Three.js 中扮演了描述 3D 对象形状的角色。它包含了顶点、面和边的信息，用于定义物体的几何形状。常见的 Geometry 类型包括：</p><ul><li><strong>BoxGeometry</strong>：定义一个立方体。</li><li><strong>SphereGeometry</strong>：定义一个球体。</li><li><strong>PlaneGeometry</strong>：定义一个平面。</li><li><strong>CylinderGeometry</strong>：定义一个圆柱体。</li><li><strong>TorusGeometry</strong>：定义一个圆环。</li></ul><p>通过 Geometry，我们可以创建各种复杂的 3D 形状，并将它们添加到场景中进行渲染。</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>Geometry 由一系列顶点（Vertices）和面（Faces）组成。顶点定义了几何体的形状，面由顶点连接形成。Three.js 中的 Geometry 还可以包含法线（Normals）、UV 坐标和其它属性，用于更详细地描述几何体的外观和行为。</p><h3 id="2-1-顶点和面"><a href="#2-1-顶点和面" class="headerlink" title="2.1 顶点和面"></a>2.1 顶点和面</h3><p>顶点是几何体的基本单位，通常用三维坐标表示。面是由顶点组成的多边形，通常是三角形或四边形。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Geometry</span>();<span class="hljs-comment">// 添加顶点</span>geometry.<span class="hljs-property">vertices</span>.<span class="hljs-title function_">push</span>(    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<span class="hljs-comment">// 添加面（使用顶点索引）</span>geometry.<span class="hljs-property">faces</span>.<span class="hljs-title function_">push</span>(    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Face3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>),    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Face3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));</code></pre></div><h3 id="2-2-法线和-UV-坐标"><a href="#2-2-法线和-UV-坐标" class="headerlink" title="2.2 法线和 UV 坐标"></a>2.2 法线和 UV 坐标</h3><p>法线用于计算光照效果，UV 坐标用于纹理映射。</p><div class="code-wrapper"><pre><code class="hljs javascript">geometry.<span class="hljs-property">faces</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">face</span> =&gt;</span> &#123;    face.<span class="hljs-property">vertexNormals</span>.<span class="hljs-title function_">push</span>(        <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),        <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>),        <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)    );&#125;);<span class="hljs-comment">// 添加 UV 坐标</span>geometry.<span class="hljs-property">faceVertexUvs</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(    [<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)],    [<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)]);</code></pre></div><h2 id="3-意义"><a href="#3-意义" class="headerlink" title="3. 意义"></a>3. 意义</h2><p>Geometry 在 3D 可视化和计算机图形学中具有重要意义。通过定义几何体的形状和属性，开发者可以创建逼真的 3D 场景和物体。这对于游戏开发、虚拟现实、建筑设计等领域尤为重要。Geometry 使得复杂的 3D 模型的创建和操控变得更加灵活和高效。</p><h2 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h2><p>在处理复杂几何体时，优化是至关重要的。以下是一些优化 Geometry 的方法：</p><h3 id="4-1-简化几何体"><a href="#4-1-简化几何体" class="headerlink" title="4.1 简化几何体"></a>4.1 简化几何体</h3><p>减少顶点和面数可以显著提高渲染性能。可以使用 LOD（Level of Detail）技术，根据距离选择不同复杂度的几何体。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 较高细节</span><span class="hljs-keyword">const</span> simpleGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 较低细节</span><span class="hljs-keyword">const</span> lod = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title function_">LOD</span>();lod.<span class="hljs-title function_">addLevel</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material), <span class="hljs-number">0</span>);lod.<span class="hljs-title function_">addLevel</span>(<span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(simpleGeometry, material), <span class="hljs-number">50</span>);scene.<span class="hljs-title function_">add</span>(lod);</code></pre></div><h3 id="4-2-合并几何体"><a href="#4-2-合并几何体" class="headerlink" title="4.2 合并几何体"></a>4.2 合并几何体</h3><p>将多个几何体合并为一个几何体，可以减少绘制调用次数，从而提高性能。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometries = [geometry1, geometry2, geometry3];<span class="hljs-keyword">const</span> mergedGeometry = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">BufferGeometryUtils</span>.<span class="hljs-title function_">mergeBufferGeometries</span>(geometries);<span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(mergedGeometry, material);scene.<span class="hljs-title function_">add</span>(mesh);</code></pre></div><h3 id="4-3-使用-BufferGeometry"><a href="#4-3-使用-BufferGeometry" class="headerlink" title="4.3 使用 BufferGeometry"></a>4.3 使用 BufferGeometry</h3><p><code>BufferGeometry</code> 是 <code>Geometry</code> 的高效版本，使用类型化数组存储顶点和属性数据，性能更高。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>();<span class="hljs-keyword">const</span> vertices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>([    -<span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,    <span class="hljs-number">1.0</span>, -<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,    <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>,    -<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>]);geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;position&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(vertices, <span class="hljs-number">3</span>));</code></pre></div><h3 id="4-4-使用-InstancedMesh"><a href="#4-4-使用-InstancedMesh" class="headerlink" title="4.4 使用 InstancedMesh"></a>4.4 使用 InstancedMesh</h3><p>对于大量相同几何体的实例，可以使用 <code>InstancedMesh</code> 提高渲染效率。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);<span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">InstancedMesh</span>(geometry, material, <span class="hljs-number">100</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;    <span class="hljs-keyword">const</span> matrix = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Matrix4</span>();    matrix.<span class="hljs-title function_">setPosition</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>);    mesh.<span class="hljs-title function_">setMatrixAt</span>(i, matrix);&#125;scene.<span class="hljs-title function_">add</span>(mesh);</code></pre></div><h2 id="5-示例：创建一个复杂的-3D-模型"><a href="#5-示例：创建一个复杂的-3D-模型" class="headerlink" title="5. 示例：创建一个复杂的 3D 模型"></a>5. 示例：创建一个复杂的 3D 模型</h2><p>下面是一个完整的示例，展示了如何创建一个复杂的 3D 模型，并应用优化技术。</p><h3 id="5-1-初始化场景"><a href="#5-1-初始化场景" class="headerlink" title="5.1 初始化场景"></a>5.1 初始化场景</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BufferGeometryUtils</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/utils/BufferGeometryUtils.js&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer, controls;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>(&#123; <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> &#125;);    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);    controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);    <span class="hljs-title function_">addLight</span>();    <span class="hljs-title function_">addComplexModel</span>();    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, onWindowResize, <span class="hljs-literal">false</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addLight</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0x404040</span>);    scene.<span class="hljs-title function_">add</span>(ambientLight);    <span class="hljs-keyword">const</span> directionalLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>);    directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);    scene.<span class="hljs-title function_">add</span>(directionalLight);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addComplexModel</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometries = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());        geometry.<span class="hljs-title function_">translate</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>);        geometries.<span class="hljs-title function_">push</span>(geometry);    &#125;    <span class="hljs-keyword">const</span> mergedGeometry = <span class="hljs-title class_">BufferGeometryUtils</span>.<span class="hljs-title function_">mergeBufferGeometries</span>(geometries);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(mergedGeometry, material);    scene.<span class="hljs-title function_">add</span>(mesh);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">onWindowResize</span>(<span class="hljs-params"></span>) &#123;    camera.<span class="hljs-property">aspect</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;    camera.<span class="hljs-title function_">updateProjectionMatrix</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    controls.<span class="hljs-title function_">update</span>();    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">init</span>();<span class="hljs-title function_">animate</span>();</code></pre></div><h1 id="纹理材质高级操作指南"><a href="#纹理材质高级操作指南" class="headerlink" title="纹理材质高级操作指南"></a>纹理材质高级操作指南</h1><p>在 Three.js 中，纹理和材质是创建逼真 3D 场景的关键元素。通过合理使用和高级操作，可以实现各种复杂的视觉效果。本指南将深入探讨 Three.js 中纹理材质的高级操作，包括多种材质类型的使用、纹理映射、纹理操作和优化技术。</p><h2 id="1-材质类型"><a href="#1-材质类型" class="headerlink" title="1. 材质类型"></a>1. 材质类型</h2><p>Three.js 提供了多种材质，每种材质都有其特定的用途和特点。以下是一些常用的材质类型：</p><h3 id="1-1-MeshBasicMaterial"><a href="#1-1-MeshBasicMaterial" class="headerlink" title="1.1 MeshBasicMaterial"></a>1.1 MeshBasicMaterial</h3><p>一种不受光照影响的材质，通常用于简单的几何体或背景。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);</code></pre></div><h3 id="1-2-MeshStandardMaterial"><a href="#1-2-MeshStandardMaterial" class="headerlink" title="1.2 MeshStandardMaterial"></a>1.2 MeshStandardMaterial</h3><p>一种物理基础渲染 (PBR) 材质，支持光照、反射和粗糙度。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span>, <span class="hljs-attr">roughness</span>: <span class="hljs-number">0.5</span>, <span class="hljs-attr">metalness</span>: <span class="hljs-number">0.5</span> &#125;);</code></pre></div><h3 id="1-3-MeshPhongMaterial"><a href="#1-3-MeshPhongMaterial" class="headerlink" title="1.3 MeshPhongMaterial"></a>1.3 MeshPhongMaterial</h3><p>一种光滑的材质，支持高光反射，适合用于金属和光滑表面。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshPhongMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x0000ff</span>, <span class="hljs-attr">shininess</span>: <span class="hljs-number">100</span> &#125;);</code></pre></div><h3 id="1-4-MeshPhysicalMaterial"><a href="#1-4-MeshPhysicalMaterial" class="headerlink" title="1.4 MeshPhysicalMaterial"></a>1.4 MeshPhysicalMaterial</h3><p>一种更高级的 PBR 材质，支持透明度、折射率等属性。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshPhysicalMaterial</span>(&#123;    <span class="hljs-attr">color</span>: <span class="hljs-number">0xffff00</span>,    <span class="hljs-attr">roughness</span>: <span class="hljs-number">0.1</span>,    <span class="hljs-attr">metalness</span>: <span class="hljs-number">1.0</span>,    <span class="hljs-attr">clearcoat</span>: <span class="hljs-number">1.0</span>,    <span class="hljs-attr">clearcoatRoughness</span>: <span class="hljs-number">0.1</span>&#125;);</code></pre></div><h2 id="2-纹理映射"><a href="#2-纹理映射" class="headerlink" title="2. 纹理映射"></a>2. 纹理映射</h2><p>纹理映射是将图像应用到 3D 模型表面的一种技术。Three.js 支持多种纹理映射类型，如颜色纹理、法线贴图、粗糙度贴图等。</p><h3 id="2-1-加载纹理"><a href="#2-1-加载纹理" class="headerlink" title="2.1 加载纹理"></a>2.1 加载纹理</h3><p>使用 <code>TextureLoader</code> 加载纹理：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();<span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/texture.jpg&#x27;</span>);</code></pre></div><h3 id="2-2-应用纹理"><a href="#2-2-应用纹理" class="headerlink" title="2.2 应用纹理"></a>2.2 应用纹理</h3><p>将纹理应用到材质上：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">map</span>: texture &#125;);<span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();<span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);scene.<span class="hljs-title function_">add</span>(mesh);</code></pre></div><h3 id="2-3-法线贴图"><a href="#2-3-法线贴图" class="headerlink" title="2.3 法线贴图"></a>2.3 法线贴图</h3><p>法线贴图用于模拟表面细节，增强视觉效果：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> normalMap = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/normalMap.jpg&#x27;</span>);<span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123;    <span class="hljs-attr">map</span>: texture,    <span class="hljs-attr">normalMap</span>: normalMap&#125;);</code></pre></div><h3 id="2-4-粗糙度贴图"><a href="#2-4-粗糙度贴图" class="headerlink" title="2.4 粗糙度贴图"></a>2.4 粗糙度贴图</h3><p>粗糙度贴图用于控制表面粗糙度，实现更真实的材质效果：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> roughnessMap = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/roughnessMap.jpg&#x27;</span>);<span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123;    <span class="hljs-attr">map</span>: texture,    <span class="hljs-attr">roughnessMap</span>: roughnessMap&#125;);</code></pre></div><h2 id="3-高级纹理操作"><a href="#3-高级纹理操作" class="headerlink" title="3. 高级纹理操作"></a>3. 高级纹理操作</h2><p>在使用纹理时，可以进行一些高级操作，如纹理重复、偏移、旋转等。</p><h3 id="3-1-纹理重复"><a href="#3-1-纹理重复" class="headerlink" title="3.1 纹理重复"></a>3.1 纹理重复</h3><p>可以设置纹理在几何体表面上的重复方式：</p><div class="code-wrapper"><pre><code class="hljs javascript">texture.<span class="hljs-property">wrapS</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span>;texture.<span class="hljs-property">wrapT</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span>;texture.<span class="hljs-property">repeat</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 水平和垂直重复两次</span></code></pre></div><h3 id="3-2-纹理偏移"><a href="#3-2-纹理偏移" class="headerlink" title="3.2 纹理偏移"></a>3.2 纹理偏移</h3><p>可以设置纹理的偏移量：</p><div class="code-wrapper"><pre><code class="hljs javascript">texture.<span class="hljs-property">offset</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);  <span class="hljs-comment">// 将纹理在水平和垂直方向上偏移0.5</span></code></pre></div><h3 id="3-3-纹理旋转"><a href="#3-3-纹理旋转" class="headerlink" title="3.3 纹理旋转"></a>3.3 纹理旋转</h3><p>可以设置纹理的旋转角度：</p><div class="code-wrapper"><pre><code class="hljs javascript">texture.<span class="hljs-property">rotation</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">4</span>;  <span class="hljs-comment">// 将纹理旋转45度</span>texture.<span class="hljs-property">center</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>);  <span class="hljs-comment">// 旋转中心设置为纹理的中心</span></code></pre></div><h2 id="4-优化技术"><a href="#4-优化技术" class="headerlink" title="4. 优化技术"></a>4. 优化技术</h2><p>在处理复杂场景时，优化纹理和材质的性能至关重要。以下是一些常见的优化技术：</p><h3 id="4-1-使用低分辨率纹理"><a href="#4-1-使用低分辨率纹理" class="headerlink" title="4.1 使用低分辨率纹理"></a>4.1 使用低分辨率纹理</h3><p>对于远距离或不重要的对象，可以使用低分辨率纹理，减少内存和计算资源的消耗。</p><h3 id="4-2-纹理压缩"><a href="#4-2-纹理压缩" class="headerlink" title="4.2 纹理压缩"></a>4.2 纹理压缩</h3><p>使用纹理压缩技术（如 DDS、KTX 格式），可以显著减少纹理的内存占用和加载时间。</p><h3 id="4-3-合并纹理"><a href="#4-3-合并纹理" class="headerlink" title="4.3 合并纹理"></a>4.3 合并纹理</h3><p>将多个小纹理合并为一张大纹理（纹理集），可以减少纹理切换次数，提高渲染性能。</p><h3 id="4-4-延迟加载"><a href="#4-4-延迟加载" class="headerlink" title="4.4 延迟加载"></a>4.4 延迟加载</h3><p>对于不立即需要的纹理，可以使用延迟加载技术，在需要时才加载纹理，避免一次性加载过多资源。</p><h3 id="4-5-使用-mipmaps"><a href="#4-5-使用-mipmaps" class="headerlink" title="4.5 使用 mipmaps"></a>4.5 使用 mipmaps</h3><p>Three.js 默认会为纹理生成 mipmaps，可以提高缩放时的纹理质量和渲染性能。</p><div class="code-wrapper"><pre><code class="hljs javascript">texture.<span class="hljs-property">generateMipmaps</span> = <span class="hljs-literal">true</span>;</code></pre></div><h2 id="5-示例：创建一个高级纹理材质的-3D-模型"><a href="#5-示例：创建一个高级纹理材质的-3D-模型" class="headerlink" title="5. 示例：创建一个高级纹理材质的 3D 模型"></a>5. 示例：创建一个高级纹理材质的 3D 模型</h2><p>下面是一个完整的示例，展示了如何创建一个使用高级纹理材质的 3D 模型，并应用优化技术。</p><h3 id="5-1-初始化场景-1"><a href="#5-1-初始化场景-1" class="headerlink" title="5.1 初始化场景"></a>5.1 初始化场景</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer, controls;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>(&#123; <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> &#125;);    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);    controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>);    <span class="hljs-title function_">addLight</span>();    <span class="hljs-title function_">addTexturedModel</span>();    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, onWindowResize, <span class="hljs-literal">false</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addLight</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0x404040</span>);    scene.<span class="hljs-title function_">add</span>(ambientLight);    <span class="hljs-keyword">const</span> directionalLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">1</span>);    directionalLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);    scene.<span class="hljs-title function_">add</span>(directionalLight);&#125;</code></pre></div><h3 id="5-2-加载和应用纹理"><a href="#5-2-加载和应用纹理" class="headerlink" title="5.2 加载和应用纹理"></a>5.2 加载和应用纹理</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addTexturedModel</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>();    <span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/texture.jpg&#x27;</span>);    <span class="hljs-keyword">const</span> normalMap = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/normalMap.jpg&#x27;</span>);    <span class="hljs-keyword">const</span> roughnessMap = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;path/to/roughnessMap.jpg&#x27;</span>);    texture.<span class="hljs-property">wrapS</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span>;    texture.<span class="hljs-property">wrapT</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">RepeatWrapping</span>;    texture.<span class="hljs-property">repeat</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123;        <span class="hljs-attr">map</span>: texture,        <span class="hljs-attr">normalMap</span>: normalMap,        <span class="hljs-attr">roughnessMap</span>: roughnessMap    &#125;);    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(mesh);&#125;</code></pre></div><h3 id="5-3-动画循环"><a href="#5-3-动画循环" class="headerlink" title="5.3 动画循环"></a>5.3 动画循环</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    controls.<span class="hljs-title function_">update</span>();    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">init</span>();<span class="hljs-title function_">animate</span>();</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>three.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网易Three.js可视化企业实战WEBGL课2024</title>
    <link href="/2024/05/31/%E7%BD%91%E6%98%93Three-js%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98WEBGL%E8%AF%BE/"/>
    <url>/2024/05/31/%E7%BD%91%E6%98%93Three-js%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BC%81%E4%B8%9A%E5%AE%9E%E6%88%98WEBGL%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Three-js-可视化简介"><a href="#Three-js-可视化简介" class="headerlink" title="Three.js 可视化简介"></a>Three.js 可视化简介</h1><p>Three.js 是一个跨平台的 JavaScript 库，用于在 Web 浏览器中创建和显示动画 3D 计算机图形。它基于 WebGL 技术，提供了简化的接口和丰富的功能，帮助开发者轻松构建复杂的 3D 场景和动画效果。Three.js 的强大之处在于它抽象了底层的 WebGL 细节，使开发者无需深入了解 WebGL 的复杂 API 就能创建高质量的 3D 可视化内容。</p><p>Three.js 提供了多种内置的几何体（如立方体、球体、圆柱体等）、材质（如基础材质、标准材质、物理材质等）和光源（如环境光、平行光、点光源等），使得构建 3D 场景变得非常直观。此外，它还支持纹理映射、阴影、后处理效果和动画等高级功能，能够满足各种 3D 可视化需求。</p><p>Three.js 的应用范围广泛，包括数据可视化、建筑和产品设计、游戏开发、虚拟现实（VR）和增强现实（AR）等领域。通过 Three.js，开发者可以将复杂的数据和模型以直观、交互性强的 3D 形式展示在网页上，从而提升用户体验和数据理解能力。</p><h1 id="Three-js-3D图表构建教程"><a href="#Three-js-3D图表构建教程" class="headerlink" title="Three.js 3D图表构建教程"></a>Three.js 3D图表构建教程</h1><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><h3 id="1-1-安装Node-js和npm"><a href="#1-1-安装Node-js和npm" class="headerlink" title="1.1 安装Node.js和npm"></a>1.1 安装Node.js和npm</h3><p>首先，需要安装Node.js和npm，可以从<a href="https://nodejs.org/">Node.js官网</a>下载并安装。</p><h3 id="1-2-创建项目文件夹"><a href="#1-2-创建项目文件夹" class="headerlink" title="1.2 创建项目文件夹"></a>1.2 创建项目文件夹</h3><p>创建一个新的项目文件夹，并在其中初始化一个新的Node.js项目：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> threejs-chart<span class="hljs-built_in">cd</span> threejs-chartnpm init -y</code></pre></div><h3 id="1-3-安装Three-js"><a href="#1-3-安装Three-js" class="headerlink" title="1.3 安装Three.js"></a>1.3 安装Three.js</h3><p>在项目中安装Three.js：</p><div class="code-wrapper"><pre><code class="hljs bash">npm install three</code></pre></div><h3 id="1-4-创建项目结构"><a href="#1-4-创建项目结构" class="headerlink" title="1.4 创建项目结构"></a>1.4 创建项目结构</h3><p>在项目文件夹中创建以下文件和文件夹结构：</p><div class="code-wrapper"><pre><code class="hljs stylus">threejs-chart/├── index<span class="hljs-selector-class">.html</span>├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>└── styles.css</code></pre></div><h2 id="2-编写HTML文件"><a href="#2-编写HTML文件" class="headerlink" title="2. 编写HTML文件"></a>2. 编写HTML文件</h2><p>在<code>index.html</code>文件中，设置基本的HTML结构，并引入Three.js和你的JavaScript文件：</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Three.js 3D Chart<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chart-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/three/build/three.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="3-编写CSS文件"><a href="#3-编写CSS文件" class="headerlink" title="3. 编写CSS文件"></a>3. 编写CSS文件</h2><p>在<code>styles.css</code>文件中，设置基本的样式：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">overflow</span>: hidden;&#125;<span class="hljs-selector-id">#chart-container</span> &#123;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;&#125;</code></pre></div><h2 id="4-编写JavaScript文件"><a href="#4-编写JavaScript文件" class="headerlink" title="4. 编写JavaScript文件"></a>4. 编写JavaScript文件</h2><p>在<code>main.js</code>文件中，编写Three.js的基本代码，创建一个3D场景、相机和渲染器：</p><h3 id="4-1-初始化场景和相机"><a href="#4-1-初始化场景和相机" class="headerlink" title="4.1 初始化场景和相机"></a>4.1 初始化场景和相机</h3><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 创建场景</span>    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    <span class="hljs-comment">// 创建相机</span>    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 创建渲染器</span>    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;chart-container&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);&#125;<span class="hljs-title function_">init</span>();</code></pre></div><h3 id="4-2-创建一个立方体"><a href="#4-2-创建一个立方体" class="headerlink" title="4.2 创建一个立方体"></a>4.2 创建一个立方体</h3><p>在<code>init</code>函数中添加一个立方体对象：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCube</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-keyword">return</span> cube;&#125;<span class="hljs-keyword">let</span> cube = <span class="hljs-title function_">addCube</span>();</code></pre></div><h3 id="4-3-动画循环"><a href="#4-3-动画循环" class="headerlink" title="4.3 动画循环"></a>4.3 动画循环</h3><p>添加一个动画循环来渲染场景：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 旋转立方体</span>    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.01</span>;    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.01</span>;    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">animate</span>();</code></pre></div><h3 id="4-4-添加坐标轴和数据"><a href="#4-4-添加坐标轴和数据" class="headerlink" title="4.4 添加坐标轴和数据"></a>4.4 添加坐标轴和数据</h3><p>为了创建一个3D图表，需要添加坐标轴和一些数据点。以下是如何实现的：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAxis</span>(<span class="hljs-params">size</span>) &#123;    <span class="hljs-keyword">const</span> axesHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AxesHelper</span>(size);    scene.<span class="hljs-title function_">add</span>(axesHelper);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDataPoints</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">point</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> sphere = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);        sphere.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(point.<span class="hljs-property">x</span>, point.<span class="hljs-property">y</span>, point.<span class="hljs-property">z</span>);        scene.<span class="hljs-title function_">add</span>(sphere);    &#125;);&#125;<span class="hljs-keyword">const</span> data = [    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;,    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> &#125;,    &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> &#125;,];<span class="hljs-title function_">createAxis</span>(<span class="hljs-number">5</span>);<span class="hljs-title function_">createDataPoints</span>(data);</code></pre></div><h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><p>将以上代码整合到一起，最终的<code>main.js</code>文件如下：</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">THREE</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three&#x27;</span>;<span class="hljs-keyword">let</span> scene, camera, renderer, cube;<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// 创建场景</span>    scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();    <span class="hljs-comment">// 创建相机</span>    camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<span class="hljs-number">75</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> / <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1000</span>);    camera.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">5</span>;    <span class="hljs-comment">// 创建渲染器</span>    renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>();    renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>);    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;chart-container&#x27;</span>).<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>);    <span class="hljs-comment">// 添加立方体</span>    cube = <span class="hljs-title function_">addCube</span>();    <span class="hljs-comment">// 添加坐标轴</span>    <span class="hljs-title function_">createAxis</span>(<span class="hljs-number">5</span>);    <span class="hljs-comment">// 添加数据点</span>    <span class="hljs-keyword">const</span> data = [        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> &#125;,        &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span> &#125;,    ];    <span class="hljs-title function_">createDataPoints</span>(data);    <span class="hljs-comment">// 开始动画</span>    <span class="hljs-title function_">animate</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">addCube</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>();    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0x00ff00</span> &#125;);    <span class="hljs-keyword">const</span> cube = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);    scene.<span class="hljs-title function_">add</span>(cube);    <span class="hljs-keyword">return</span> cube;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createAxis</span>(<span class="hljs-params">size</span>) &#123;    <span class="hljs-keyword">const</span> axesHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AxesHelper</span>(size);    scene.<span class="hljs-title function_">add</span>(axesHelper);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createDataPoints</span>(<span class="hljs-params">data</span>) &#123;    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereGeometry</span>(<span class="hljs-number">0.1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span> &#125;);    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">point</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> sphere = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);        sphere.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(point.<span class="hljs-property">x</span>, point.<span class="hljs-property">y</span>, point.<span class="hljs-property">z</span>);        scene.<span class="hljs-title function_">add</span>(sphere);    &#125;);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-title function_">requestAnimationFrame</span>(animate);    <span class="hljs-comment">// 旋转立方体</span>    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> += <span class="hljs-number">0.01</span>;    cube.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> += <span class="hljs-number">0.01</span>;    renderer.<span class="hljs-title function_">render</span>(scene, camera);&#125;<span class="hljs-title function_">init</span>();</code></pre></div><h2 id="6-运行项目"><a href="#6-运行项目" class="headerlink" title="6. 运行项目"></a>6. 运行项目</h2><p>打开命令行，进入项目文件夹，然后运行一个简单的HTTP服务器：</p><div class="code-wrapper"><pre><code class="hljs bash">npx http-server</code></pre></div><p>在浏览器中访问<code>http://localhost:8080</code>，你将看到一个3D图表，其中包含一个旋转的立方体、坐标轴和数据点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>three.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕ke体系-AI人工智能算法工程师</title>
    <link href="/2024/05/29/%E6%85%95ke%E4%BD%93%E7%B3%BB-AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2024/05/29/%E6%85%95ke%E4%BD%93%E7%B3%BB-AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-深度卷积神经网络（Deep-CNN）"><a href="#1-深度卷积神经网络（Deep-CNN）" class="headerlink" title="1. 深度卷积神经网络（Deep CNN）"></a>1. 深度卷积神经网络（Deep CNN）</h2><p>深度卷积神经网络通过增加更多的卷积层和池化层来捕捉更多的图像特征，从而提高图像分类的准确率。以下是一个使用VGG16模型的示例，该模型在ImageNet挑战中表现优异。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.applications <span class="hljs-keyword">import</span> VGG16<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers, models<span class="hljs-comment"># 加载预训练的VGG16模型</span>vgg16_base = VGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>, input_shape=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>, <span class="hljs-number">3</span>))<span class="hljs-comment"># 冻结卷积基</span>vgg16_base.trainable = <span class="hljs-literal">False</span><span class="hljs-comment"># 构建模型</span>model = models.Sequential()model.add(vgg16_base)model.add(layers.Flatten())model.add(layers.Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))model.add(layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<span class="hljs-comment"># 编译模型</span>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,              loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>,              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<span class="hljs-comment"># 数据预处理</span>train_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)validation_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)train_generator = train_datagen.flow_from_directory(    <span class="hljs-string">&#x27;data/train&#x27;</span>,    target_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>),    batch_size=<span class="hljs-number">20</span>,    class_mode=<span class="hljs-string">&#x27;binary&#x27;</span>)validation_generator = validation_datagen.flow_from_directory(    <span class="hljs-string">&#x27;data/validation&#x27;</span>,    target_size=(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>),    batch_size=<span class="hljs-number">20</span>,    class_mode=<span class="hljs-string">&#x27;binary&#x27;</span>)<span class="hljs-comment"># 训练模型</span>history = model.fit(    train_generator,    steps_per_epoch=<span class="hljs-number">100</span>,    epochs=<span class="hljs-number">30</span>,    validation_data=validation_generator,    validation_steps=<span class="hljs-number">50</span>)</code></pre></div><h2 id="2-长短期记忆网络（LSTM）"><a href="#2-长短期记忆网络（LSTM）" class="headerlink" title="2. 长短期记忆网络（LSTM）"></a>2. 长短期记忆网络（LSTM）</h2><p>LSTM是RNN的一种变体，擅长处理长时间依赖问题。以下是一个改进版的LSTM实现，用于文本生成任务。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Embedding, LSTM, Dense<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.text <span class="hljs-keyword">import</span> Tokenizer<span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.sequence <span class="hljs-keyword">import</span> pad_sequences<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 文本数据</span>data = <span class="hljs-string">&quot;&quot;&quot;Your text data here&quot;&quot;&quot;</span><span class="hljs-comment"># 文本预处理</span>tokenizer = Tokenizer()tokenizer.fit_on_texts([data])total_words = <span class="hljs-built_in">len</span>(tokenizer.word_index) + <span class="hljs-number">1</span>input_sequences = []<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data.split(<span class="hljs-string">&#x27;\n&#x27;</span>):    token_list = tokenizer.texts_to_sequences([line])[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(token_list)):        n_gram_sequence = token_list[:i+<span class="hljs-number">1</span>]        input_sequences.append(n_gram_sequence)<span class="hljs-comment"># 填充序列</span>max_sequence_len = <span class="hljs-built_in">max</span>([<span class="hljs-built_in">len</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> input_sequences])input_sequences = np.array(pad_sequences(input_sequences, maxlen=max_sequence_len, padding=<span class="hljs-string">&#x27;pre&#x27;</span>))<span class="hljs-comment"># 创建预测变量</span>xs, labels = input_sequences[:,:-<span class="hljs-number">1</span>],input_sequences[:,-<span class="hljs-number">1</span>]ys = tf.keras.utils.to_categorical(labels, num_classes=total_words)<span class="hljs-comment"># 构建模型</span>model = tf.keras.Sequential()model.add(Embedding(total_words, <span class="hljs-number">100</span>, input_length=max_sequence_len-<span class="hljs-number">1</span>))model.add(LSTM(<span class="hljs-number">150</span>))model.add(Dense(total_words, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<span class="hljs-comment"># 编译模型</span>model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<span class="hljs-comment"># 训练模型</span>history = model.fit(xs, ys, epochs=<span class="hljs-number">100</span>, verbose=<span class="hljs-number">1</span>)<span class="hljs-comment"># 文本生成</span>seed_text = <span class="hljs-string">&quot;Your seed text&quot;</span>next_words = <span class="hljs-number">50</span><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(next_words):    token_list = tokenizer.texts_to_sequences([seed_text])[<span class="hljs-number">0</span>]    token_list = pad_sequences([token_list], maxlen=max_sequence_len-<span class="hljs-number">1</span>, padding=<span class="hljs-string">&#x27;pre&#x27;</span>)    predicted = np.argmax(model.predict(token_list, verbose=<span class="hljs-number">0</span>), axis=-<span class="hljs-number">1</span>)    output_word = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">for</span> word, index <span class="hljs-keyword">in</span> tokenizer.word_index.items():        <span class="hljs-keyword">if</span> index == predicted:            output_word = word            <span class="hljs-keyword">break</span>    seed_text += <span class="hljs-string">&quot; &quot;</span> + output_word<span class="hljs-built_in">print</span>(seed_text)</code></pre></div><h2 id="3-注意力机制和Transformer模型"><a href="#3-注意力机制和Transformer模型" class="headerlink" title="3. 注意力机制和Transformer模型"></a>3. 注意力机制和Transformer模型</h2><p>Transformer模型引入了注意力机制，在自然语言处理任务中表现出色。以下是一个简单的Transformer实现，用于机器翻译任务。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense, LayerNormalization, Embedding, MultiHeadAttention, Dropout<span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Model<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">class</span> <span class="hljs-title class_">TransformerBlock</span>(tf.keras.layers.Layer):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, embed_dim, num_heads, ff_dim, rate=<span class="hljs-number">0.1</span></span>):        <span class="hljs-built_in">super</span>(TransformerBlock, self).__init__()        self.att = MultiHeadAttention(num_heads=num_heads, key_dim=embed_dim)        self.ffn = tf.keras.Sequential(            [Dense(ff_dim, activation=<span class="hljs-string">&quot;relu&quot;</span>), Dense(embed_dim),]        )        self.layernorm1 = LayerNormalization(epsilon=<span class="hljs-number">1e-6</span>)        self.layernorm2 = LayerNormalization(epsilon=<span class="hljs-number">1e-6</span>)        self.dropout1 = Dropout(rate)        self.dropout2 = Dropout(rate)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, inputs, training</span>):        attn_output = self.att(inputs, inputs)        attn_output = self.dropout1(attn_output, training=training)        out1 = self.layernorm1(inputs + attn_output)        ffn_output = self.ffn(out1)        ffn_output = self.dropout2(ffn_output, training=training)        <span class="hljs-keyword">return</span> self.layernorm2(out1 + ffn_output)<span class="hljs-comment"># 创建Transformer模型</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenAndPositionEmbedding</span>(tf.keras.layers.Layer):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, maxlen, vocab_size, embed_dim</span>):        <span class="hljs-built_in">super</span>(TokenAndPositionEmbedding, self).__init__()        self.token_emb = Embedding(input_dim=vocab_size, output_dim=embed_dim)        self.pos_emb = Embedding(input_dim=maxlen, output_dim=embed_dim)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, x</span>):        maxlen = tf.shape(x)[-<span class="hljs-number">1</span>]        positions = tf.<span class="hljs-built_in">range</span>(start=<span class="hljs-number">0</span>, limit=maxlen, delta=<span class="hljs-number">1</span>)        positions = self.pos_emb(positions)        x = self.token_emb(x)        <span class="hljs-keyword">return</span> x + positionsvocab_size = <span class="hljs-number">20000</span>  <span class="hljs-comment"># 词汇表大小</span>maxlen = <span class="hljs-number">200</span>  <span class="hljs-comment"># 序列最大长度</span>embed_dim = <span class="hljs-number">32</span>  <span class="hljs-comment"># 嵌入维度</span>num_heads = <span class="hljs-number">2</span>  <span class="hljs-comment"># 注意力头数量</span>ff_dim = <span class="hljs-number">32</span>  <span class="hljs-comment"># 前馈网络维度</span>inputs = tf.keras.Input(shape=(maxlen,))embedding_layer = TokenAndPositionEmbedding(maxlen, vocab_size, embed_dim)x = embedding_layer(inputs)transformer_block = TransformerBlock(embed_dim, num_heads, ff_dim)x = transformer_block(x)x = tf.keras.layers.GlobalAveragePooling1D()(x)x = tf.keras.layers.Dropout(<span class="hljs-number">0.1</span>)(x)x = tf.keras.layers.Dense(<span class="hljs-number">20</span>, activation=<span class="hljs-string">&quot;relu&quot;</span>)(x)x = tf.keras.layers.Dropout(<span class="hljs-number">0.1</span>)(x)outputs = tf.keras.layers.Dense(<span class="hljs-number">2</span>, activation=<span class="hljs-string">&quot;softmax&quot;</span>)(x)model = Model(inputs=inputs, outputs=outputs)<span class="hljs-comment"># 编译和训练模型</span>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&quot;adam&quot;</span>, loss=<span class="hljs-string">&quot;sparse_categorical_crossentropy&quot;</span>, metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>])</code></pre></div><h2 id="4-自编码器（Autoencoder）"><a href="#4-自编码器（Autoencoder）" class="headerlink" title="4. 自编码器（Autoencoder）"></a>4. 自编码器（Autoencoder）</h2><p>自编码器用于无监督学习，尤其是在数据降维和特征提取方面。以下是一个简单的自编码器实现示例，用于图像去噪。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers, models<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 构建自编码器模型</span>input_img = tf.keras.Input(shape=(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))<span class="hljs-comment"># 编码器</span>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(input_img)x = layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)encoded = layers.MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)<span class="hljs-comment"># 解码器</span>x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(encoded)x = layers.UpSampling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(x)x = layers.Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)x = layers.UpSampling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))(x)decoded = layers.Conv2D(<span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>)(x)autoencoder = models.Model(input_img, decoded)autoencoder.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>)<span class="hljs-comment"># 加载数据并添加噪声</span>(x_train, _), (x_test, _) = tf.keras.datasets.mnist.load_data()x_train = x_train.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.</span>x_test = x_test.astype(<span class="hljs-string">&#x27;float32&#x27;</span>) / <span class="hljs-number">255.</span>x_train = np.reshape(x_train, (<span class="hljs-built_in">len</span>(x_train), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))x_test = np.reshape(x_test, (<span class="hljs-built_in">len</span>(x_test), <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>))noise_factor = <span class="hljs-number">0.5</span>x_train_noisy = x_train + noise_factor * np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>, size=x_train.shape)x_test_noisy = x_test + noise_factor * np.random.normal(loc=<span class="hljs-number">0.0</span>, scale=<span class="hljs-number">1.0</span>, size=x_test.shape)x_train_noisy = np.clip(x_train_noisy, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>)x_test_noisy = np.clip(x_test_noisy, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>)<span class="hljs-comment"># 训练自编码器</span>autoencoder.fit(x_train_noisy, x_train,                epochs=<span class="hljs-number">50</span>,                batch_size=<span class="hljs-number">256</span>,                shuffle=<span class="hljs-literal">True</span>,                validation_data=(x_test_noisy, x_test))<span class="hljs-comment"># 预测</span>decoded_imgs = autoencoder.predict(x_test_noisy)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕ke慕w-鸿蒙NEXT应用开发工程师</title>
    <link href="/2024/05/28/%E6%85%95ke%E6%85%95w-%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2024/05/28/%E6%85%95ke%E6%85%95w-%E9%B8%BF%E8%92%99NEXT%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>鸿蒙系统采用ArkTS作为其原生开发语言。如果你对TypeScript有所了解，那么你将能够轻松过渡到ArkTS，因为它并非一种全新的语言，而是基于TypeScript的扩展。这意味着我们可以省去学习新语言的过程，只需专注于鸿蒙的UI框架——ArkUI。</p><p>ArkUI框架与React类似，采用声明式开发模式来构建用户界面，并内置了全面的状态管理机制，无需像React那样面对众多复杂的第三方状态管理库。</p><p>鸿蒙系统的内置组件布局设计灵感来源于CSS，包括margin、padding、flex、grid、栅格系统和媒体查询等概念，这些都是Web前端开发者所熟悉的。</p><p>鸿蒙Next提供了一套完整的开发、调试、测试和发布流程，集成在一个IDE中。如果你之前使用过IntelliJ IDEA，那么你将发现使用鸿蒙的DevEco Studio是无缝的，因为它是基于IntelliJ IDEA Community版深度定制的。即使你是Neovim或VSCode的忠实用户，DevEco Studio同样易于上手。</p><h3 id="IDE介绍"><a href="#IDE介绍" class="headerlink" title="IDE介绍"></a>IDE介绍</h3><p>在开始之前，让我们先了解鸿蒙的IDE——DevEco Studio。</p><h4 id="DevEco-Studio-安装"><a href="#DevEco-Studio-安装" class="headerlink" title="DevEco-Studio 安装"></a>DevEco-Studio 安装</h4><p>目前，DevEco Studio提供了三个版本供下载：</p><ul><li>Windows(64-bit)</li><li>Mac(X86)</li><li>Mac(ARM)</li></ul><p>请注意，当前版本需要Node 18.x环境。对于前端开发者，建议安装nvm，并预先切换到正确的Node版本。</p><p>安装nvm后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvm install 18.14.1<br>nvm use 18.14.1<br>node -v<br></code></pre></td></tr></table></figure><p>这样，在安装DevEco时，你可以选择本地的Node环境。如果你的本地没有Node，也可以选择全新安装。</p><p>如果一切顺利，在Diagnose界面，你将看到所有的检查项都显示为对号，这表示安装成功。</p><p>我相信你能够自己摸索着创建一个”Hello World”项目。</p><p>接下来，你将看到项目中默认创建了大量的文件。起初，我和你一样，不知道从何下手。但经过研究，我发现许多文件都存在两个版本：一个是模块级的，另一个是应用级的。</p><p>为了更清晰地展示，我制作了一张图，图中左侧列出的文件都是应用和模块的两个版本。</p><p>整个<code>entry</code>目录称为一个Module，该目录将编译为一个以<code>.hap</code>为后缀的文件，即HAP包。</p><p>当应用最终发布时，它将被打包成一个以<code>.app</code>为扩展名的文件，并上传到华为应用商店。</p><p>Module不仅限于<code>entry</code>类型，还包括其他类型。为了简化，我仍然总结了一张图：</p><p>初看可能会感到有些困惑，但实际上，作为初学者，我们只需要关注<code>entry</code>模块。其他Module类型可以等到更深入的开发阶段再去文档中了解。</p><p>在<code>entry</code>目录下，有一个<code>src/main/ets/pages/index.ets</code>文件，这是用户看到的第一个页面。我们先打开这个文件，稍后我将详细介绍对应的语法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Index</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Column</span>() &#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br>          .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">50</span>)<br>          .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>          .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>          .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一行的<code>@Entry</code>装饰器表明这是应用的入口点，<code>build()</code>方法返回的是整个声明式UI的页面结构。</p><p>翻译过来，就是在较高的<code>Row</code>组件中放置了一个较宽的<code>Column</code>组件，其中包含了一个文本组件，字体大小为50。</p><p>在右上角选择<code>previewer</code>，点击<code>run</code>按钮即可运行并预览效果。</p><h3 id="输出效果"><a href="#输出效果" class="headerlink" title="输出效果"></a>输出效果</h3><p>这就是整个开发流程。刚才的代码看起来是否非常熟悉？是的，它是TypeScript！</p><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>鸿蒙的主要开发语言是ArkTS（以<code>.ets</code>文件为扩展名）。它看起来如此熟悉，因为它是TypeScript的一个超集，基本上是TS代码。最大的区别或特点是，在编译时对静态类型的检查和分析进行了增强，并对一些动态特性进行了一些限制。这使得程序在运行时类型都是已知的，减少了运行时错误并提高了程序性能。</p><p>例如，强制类型不允许使用<code>any</code>或<code>unknown</code>类型。也不能使用<code>obj as any</code>之类的语法动态给对象添加属性和方法，更不能在运行时使用<code>delete</code>删除属性或方法。在某些需要<code>any</code>类型的情况下，建议使用<code>Record&lt;string, Object&gt;</code>类型。</p><p>编译器默认开启了TypeScript的一些严格模式，例如<code>strictPropertyInitialization</code>，要求强制给定初始值。<code>strictNullChecks</code>强制进行空值安全检查等。</p><p>总之，你能想到的所有运行时的动态类型特性都将受到限制，尽量不要使用。更多详细的语法规则可以参考官方文档中关于《从TypeScript到ArkTS的适配规则》的文章，内容非常详细。实际上，在开发过程中，DevEco Studio会提供非常好的错误报告信息，因此你可以先不必了解这些语法规则，等到遇到问题时再去查询。</p><h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3><p>ArkUI框架是基于ArkTS的UI框架，采用声明式开发范式，数据驱动UI更新，并提供了页面级路由导航等。</p><p>在页面布局方面，提供了多种媒体查询，例如：</p><ul><li>设备类型</li><li>窗口宽高监听</li><li>折叠屏状态</li><li>横竖屏查询</li></ul><p>统一了单位，例如：</p><ul><li><code>vp</code> 虚拟像素</li><li><code>fp</code> 字体像素，用户端的设置会乘以系数 <code>1fp = 1vp * scale</code></li></ul><p>并提供了多种栅格系统，窗口栅格会根据容器宽度自动匹配栅格数量：</p><ul><li>4格：small（360～600），手机竖屏</li><li>8格：medium（600～840），手机横屏，pad竖屏，折叠屏</li><li>12格：large（840～1440），pad横屏，2in1</li><li>12格：x-large（1440～），全屏</li></ul><p>需要注意的是，目前稳定主推的应用模型称为Stage模型。如果你在学习过程中看到FA模型，那就是旧版教程，可以不用看了。</p><p>下面我们在代码层面了解一下如何声明UI。</p><h4 id="声明式UI描述"><a href="#声明式UI描述" class="headerlink" title="声明式UI描述"></a>声明式UI描述</h4><p>声明式UI的描述方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Column</span>() &#123;<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 1&#x27;</span>)<br>  <span class="hljs-title class_">Divider</span>()<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;item 2&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Column</code>是容器组件，所以后面带有<code>&#123;&#125;</code>，包含子组件。非容器组件则无需<code>&#123;&#125;</code>。</p><p>给组件配置属性通常使用链式调用的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Text</span>(<br>  <span class="hljs-string">&quot;hello&quot;</span><br>).<span class="hljs-title function_">fontSize</span>(<br>  <span class="hljs-number">20</span><br>).<span class="hljs-title function_">fontColor</span>(<br>  <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span><br>).<span class="hljs-title function_">fontWeight</span>(<br>  <span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span><br>);<br></code></pre></td></tr></table></figure><p>为了更加清晰，通常会写成这种格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>  .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">20</span>)<br>  .<span class="hljs-title function_">fontColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>)<br>  .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>);<br></code></pre></td></tr></table></figure><h4 id="添加事件处理"><a href="#添加事件处理" class="headerlink" title="添加事件处理"></a>添加事件处理</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;Click me&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">myText</span> = <span class="hljs-string">&quot;ArkUI&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>ArkUI中大量使用了装饰器，包括我们之前看到的<code>@entry</code>表示入口。再看一个最简单的自定义组件：</p><p>ArkUI中用<code>@Component</code>装饰的<code>struct</code>结构代表自定义组件。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">MyComponent</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 在build函数里返回UI描述</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在当前流行的数据驱动UI编程范式中，UI &#x3D; f(State)，状态是不可或缺的。</p><p>ArkUI中用<code>@State</code>装饰器来声明状态，Parent可以直接覆盖Child State：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-comment">// 父组件覆盖State</span><br>      <span class="hljs-title class_">MyComponent</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hi&quot;</span> &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和React中的State类似，状态的变化可以引起UI更新，但注意这个状态不是immutable的，UI是否可以观察到状态的变化要看数据类型，具体要参考详细的文档。</p><p>下面是典型的事件处理中修改状态，引起UI刷新的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">HelloComponent</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span>;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 基础类型的状态变量message改变驱动UI刷新，</span><br>          <span class="hljs-comment">// UI从&#x27;Hello, World!&#x27;刷新为&#x27;Hello, ArkUI!&#x27;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Hello, ArkUI!&#x27;</span>;<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>@State</code>只是组件内部的状态。如果想在状态更改时引发Child组件的更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>鸿蒙</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件项目-自动化云测平台/Spingboot3.X/微服务/Kafka3.x学习指南</title>
    <link href="/2024/05/28/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2024/05/28/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="基于云的测试实践"><a href="#基于云的测试实践" class="headerlink" title="基于云的测试实践"></a>基于云的测试实践</h2><p>在当今快速发展的科技时代，云计算技术已经深入到各个领域，其中软件测试行业也受到了显著的影响。本文将探讨云测试的概念、优势、挑战以及如何有效利用云资源进行软件测试。</p><p><strong>测试的现状与痛点</strong></p><p>首先，我们来审视一下软件测试领域目前所面临的一些挑战。测试成本高昂，特别是兼容性测试，随着移动设备的快速迭代，跨设备的兼容性测试变得越来越复杂和耗时。此外，测试机系统需要频繁升级，测试硬件和软件的利用率低，测试环境管理复杂，这些都是测试领域需要解决的问题。</p><p><strong>云计算带给测试领域的变革</strong></p><p>云计算作为一种服务提供模型，允许用户随时随地通过网络访问共享资源池的资源。这种模式为软件测试带来了新的可能性。企业不再需要购买大量实体机型进行测试，而是可以将测试过程迁移到云中，利用云计算平台提供的计算和存储资源进行测试活动。资源的自动生成、弹性分配、按需服务等特性，有效解决了传统测试中的诸多问题。</p><p><strong>云测试平台</strong></p><p>云测试平台是一种利用云环境进行测试的方法，它集约化利用测试资源，规模化完成测试任务。用户可以通过浏览器提交测试项目和脚本，测试任务在云端执行，并将结果集中展现给用户。云测试平台具有节约成本、服务按需付费、扩展性强、高可靠性、联网即得和加速测试等优点。然而，它也存在一些缺点，如平台服务及数据的安全性、供应商角色增加的复杂度以及虚拟技术不固定影响性能测试等。</p><p><strong>云测试平台的选择</strong></p><p>市场上存在多种云测试平台，如Xamarin Test Cloud、Testin云测、AWS Device Farm、Sauce Labs等，它们各自拥有独特的优势。在选择云测试平台时，需要考虑供应商的选择标准、软硬件标准、安全性、服务类型（私有云、公有云或混合云平台）等因素。</p><p><strong>AWS Device Farm</strong></p><p>AWS Device Farm是一个相对较新的云测试平台，它支持的设备数量较少，但在脚本测试中支持的语言和框架发展迅速。AWS Device Farm是唯一支持测试FireOS设备的云测试平台，支持远程访问测试、脚本测试、并行运行测试等多种功能。它还提供了丰富的日志记录操作、与CloudTrail集成、模拟不同网络连接状态的性能监控和分析等功能。</p><p><strong>云测试平台搭建</strong></p><p>搭建云测试平台可以分为用户接口层、云测试项目管理层和云管理层。用户接口层是用户访问云测试系统的入口，通过Web界面实现测试任务的提交、状态查看和结果审阅。云测试项目管理层负责资源预留和调度，监控测试状态，并分析统计测试结果。云管理层则是测试云的基础设施，根据任务管理层的指令来选择镜像并创建虚拟机，动态分配和管理各种虚拟资源。</p><h2 id="微服务架构的陷阱与最佳实践"><a href="#微服务架构的陷阱与最佳实践" class="headerlink" title="微服务架构的陷阱与最佳实践"></a>微服务架构的陷阱与最佳实践</h2><p>在当今快速发展的软件开发领域，微服务架构因其灵活性和可扩展性而受到广泛关注。然而，微服务架构并非没有陷阱。本文将探讨微服务架构的一些常见问题，并提供一系列最佳实践，以帮助开发者和团队更有效地实施微服务。</p><h3 id="微服务架构的陷阱"><a href="#微服务架构的陷阱" class="headerlink" title="微服务架构的陷阱"></a>微服务架构的陷阱</h3><p>首先，我们来识别微服务架构中的一些常见陷阱：</p><ol><li><strong>服务拆分过细</strong>：过度强调“small”而忽略了服务的实用性和维护性。</li><li><strong>基础设施不完善</strong>：忽略了“automated”的重要性，导致微服务架构难以维护和扩展。</li><li><strong>并非轻量级</strong>：随着规模的扩大，微服务的“lightweight”特性不再适用。</li></ol><h3 id="服务粒度"><a href="#服务粒度" class="headerlink" title="服务粒度"></a>服务粒度</h3><p>针对服务拆分过细的问题，可以基于团队规模进行服务拆分。这里引入了“三个火枪手”原则，即一个微服务由三个人负责开发。这种原则基于团队规模来划分服务数量，随着业务的发展和团队规模的扩大，可以进一步拆分服务。</p><h3 id="为什么选择三个人？"><a href="#为什么选择三个人？" class="headerlink" title="为什么选择三个人？"></a>为什么选择三个人？</h3><ul><li><strong>系统规模</strong>：三个人可以全面理解系统，同时进行有效的分工。</li><li><strong>团队管理</strong>：三个人可以形成稳定的备份，即使有人休假或调配，剩余人员仍可支撑。</li><li><strong>技术提升</strong>：三个人可以进行有效讨论，并快速达成一致。</li></ul><h3 id="拆分方法"><a href="#拆分方法" class="headerlink" title="拆分方法"></a>拆分方法</h3><p>在实施微服务架构时，拆分服务的具体方法也至关重要。以下是几种推荐的拆分策略：</p><ol><li><p><strong>基于业务进行拆分</strong>：识别系统中的业务模块，并将其拆分成独立的服务。需要注意的是，拆分粒度应根据“三个火枪手”原则来确定，避免过粗或过细。</p></li><li><p><strong>基于可扩展性拆分</strong>：将服务按照稳定性排序，将成熟和变动不大的服务拆分成稳定服务，而将经常变动的服务拆分成变动服务。</p></li><li><p><strong>基于可靠性拆分</strong>：将业务模块按照优先级排序，将核心服务和非核心服务分开，重点保护核心服务的高可用性。</p></li><li><p><strong>基于性能拆分</strong>：将性能要求高或压力大的模块拆分出来，避免影响其他服务。</p></li></ol><p>这些拆分方式可以根据实际情况自由组合。</p><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><p>微服务的成功不仅取决于服务的划分，更在于基础设施的完善。以下是微服务基础设施的关键组成部分：</p><ul><li><strong>服务发现</strong>、<strong>服务路由</strong>、<strong>服务容错</strong>：这是最基本的微服务基础设施。</li><li><strong>接口框架</strong>、<strong>API网关</strong>：提高开发效率和与外部服务对接的效率。</li><li><strong>自动化部署</strong>、<strong>自动化测试</strong>、<strong>配置中心</strong>：提升测试和运维效率。</li><li><strong>服务监控</strong>、<strong>服务跟踪</strong>、<strong>服务安全</strong>：提升监控效率。</li></ul><p>微服务的基础设施可能看起来是一个庞大的工程，但现有的开源解决方案如Spring Cloud可以帮助简化这一过程。此外，如果微服务的数量不多，并不是所有基础设施组件都是必需的。</p><h2 id="kafka工作原理"><a href="#kafka工作原理" class="headerlink" title="kafka工作原理"></a>kafka工作原理</h2><p>Kafka是一种流行的分布式流处理平台，它被设计用来处理高吞吐量的实时数据。本文将深入探讨Kafka的工作原理，包括其系统角色、数据结构、以及与Zookeeper的交互。</p><h3 id="Kafka系统的角色"><a href="#Kafka系统的角色" class="headerlink" title="Kafka系统的角色"></a>Kafka系统的角色</h3><p>在Kafka架构中，有几个关键角色：</p><ul><li><strong>Broker</strong>：Kafka服务器的实例，一个集群由多个Broker组成，每个Broker可以存储多个Topic。</li><li><strong>Topic</strong>：可以理解为消息队列的名称，是消息的分类。</li><li><strong>Partition</strong>：为了实现扩展性，一个Topic可以被分割成多个Partition，每个Partition是一个有序的队列，并且每个Partition中的每条消息都有一个唯一的offset。</li></ul><h3 id="Topic、Partition和Replica的关系"><a href="#Topic、Partition和Replica的关系" class="headerlink" title="Topic、Partition和Replica的关系"></a>Topic、Partition和Replica的关系</h3><p>Partition是Kafka中实现并行处理的关键。一个Topic可以有多个Partition，而每个Partition可以有多个Replica（副本）。这样设计可以提高系统的可用性和容错性。Partition的分配策略通常基于两种基本算法：Key Hash算法和Round Robin算法。</p><h3 id="Kafka与Zookeeper的交互"><a href="#Kafka与Zookeeper的交互" class="headerlink" title="Kafka与Zookeeper的交互"></a>Kafka与Zookeeper的交互</h3><p>Kafka使用Zookeeper来维护集群状态和协调分布式操作。Broker、Consumer和Producer都与Zookeeper交互：</p><ul><li><strong>Broker</strong>：在Zookeeper中注册信息，并更新元数据，如Topic和Partition信息。</li><li><strong>Consumer</strong>：使用Zookeeper来注册信息，包括消费的Partition列表，并发现Broker列表，建立连接并获取消息。</li><li><strong>Producer</strong>：与Zookeeper没有直接关系，主要与Broker交互。</li></ul><p>Zookeeper在Kafka中扮演着协调者的角色，但不直接存储Topic数据。</p><h3 id="Kafka的文件存储机制"><a href="#Kafka的文件存储机制" class="headerlink" title="Kafka的文件存储机制"></a>Kafka的文件存储机制</h3><p>Kafka的消息存储在磁盘上，文件以<code>offset.kafka</code>命名，这样设计便于根据offset快速查找消息。例如，要查找位于2049位置的消息，只需定位到2048.kafka文件即可。</p><h3 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h3><p>Kafka支持两种消息传递模式：广播（将消息发送给所有消费者）和发布订阅（只发送给订阅者）。通过Consumer Group（CG），Kafka实现了这两种模式：</p><ul><li>一个Topic的消息可以复制到所有CG，但每个CG中的Consumer只会收到消息的一份。</li><li>如果需要广播，每个Consumer可以有自己的CG。</li><li>如果需要单播，所有Consumer可以属于同一个CG。</li></ul><h3 id="Kafka的动态集群扩展"><a href="#Kafka的动态集群扩展" class="headerlink" title="Kafka的动态集群扩展"></a>Kafka的动态集群扩展</h3><p>Kafka通过Zookeeper实现动态集群扩展，无需更改客户端配置。Broker在Zookeeper中注册并保持元数据更新，客户端在Zookeeper上注册watcher，以感知变化并作出调整。</p><h3 id="如何查看Topic的Partition数量"><a href="#如何查看Topic的Partition数量" class="headerlink" title="如何查看Topic的Partition数量"></a>如何查看Topic的Partition数量</h3><p>可以使用Kafka提供的脚本<code>kakfa-topic.sh</code>来查看Topic的Partition数量：</p><div class="code-wrapper"><pre><code class="hljs shell">kafka-topic.sh --list --topic topicName --zookeeper zookeeper.servers.list</code></pre></div><h3 id="Zookeeper存储结构"><a href="#Zookeeper存储结构" class="headerlink" title="Zookeeper存储结构"></a>Zookeeper存储结构</h3><p>Zookeeper存储了Kafka集群的元数据，包括admin、consumers、config和brokers等节点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慕体系Python全能工程师2024之深入底层原理</title>
    <link href="/2024/05/27/%E6%85%95%E4%BD%93%E7%B3%BBPython%E5%85%A8%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%B8%882024%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2024/05/27/%E6%85%95%E4%BD%93%E7%B3%BBPython%E5%85%A8%E8%83%BD%E5%B7%A5%E7%A8%8B%E5%B8%882024%E4%B9%8B%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Python数据类型底层原理"><a href="#Python数据类型底层原理" class="headerlink" title="Python数据类型底层原理"></a>Python数据类型底层原理</h2><p>Python是一种动态类型的编程语言，它允许我们在不指定类型的情况下为变量赋值。例如，我们可以连续地给一个变量赋值为整数和字符串，而不会报错。这种灵活性源于Python的动态数据类型设计，其中每个变量都包含了值信息和类型额外信息。</p><blockquote><p>“夏のke”》 Ukoou·ㄷㅁΜ</p></blockquote><p>在Python的内部实现中，每个对象都是基于C语言编写的结构体，例如整型对象。一个整型在Python中实际上是一个指向C语言结构体的指针。这个结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">longobject</span> &#123;</span><br>    <span class="hljs-type">long</span> ob_refcnt;<br>    PyTypeObject *ob_type;<br>    <span class="hljs-type">size_t</span> ob_size;<br>    <span class="hljs-type">long</span> ob_digit[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个结构体中，<code>ob_refcnt</code>是引用计数，用于协助Python的垃圾回收（GC）。<code>ob_type</code>是类型对象，它编码了变量的类型信息。<code>ob_size</code>表示数据成员的大小，而<code>ob_digit</code>则包含了实际的整数值。</p><p>由于Python的动态类型系统，存储一个整型需要额外的开销。除了实际的数值之外，还需要存储类型和引用计数等信息。这种设计虽然带来了灵活性，但也增加了内存的使用。</p><p>列表（list）是Python中的标准可变多元素容器。它的底层实现是一个包含多个Python对象的指针数组。列表的C语言结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    PyObject_VAR_HEAD<br>    PyObject *ob_item; <span class="hljs-comment">// 指针数组</span><br>    Py_ssize_t allocated; <span class="hljs-comment">// 申请内存的槽个数</span><br>&#125; PyListObject;<br></code></pre></td></tr></table></figure><p>列表中的每个元素都是一个指向Python对象的指针。当添加或删除元素时，可能需要重新分配内存。不过，由于Python的实现细节，并不是每次操作都需要改变数组的大小。</p><p>NumPy库提供了固定类型的数组，这与Python原生的列表有所不同。NumPy数组的底层结构体中包含了头信息、数据、维度和步幅等信息，然后指向数组的第一个元素。通过步幅和维度可以快速定位到数组中的任何元素。</p><p>慕课Python全能工程师2024 字典（dict）在Python中的底层实现是基于哈希表的。只有可哈希的对象才能作为字典的键。Python使用伪随机探测的哈希表作为字典的底层结构。解决哈希碰撞的方法包括开放寻址、再hash法、链地址法、公共溢出区以及装填因子等。</p><p>集合（set）的实现与哈希表类似，它基于hash对元素进行散列，只包含对键的引用，没有对值的引用。</p><p>通过深入了解Python数据类型的底层原理，我们可以更好地理解Python的内存管理和性能特性。这对于编写高效、可维护的Python代码至关重要。</p><h2 id="Python封装底层实现原理"><a href="#Python封装底层实现原理" class="headerlink" title="Python封装底层实现原理"></a>Python封装底层实现原理</h2><p>慕课Python全能工程师2024 Python中的封装特性并非通过传统的访问控制修饰符（如Java中的public、private等）来实现，而是通过名称修改（name mangling）的方式。这意味着，当你试图在一个类中定义私有属性或方法时，Python会自动将这些属性或方法的名称进行修改，以防止它们被外部直接访问。</p><p>在提供的示例代码中，我们定义了一个名为<code>CLanguage</code>的类，其中包含了私有属性<code>__name</code>和<code>__add</code>，以及对应的setter和getter方法。此外，还有一个私有方法<code>__display</code>，用于打印这些私有属性的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CLanguage</span> :<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setname</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &lt; <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;名称长度必须大于3！&#x27;</span>)<br>        self.__name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getname</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br>    <span class="hljs-comment"># 为 name 配置 setter 和 getter 方法</span><br>    name = <span class="hljs-built_in">property</span>(getname, setname)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setadd</span>(<span class="hljs-params">self, add</span>):<br>        <span class="hljs-keyword">if</span> add.startswith(<span class="hljs-string">&quot;http://&quot;</span>):<br>            self.__add = add<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;地址必须以 http:// 开头&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getadd</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__add<br><br>    <span class="hljs-comment"># 为 add 配置 setter 和 getter 方法</span><br>    add = <span class="hljs-built_in">property</span>(getadd, setadd)<br><br>    <span class="hljs-comment"># 定义个私有方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__display</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.__name,self.__add)<br></code></pre></td></tr></table></figure><p>当我们尝试直接调用私有方法<code>__display</code>时，Python会抛出一个<code>AttributeError</code>，因为该方法的名称已经被修改，不再是<code>__display</code>。然而，如果我们知道了名称修改的规则，即在属性或方法名前加上<code>_类名__</code>，我们就可以访问到这些私有成员。例如，<code>_CLanguage__display</code>就是<code>__display</code>方法修改后的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">clang = CLanguage()<br><span class="hljs-comment"># 尝试调用私有的 display() 方法</span><br>clang.__display()  <span class="hljs-comment"># 这将引发错误</span><br><br><span class="hljs-comment"># 调用name的setname()方法</span><br>clang.name = <span class="hljs-string">&quot;新宝库&quot;</span><br><span class="hljs-comment"># 调用add的setadd()方法</span><br>clang.add = <span class="hljs-string">&quot;https://www.xinbaoku.com&quot;</span><br><span class="hljs-comment"># 直接调用隐藏的display()方法</span><br>clang._CLanguage__display()  <span class="hljs-comment"># 正确调用</span><br></code></pre></td></tr></table></figure><p>此外，我们还可以访问和修改私有属性<code>__name</code>和<code>__add</code>，尽管这不是推荐的做法，因为它破坏了封装性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">clang = CLanguage()<br>clang.name = <span class="hljs-string">&quot;新宝库&quot;</span><br>clang.add = <span class="hljs-string">&quot;https://www.xinbaoku.com&quot;</span><br><span class="hljs-comment"># 直接调用 name 和 add 私有属性</span><br><span class="hljs-built_in">print</span>(clang._CLanguage__name,clang._CLanguage__add)<br><br><span class="hljs-comment"># 甚至于，我们还可以通过这种方式修改 clang 对象的私有属性</span><br>clang._CLanguage__name = <span class="hljs-string">&quot;Python教程&quot;</span><br>clang._CLanguage__add = <span class="hljs-string">&quot;https://www.xinbaoku.com/python&quot;</span><br><span class="hljs-built_in">print</span>(clang._CLanguage__name,clang._CLanguage__add)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中间件项目大课-自动化云测平台/Spingboot3.X/微服务/Kafka3.x</title>
    <link href="/2024/05/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%AF%BE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x/"/>
    <url>/2024/05/27/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%A1%B9%E7%9B%AE%E5%A4%A7%E8%AF%BE-%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BA%91%E6%B5%8B%E5%B9%B3%E5%8F%B0-Spingboot3-X-%E5%BE%AE%E6%9C%8D%E5%8A%A1-Kafka3-x/</url>
    
    <content type="html"><![CDATA[<p>在当今快速发展的信息技术时代，中间件技术在企业信息化建设中扮演着至关重要的角色。自20世纪80年代以来，随着企业业务需求的不断变化，企业可能需要同时运行多个不同的业务系统，这些系统可能基于不同的操作系统、数据库和异构网络环境。中间件的出现，正是为了解决这些信息系统如何协同工作的问题，实现企业跨平台、分布式应用的目标。</p><h3 id="中间件的定义与作用"><a href="#中间件的定义与作用" class="headerlink" title="中间件的定义与作用"></a>中间件的定义与作用</h3><p>中间件（Middleware）是一种位于操作系统和应用程序之间的软件，有时也被认为是操作系统的一部分。它通过一组集成的中间件构成一个平台，包括开发平台和运行平台。中间件的核心功能是通信，它使得分布式系统中的各个部分能够相互通信。中间件的使用简化了企业应用的复杂性，使得开发人员能够面对一个简单而统一的开发环境，专注于业务逻辑的实现，而不必为程序在不同系统软件上的移植而烦恼。</p><h3 id="中间件的特点"><a href="#中间件的特点" class="headerlink" title="中间件的特点"></a>中间件的特点</h3><p>中间件应具备以下特点：</p><ol><li><strong>满足大量应用的需要</strong>：中间件需要能够支持广泛的应用场景。</li><li><strong>运行于多种硬件和操作系统平台</strong>：中间件应具有跨平台的特性。</li><li><strong>支持分布计算</strong>：提供跨网络、硬件和操作系统平台的透明性应用或服务的交互。</li><li><strong>支持标准的协议和接口</strong>：这是中间件可移植性和互操作性的关键。</li></ol><p>中间件的这些特点使其成为许多标准化工作的主要部分，对于应用软件开发来说，中间件的重要性甚至超过了操作系统和网络服务。中间件提供的程序接口定义了一个相对稳定的高层应用环境，保护了企业在应用软件开发和维护中的投资。</p><h3 id="消息中间件——Kafka机制"><a href="#消息中间件——Kafka机制" class="headerlink" title="消息中间件——Kafka机制"></a>消息中间件——Kafka机制</h3><p><strong>储存模型</strong></p><p>Kafka节点上，一个Partition的每个副本对应一个磁盘目录，新的日志，都是直接append到文件末尾，所以不管文件多大，写入总是O(1)的时间复杂度。但如果文件很大，顺序查找的效率也会很低。kafka通过两种方式解决：分段、索引。</p><p><strong>分段</strong></p><p>比如有100条 Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文 件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段 中。</p><p><strong>索引</strong></p><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的 Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立 了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。</p><p>索引文件中包含若干个索引条目，每个条目表示数据文件中一条Message的索引。索引包含两个部分（均为4个字节的数字），分别为相对offset和position。</p><p>注: index文件中并没有为数据文件中的每条Message建立索引，而是采用了 稀疏存储 的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。但缺点是没有建立索引的 Message也不能一次定位到其在数据文件的位置，从而需要做一次顺序扫描，但是这次顺序扫描的范围就很小了。</p><p><strong>高性能</strong></p><p>顺序读写</p><p>kafka采用的磁盘的顺序读写比无序快了太多，这是由操作系统决定的，即使是普通的机械磁盘，顺序访问速率也接近了内存的随机访问速率。</p><p>即使是顺序读写，过于频繁的大量小IO操作一样会造成磁盘的瓶颈，此时又变成了随机读写。Kafka的策略是把消息集合在一起，批量发送，尽可能减少对磁盘的访问。所以，Kafka的Topic和Partition数量不宜过多，超过64个Topic&#x2F;Partition以后，Kafka性能会急剧下降。</p><p><strong>零拷贝</strong></p><p>Kafka中存在大量的网络数据持久化到磁盘（Producer到Broker）和磁盘文件通过网络发送（Broker到Consumer）的过程。这一过程的性能直接影响Kafka的整体吞吐量。</p><p>Linux 2.4+内核通过sendfile系统调用，提供了零拷贝。数据通过DMA拷贝到内核态Buffer后，直接通过DMA拷贝到NIC Buffer，无需CPU拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件-网络发送由一个sendfile调用完成，整个过程只有两次上下文切换，因此大大提高了性能。</p><p>Kafka的数据传输通过TransportLayer来完成，其子类PlaintextTransportLayer通过Java NIO的FileChannel的transferTo和transferFrom方法实现零拷贝。</p><p><strong>页缓存</strong></p><p>Kafka并不太依赖JVM内存大小，而是主要利用Page Cache，如果使用应用层缓存（JVM堆内存），会增加GC负担，增加停顿时间和延迟，创建对象的开销也会比较高。</p><p>读取操作可以直接在Page Cache上进行，如果消费和生产速度相当，甚至不需要通过物理磁盘直接交换数据，这是Kafka高吞吐量的一个重要原因。</p><p>这么做还有一个优势，如果Kafka重启，JVM内的Cache会失效，Page Cache依然可用。</p><p>代码机制</p><p>kafka-producer.xml</p><pre><code class="hljs">&lt;!--基本配置 --&gt;&lt;bean id=&quot;producerProperties&quot; class=&quot;java.util.HashMap&quot;&gt;    &lt;constructor-arg&gt;        &lt;map&gt;            &lt;!-- kafka服务地址，可能是集群--&gt;            &lt;entry key=&quot;bootstrap.servers&quot; value=&quot;192.168.62.212:9092,192.168.62.213:9092,192.168.62.214:9092&quot;/&gt;            &lt;!-- 有可能导致broker接收到重复的消息,默认值为3--&gt;            &lt;entry key=&quot;retries&quot; value=&quot;10&quot;/&gt;            &lt;!-- 每次批量发送消息的数量--&gt;            &lt;entry key=&quot;batch.size&quot; value=&quot;1638&quot;/&gt;            &lt;!-- 默认0ms，在异步IO线程被触发后（任何一个topic，partition满都可以触发）--&gt;            &lt;entry key=&quot;linger.ms&quot; value=&quot;1&quot;/&gt;            &lt;!--producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常 --&gt;            &lt;entry key=&quot;buffer.memory&quot; value=&quot;33554432 &quot;/&gt;            &lt;!-- producer需要server接收到数据之后发出的确认接收的信号，此项配置就是指procuder需要多少个这样的确认信号--&gt;            &lt;entry key=&quot;acks&quot; value=&quot;all&quot;/&gt;            &lt;entry key=&quot;key.serializer&quot; value=&quot;org.apache.kafka.common.serialization.StringSerializer&quot;/&gt;            &lt;entry key=&quot;value.serializer&quot; value=&quot;org.apache.kafka.common.serialization.StringSerializer&quot;/&gt;        &lt;/map&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 创建kafkatemplate需要使用的producerfactory bean --&gt;&lt;bean id=&quot;producerFactory&quot;      class=&quot;org.springframework.kafka.core.DefaultKafkaProducerFactory&quot;&gt;    &lt;constructor-arg&gt;        &lt;ref bean=&quot;producerProperties&quot;/&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 创建kafkatemplate bean，使用的时候，只需要注入这个bean，即可使用template的send消息方法 --&gt;&lt;bean id=&quot;KafkaTemplate&quot; class=&quot;org.springframework.kafka.core.KafkaTemplate&quot;&gt;    &lt;constructor-arg ref=&quot;producerFactory&quot;/&gt;    &lt;!--设置对应topic--&gt;    &lt;property name=&quot;defaultTopic&quot; value=&quot;bert&quot;/&gt;&lt;/bean&gt;// 测试类@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &quot;classpath:kafka-producer.xml&quot;)public class KafkaTemplateTest &#123;    @Autowired    private KafkaTemplate&lt;Integer, String&gt; kafkaTemplate;    @Test    public void hello()&#123;        kafkaTemplate.sendDefault(&quot;hello world&quot;);    &#125;&#125;</code></pre><p>kafka-consumer.xml</p><pre><code class="hljs">&lt;bean id=&quot;consumerProperties&quot; class=&quot;java.util.HashMap&quot;&gt;        &lt;constructor-arg&gt;            &lt;map&gt;                &lt;!--Kafka服务地址 --&gt;                &lt;entry key=&quot;bootstrap.servers&quot; value=&quot;192.168.62.212:9092,192.168.62.213:9092,192.168.62.214:9092&quot; /&gt;                &lt;!--Consumer的组ID，相同goup.id的consumer属于同一个组。 --&gt;                &lt;entry key=&quot;group.id&quot; value=&quot;bert.mac&quot; /&gt;                &lt;!--如果此值设置为true，consumer会周期性的把当前消费的offset值保存到zookeeper。当consumer失败重启之后将会使用此值作为新开始消费的值。 --&gt;                &lt;entry key=&quot;enable.auto.commit&quot; value=&quot;true&quot; /&gt;                &lt;!--网络请求的socket超时时间。实际超时时间由max.fetch.wait + socket.timeout.ms 确定 --&gt;                &lt;entry key=&quot;session.timeout.ms&quot; value=&quot;15000 &quot; /&gt;                &lt;entry key=&quot;key.deserializer&quot;                    value=&quot;org.apache.kafka.common.serialization.StringDeserializer&quot; /&gt;                &lt;entry key=&quot;value.deserializer&quot;                    value=&quot;org.apache.kafka.common.serialization.StringDeserializer&quot; /&gt;            &lt;/map&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;!--指定具体监听类的bean --&gt;    &lt;bean id=&quot;messageListernerConsumerService&quot; class=&quot;com.ximalaya.queue.KafkaConsumerListener&quot; /&gt;    &lt;!-- 创建consumerFactory bean --&gt;    &lt;bean id=&quot;consumerFactory&quot; class=&quot;org.springframework.kafka.core.DefaultKafkaConsumerFactory&quot;&gt;        &lt;constructor-arg&gt;            &lt;ref bean=&quot;consumerProperties&quot;/&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;containerProperties&quot; class=&quot;org.springframework.kafka.listener.config.ContainerProperties&quot;&gt;        &lt;!-- 要消费的 topic --&gt;        &lt;constructor-arg value=&quot;bert&quot;/&gt;        &lt;property name=&quot;messageListener&quot; ref=&quot;messageListernerConsumerService&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;messageListenerContainer&quot; class=&quot;org.springframework.kafka.listener.KafkaMessageListenerContainer&quot; init-method=&quot;doStart&quot;&gt;        &lt;constructor-arg ref=&quot;consumerFactory&quot;/&gt;        &lt;constructor-arg ref=&quot;containerProperties&quot;/&gt;    &lt;/bean&gt;</code></pre><p>生产者</p><ol><li><p>直接使用KafkaProducer， DefaultKafkaProducerFactory 典型的工厂模式， 封装了kafka producer 配置</p></li><li><p>KafkaTemplate 来了一个 经典的单例模式</p><pre><code class="hljs"> public class KafkaTemplate&lt;K, V&gt; implements KafkaOperations&lt;K, V&gt; &#123;     private final ProducerFactory&lt;K, V&gt; producerFactory;     // volatile 保证多线程的可见性     private volatile Producer&lt;K, V&gt; producer;     private Producer&lt;K, V&gt; getTheProducer() &#123;         if (this.producer == null) &#123;             synchronized (this) &#123;                 // 多重检查                 if (this.producer == null) &#123;                     this.producer = this.producerFactory.createProducer();                 &#125;             &#125;         &#125;         return this.producer;     &#125; &#125;</code></pre></li></ol><p>发送逻辑</p><pre><code class="hljs">public ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; send(String topic, V data) &#123;    ProducerRecord&lt;K, V&gt; producerRecord = new ProducerRecord&lt;&gt;(topic, data);    return doSend(producerRecord);&#125;protected ListenableFuture&lt;SendResult&lt;K, V&gt;&gt; doSend(final ProducerRecord&lt;K, V&gt; producerRecord) &#123;    getTheProducer();    final SettableListenableFuture&lt;SendResult&lt;K, V&gt;&gt; future = new SettableListenableFuture&lt;&gt;();    getTheProducer().send(producerRecord, new Callback() &#123;        public void onCompletion(RecordMetadata metadata, Exception exception) &#123;            if (exception == null) &#123;                future.set(new SendResult&lt;&gt;(producerRecord, metadata));                if (KafkaTemplate.this.producerListener != null                        &amp;&amp; KafkaTemplate.this.producerListener.isInterestedInSuccess()) &#123;                    KafkaTemplate.this.producerListener.onSuccess(producerRecord.topic(),                            producerRecord.partition(), producerRecord.key(), producerRecord.value(), metadata);                &#125;            &#125;else &#123;                future.setException(new KafkaProducerException(producerRecord, &quot;Failed to send&quot;, exception));                if (KafkaTemplate.this.producerListener != null) &#123;                    KafkaTemplate.this.producerListener.onError(producerRecord.topic(),                            producerRecord.partition(), producerRecord.key(), producerRecord.value(), exception);                &#125;            &#125;        &#125;    &#125;);    if (this.autoFlush) &#123;        flush();    &#125;    return future;&#125;</code></pre><ol><li>将KafkaProducer 的send callback 转换为ListenableFuture</li><li>使用 producerListener 将“事件处理”逻辑与发送主流程解耦</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 高级教程系列 - 线程创建</title>
    <link href="/2024/05/20/15_Java%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%20-%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/05/20/15_Java%20%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97%20-%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-创建多线程（Multithreading）"><a href="#Java-创建多线程（Multithreading）" class="headerlink" title="Java 创建多线程（Multithreading）"></a>Java 创建多线程（Multithreading）<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Java-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88Multithreading%EF%BC%89"></a></h1><p>Java 并发编程以多线程（Multithreading）为基础。Java 屏蔽了不同操作系统之间多线程 API 的差异，抽象出一套统一的多线程编程范式，为程序员减轻多线程开发的难度。</p><p>在 Java 中，线程被抽象为了<code>Thread</code>类，一枚<code>Thread</code>类实例即对应一枚操作系统线程（1：1）。Java 线程创建有如下几种方式：</p><ul><li><p>继承<code>Thread</code>类</p></li><li><p>实现<code>Runnable</code>接口</p></li><li><p>实现<code>Callable</code>接口</p></li></ul><h1 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E7%BB%A7%E6%89%BFThread%E7%B1%BB" title="继承Thread类"></a>继承<code>Thread</code>类<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"></a></h1><p>继承<code>Thread</code>类，覆写其<code>run()</code>方法，即可创建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.String;<br><span class="hljs-keyword">import</span> java.lang.Thread;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyThread -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：继承<code>Thread</code>类</p></blockquote><h1 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3" title="实现Runnable接口"></a>实现<code>Runnable</code>接口<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"></a></h1><p>直接继承<code>Thread</code>类创建线程，可能会受限于 Java 仅支持单继承的局限性，不够灵活。实现<code>Runnable</code>接口，实现接口<code>run()</code>方法体，是另一种创建线程的方式。在创建线程时，向<code>Thread</code>类构造函数传递一枚<code>Runnable</code>实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.String;<br><span class="hljs-keyword">import</span> java.lang.Runnable;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        thread.start();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyRunnable -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：实现<code>Runnable</code>接口</p></blockquote><p><code>Runnable</code>接口非常简单，只有一个待实现的抽象<code>run()</code>方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Runnable</code>接口源码</p></blockquote><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3" title="实现Callable接口"></a>实现<code>Callable</code>接口<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"></a></h1><p><code>Callable</code>接口的出现是为了弥补<code>Runnable</code>接口实现多线程无法带回线程任务执行结果（返回值），无法抛出异常的局限。利用<code>Callable</code>、<code>Future</code>、<code>FutureTask</code>等并发组件，我们可以方便地取得多线程任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><span class="hljs-keyword">import</span> java.util.concurrent.RunnableFuture;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>()<br>        );<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        myCallable.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: myCallable result -&gt; &quot;</span> + result);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            System.out.println(<span class="hljs-string">&quot;[INFO]: MyCallable -&gt; &quot;</span> + String.valueOf(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCallable-&quot;</span> + String.valueOf(<span class="hljs-built_in">this</span>.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：实现<code>Callable</code>接口</p></blockquote><p><code>Callable</code>接口是一枚泛型接口，有一个待实现<code>call()</code>方法。如果线程正常退出，方法可带回线程执行结果，如果线程执行出错，则抛出异常。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Callable</code>接口源码</p></blockquote><p><code>Future</code>接口是一枚泛型接口，提供了<code>Callable</code>线程任务的一些调用方法，如：获取计算结果、取消线程任务、判断任务是否完成…</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Future</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">cancel</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> mayInterruptIfRunning)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Future</code>接口源码</p></blockquote><h1 id="Thread类源码观察"><a href="#Thread类源码观察" class="headerlink" title="Thread类源码观察"></a><a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%82%E5%AF%9F" title="Thread类源码观察"></a><code>Thread</code>类源码观察<a href="https://zihengcat.github.io/2019/07/14/java-tutorial-for-language-adavanced-create-thread/#Thread%E7%B1%BB%E6%BA%90%E7%A0%81%E8%A7%82%E5%AF%9F"></a></h1><p>我们观察<code>Thread</code>类源码，可以看到，在<code>Thread</code>类构造函数中，<code>Runnable</code>实例会被传递至内部<code>target</code>中，并在线程中实际调用<code>target.run()</code>。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">...<br>    <span class="hljs-comment">/* What will be run. */</span><br>    <span class="hljs-keyword">private</span> Runnable <span class="hljs-keyword">target</span>;<br>...<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Initializes a Thread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> g the Thread group</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target the object whose run() method gets called</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name the name of the new Thread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> stackSize the desired stack size for the new thread, or</span><br><span class="hljs-comment">     *        zero to indicate that this parameter is to be ignored.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> acc the AccessControlContext to inherit, or</span><br><span class="hljs-comment">     *            AccessController.getContext() if null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inheritThreadLocals if &#123;<span class="hljs-doctag">@code</span> true&#125;, inherit initial values for</span><br><span class="hljs-comment">     *            inheritable thread-locals from the constructing thread</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadGroup g, Runnable <span class="hljs-keyword">target</span>, String name,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>...<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * If this thread was constructed using a separate</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> Runnable&#125; run object, then that</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> Runnable&#125; object&#x27;s &#123;<span class="hljs-doctag">@code</span> run&#125; method is called;</span><br><span class="hljs-comment">     * otherwise, this method does nothing and returns.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Subclasses of &#123;<span class="hljs-doctag">@code</span> Thread&#125; should override this method.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #start()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #stop()</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">target</span>.run();<br>        &#125;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><blockquote><p>代码清单：<code>Thread</code>类部分源码</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Vite 搭建 React18 + TS 的开发模板</title>
    <link href="/2022/05/25/14_%E6%90%AD%E5%BB%BA%20Vite%20+%20React%2018%20+%20TS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/05/25/14_%E6%90%AD%E5%BB%BA%20Vite%20+%20React%2018%20+%20TS%20%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>Vite + React 18 + TS，集成 ESLint 和 Prettier ，开箱即用，无需再从零开始配置。便于统一团队代码风格及规范。</p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>为了尽量减少手动配置，本项目的搭建将尽可能使用已有工具。</p></blockquote><p>每次想建一个项目，都需要从零开始配置？<code>ESLint</code> 和 <code>Prettie</code> 的冲突让人难受？</p><p>使用 <code>Create-React-App</code> 确实能节省一部分配置时间，但是为了有更好的开发体验，感受更快的热更新及打包速度，本次选用了 <a href="https://cn.vitejs.dev/">Vite</a>。</p><h2 id="搭建基础模板"><a href="#搭建基础模板" class="headerlink" title="搭建基础模板"></a>搭建基础模板</h2><h2 id="集成-ESLint-和-Prettier"><a href="#集成-ESLint-和-Prettier" class="headerlink" title="集成 ESLint 和 Prettier"></a>集成 ESLint 和 Prettier</h2><h3 id="各个包的作用"><a href="#各个包的作用" class="headerlink" title="各个包的作用"></a>各个包的作用</h3>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>效率</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code-Challenges: 4-Technical-Books</title>
    <link href="/2021/08/05/13-Code-Challenges-4-Technical-Books/"/>
    <url>/2021/08/05/13-Code-Challenges-4-Technical-Books/</url>
    
    <content type="html"><![CDATA[<p>领英课程： <code>JavaScript Code Challenges</code> 系列：EP4- <a href="https://www.linkedin.com/learning/javascript-code-challenges/technical-books">Technical Books</a></p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>题目只作简要描述，具体题目请点击上方👆🏻标题跳转。</p></blockquote><p>继承 挑战1（<a href="/2021/07/15/12_Code-Challenges-1-Available-Books/" title="Code Challenges: 1-Available Books">Code Challenges: 1-Available Books</a>）中的 <code>Book</code> 类，并新增一个 <code>edition</code> 属性，使用 <code>getEdition()</code> 方法获取当前版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 挑战1中的 Book 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">availability</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAvailability</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">getAvailability</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Out of stock&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt; <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`Low stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`In stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sell</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;No stock&#x27;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> -= numSold;<br>  &#125;<br><br>  <span class="hljs-title function_">restock</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> += numCopiesStocked;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TechnicalBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies, edition</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(title, author, <span class="hljs-variable constant_">ISBN</span>, numCopies);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> = edition;<br>  &#125;<br><br>  <span class="hljs-title function_">getEdition</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`The current version of this book is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.edition&#125;</span>.`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myTechnicalBook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TechnicalBook</span>(<br>  <span class="hljs-string">&#x27;......&#x27;</span>, <span class="hljs-comment">// 继承原属性</span><br>  <span class="hljs-string">&#x27;2.0&#x27;</span>, <span class="hljs-comment">// edition</span><br>);<br><br>myTechnicalBook.<span class="hljs-title function_">getEdition</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
      <tag>JS Code Challenges</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code Challenges: 1-Available Books</title>
    <link href="/2021/07/15/12_Code-Challenges-1-Available-Books/"/>
    <url>/2021/07/15/12_Code-Challenges-1-Available-Books/</url>
    
    <content type="html"><![CDATA[<p>领英课程： <code>JavaScript Code Challenges</code> 系列：EP1- <a href="https://www.linkedin.com/learning/javascript-code-challenges/available-books">Available Books</a></p><span id="more"></span><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>题目只作简要描述，具体题目请点击上方👆🏻标题跳转。</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>title, author, ISBN, numCopies</code></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>getAvailability()</code>：根据书本的库存返回对应提示</p><p><code>sell(numSold)</code>：售出指定数量书本，若无传递参数，则为默认为1</p><p><code>restock(numCopies)</code>：入库数量，若无传递参数，则为默认为5</p><h3 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h3><ol><li>使用类</li><li>使用 getter 方法</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">availability</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getAvailability</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">getAvailability</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Out of stock&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt; <span class="hljs-number">10</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">`Low stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`In stock: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.numCopies&#125;</span>`</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">sell</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;No stock&#x27;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> -= numSold;<br>  &#125;<br><br>  <span class="hljs-title function_">restock</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> += numCopiesStocked;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Book</span>(<span class="hljs-params">title, author, ISBN, numCopies</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">author</span> = author;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ISBN</span> = <span class="hljs-variable constant_">ISBN</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">numCopies</span> = numCopies;<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sell</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">numSold = <span class="hljs-number">1</span></span>) &#123;<br>  ...<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">restock</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">numCopiesStocked = <span class="hljs-number">5</span></span>) &#123;<br>  ...<br>&#125;<br><br><span class="hljs-title class_">Book</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAvailability</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
      <tag>JS Code Challenges</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个sleep函数</title>
    <link href="/2021/05/25/11_%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/"/>
    <url>/2021/05/25/11_%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsleep%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>从ES5、ES6+的角度实现一个sleep函数。</p><span id="more"></span><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6+"></a>ES6+</h2><p>主要方式包括：Promise（常用）、Async&#x2F;Await（常用）、Generator（较少使用）。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = time =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br><br><span class="hljs-comment">// 1秒后，打印‘Promise’</span><br><span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sleep</span> = time =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">output</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Async/Await---Start&#x27;</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Async/Await---End&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 先直接打印 Async/Await---Start，1秒后打印 Async/Await---End</span><br><span class="hljs-title function_">output</span>(); <br></code></pre></td></tr></table></figure><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">sleepGenerator</span>(<span class="hljs-params">time</span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<br>&#125;<br><br><span class="hljs-comment">// 1秒后，打印‘Generator’</span><br><span class="hljs-title function_">sleepGenerator</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Generator&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><p>ES5主要通过setTimeout回调函数的方式实现。</p><h3 id="使用回调"><a href="#使用回调" class="headerlink" title="使用回调"></a>使用回调</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">callback, time</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(callback, time);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;回调函数错误&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">output</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;回调&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 1秒后，打印‘回调’</span><br><span class="hljs-title function_">sleep</span>(output, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期跳槽面试记录</title>
    <link href="/2021/05/13/10_%E8%BF%91%E6%9C%9F%E8%B7%B3%E6%A7%BD%E9%9D%A2%E8%AF%95%E6%9C%89%E6%84%9F/"/>
    <url>/2021/05/13/10_%E8%BF%91%E6%9C%9F%E8%B7%B3%E6%A7%BD%E9%9D%A2%E8%AF%95%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>最近一两周在投简历面试，面了3家不同风格的公司：腾讯、外企、创业公司。简单谈下整体感受，做个记录📝</p><span id="more"></span><h2 id="跳槽原因"><a href="#跳槽原因" class="headerlink" title="跳槽原因"></a>跳槽原因</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>其实我在现公司工作的时间不长，也就八个月。</p><p>当初毕业后选择现公司的一个很大原因就是面试流程非常规范、感觉公司前景很好。</p><p>当初面试面了5轮，公司用的技术栈是React，但我只接触过Vue。经过面试，公司愿意给我机会。还记得在CTO面时，CTO表示公司不怎么招应届生，只招有经验的工程师，因为公司节奏快，需要的是能够快速上手干活的人，希望我做好准备。</p><p>入职后，果不其然，公司节奏非常快。在我入职的第二天，导师就要求我上手写项目，于是我就开始了一边看React官网一边写项目的奇妙经历。</p><p>同时，也认识到了自己的知识在“学到”和“实践”之间有较大差距，很多知识自己是知道，但是没能很好地应用起来，于是就开启了白天工作、晚上回家继续学习的生活。</p><p>后来，在走过各种曲折的路后，感觉自己回到正轨了，各种业务也能够比较从容地应对。</p><h3 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h3><p>由于公司经营的不是很好，员工们的待遇也跟不上了，发生了较大规模的离职潮。二十多人前端组来说，几个月时间，走了近一半人。</p><p>而我所在业务线，也多人离职，前端只剩我一个，我一个刚毕业没几个月的菜鸡，竟然得扛这个业务线的前端大旗。也是在这段时间，我从0到1独立开发了多个的功能模块。期间，我感觉压力也非常大，当然也成长了非常多，例如我开始更多地考虑项目的代码质量及风格、项目的可扩展性、组件复用、性能等多方面。非常幸运的是，我扛过来了。</p><h3 id="爆发"><a href="#爆发" class="headerlink" title="爆发"></a>爆发</h3><p>而真正让我萌生离职想法的，是接手某个屎山项目以后，似乎多个存在已久的问题都同时冒头了。</p><p>我接手的屎山项目，有非常多的自爆式写法，完全是为了跑路不顾一切写出来的代码，甚至出现“这么做我也没办法”的注释，完美诠释“高耦合低内聚”，导致牵一发动全身，后续迭代举步维艰。于是我主动跟业务线领导反映了这个情况，但他并没有放在心上，反而表达了一种是我经验不足之类的意思。我感受到了失望。</p><p>由于原来写这些代码的人都跑路了，这座屎山落到我头上，压得我喘不过气。明明是一些非常简单的功能，却受制于原代码而难以实现。曾想过重构重写，但前端哪里还够人手呢？反馈又得不到有效回应，于是每天早上醒来不想去上班，出现了 <a href="https://baike.baidu.com/item/%E8%81%8C%E4%B8%9A%E5%80%A6%E6%80%A0/8254445?fr=aladdin">burnout</a> 的症状。</p><p>由于离职的人多了，导致人手不够，导致手上的工作越来越多，而开发时间却越压越短。多次出现评估开发时间后被砍时间的情况。</p><p>再加上后来业务线领导说，怕我们工作不饱和，所以周报要多写字，在给我看了一篇上千字的模范作文周报后，我也觉得是时候说再见了。</p><p>跳过这个沉重的话题，开启新篇章~~😎</p><hr><h2 id="面试时间线"><a href="#面试时间线" class="headerlink" title="面试时间线"></a>面试时间线</h2><table><thead><tr><th>时间</th><th>进度</th></tr></thead><tbody><tr><td>4月30号早上</td><td>外企HR英语面</td></tr><tr><td>4月30号下午</td><td>创业公司技术面 + HR面</td></tr><tr><td>五一假期</td><td>旅行🚄、学习📖</td></tr><tr><td>5月6号</td><td>腾讯技术面</td></tr><tr><td>5月8号</td><td>外企技术面</td></tr><tr><td>5月11号早上</td><td>外企manager面</td></tr><tr><td>5月11号下午</td><td>创业公司CTO面</td></tr><tr><td>5月11号晚上</td><td>创业公司CEO面</td></tr><tr><td>5月12号</td><td>外企Offer、创业公司Offer</td></tr></tbody></table><h2 id="腾讯（凉）"><a href="#腾讯（凉）" class="headerlink" title="腾讯（凉）"></a>腾讯（凉）</h2><p>问题几乎都在围绕原理、源码，挺有深度。</p><p>估计面试官的内心是这样的👇🏻</p><p><img src="/images/stickers/shutUp.jpg" alt="就这水平你还敢来面试?"></p><p>面试官挺冷酷的，我也凉的透透的😂</p><hr><h2 id="外企（Offer）"><a href="#外企（Offer）" class="headerlink" title="外企（Offer）"></a>外企（Offer）</h2><p>面试体验直接打满分💯！</p><p>我是先在Boss直聘上投的简历。投递后，HR会先简单了解你的英文水平、是否能够全英面试、是否接受做coding task等，我 <del>瑟瑟发抖</del> 信心满满地表示：可以。😎</p><h3 id="一面：HR面（4月30号）"><a href="#一面：HR面（4月30号）" class="headerlink" title="一面：HR面（4月30号）"></a>一面：HR面（4月30号）</h3><p>HR会简单考察下我的英文水平，让我用英文做个自我介绍、再进行一些问题的问答等。</p><p>由于这是本次跳槽的第一场面试，我感觉自己说的磕磕绊绊，一度以为自己凉了😭。不过幸好通过了，然后HR就发了coding task，并提醒做好英文简历一并提交。</p><p>coding task比较简单，应该主要是考察代码风格吧。最难的是写英文简历，写的头疼😂。</p><h3 id="二面：技术面（5月8号）"><a href="#二面：技术面（5月8号）" class="headerlink" title="二面：技术面（5月8号）"></a>二面：技术面（5月8号）</h3><p>先自我介绍。</p><p>然后在线coding，一道考察位运算的算法题。题目要求线性复杂度、并且不能用额外空间，而我写的是O(n²)复杂度所以我并没有满足需求。后来面试官还问了几种排序，讲插入排序的思想。</p><p>然后从数据结构、网络、前端基础、React、Git、敏捷开发等都问了一遍，考察范围非常广，总历时1.5小时。</p><h3 id="三面：manager面（5月11号）"><a href="#三面：manager面（5月11号）" class="headerlink" title="三面：manager面（5月11号）"></a>三面：manager面（5月11号）</h3><p>自我介绍，然后聊天。</p><p>manager非常会鼓励人，循循善诱。最后问我期望薪资，我说了个范围X-Y，然后manager直接给我开了Y，非常惊喜🤩。</p><h3 id="Offer-Call（5月11号）"><a href="#Offer-Call（5月11号）" class="headerlink" title="Offer Call（5月11号）"></a>Offer Call（5月11号）</h3><p>讲了薪资福利、背调事项等，确定入职时间。</p><hr><h2 id="创业公司（Offer）"><a href="#创业公司（Offer）" class="headerlink" title="创业公司（Offer）"></a>创业公司（Offer）</h2><p>公司融资融了几个亿，发展应该是比较迅速的，前端所用技术栈是Typescript + React。</p><h3 id="一面：技术面-hr面（4月30号）"><a href="#一面：技术面-hr面（4月30号）" class="headerlink" title="一面：技术面 + hr面（4月30号）"></a>一面：技术面 + hr面（4月30号）</h3><p>一上来直接考察非常高级高端的技术问题、猝不及防😂。后面回到常规问题。最后面试官把电脑推过来，让我完成一道算法题，完成后，到了HR面。</p><p>HR面主要介绍公司情况、聊以往薪资、问期望薪资等。</p><h3 id="二面：CTO面（5月11号下午）"><a href="#二面：CTO面（5月11号下午）" class="headerlink" title="二面：CTO面（5月11号下午）"></a>二面：CTO面（5月11号下午）</h3><p>CTO是个超级大佬，但不会让人觉的不可靠近，反而非常nice🤩。或许这就是大佬吧。</p><p>主要内容就是在线coding，给定一个需要实现的功能，用React实现，之前技术面编程是有IDE的，这次是用空白文本编程，CTO还打趣说他就是这样过来的哈哈哈。</p><p>花了不少时间在格式调整上😄，然后代码写完，CTO表示可以，便问了期望薪资。</p><h3 id="三面CEO面（5月11号晚上）"><a href="#三面CEO面（5月11号晚上）" class="headerlink" title="三面CEO面（5月11号晚上）"></a>三面CEO面（5月11号晚上）</h3><p>得益于HR小姐姐的快速推进，刚面完CTO面就联系我，问我今晚是否有空进行终面，虽然很累（一天3场面试😭），但是抵不住HR小姐姐的热情，便答应了。</p><p>终面主要考察职业规划、思考之类的。</p><h3 id="Offer-Call（5月12号）"><a href="#Offer-Call（5月12号）" class="headerlink" title="Offer Call（5月12号）"></a>Offer Call（5月12号）</h3><p>HR小姐姐非常热情，开门见山直接开了一个非常有竞争力的薪资😱，非常惊喜，并表示非常希望我能加入公司。同时得知我打算接外企Offer后，晓之以理，动之以情地劝了我挺久🥺。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我最终接了外企Offer，一是整个面试流程体验非常棒。其次，薪资及各方面福利也是非常满意。还有就是外企很人性化的制度吸引了我。</p><p>所以后面的面试也推掉啦~准备入职外企❤️🥰🤩</p><p>本次面试之旅就告一段落了，这次的时间跨度其实也就一周多的时间，没想到会这么快结束战斗，感觉还是挺意外的。</p><p>最后，希望下个月顺利入职外企~~😄</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用栈实现队列</title>
    <link href="/2021/04/29/09_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2021/04/29/09_%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>LeetCode 232 用栈实现队列 (JavaScript版😎)</p><span id="more"></span><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。</p><p>pop() – 从队列首部移除元素。</p><p>peek() – 返回队列首部的元素。</p><p>iSEmpty() – 返回队列是否为空。</p></blockquote><p>说明：</p><p>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-title function_">push</span>(<span class="hljs-number">2</span>);<br>queue.<span class="hljs-title function_">peek</span>(); <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-title function_">empty</span>(); <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></table></figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyQueue</span>(<span class="hljs-params">contents = []</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [...contents];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span> = [];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将元素 x 推入队列。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">number</span>&#125; <span class="hljs-variable">x</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">void</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将队头元素推出，并返回该值。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">pop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> res;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>();<br><br>  <span class="hljs-comment">// 由于上面的 stack 已经全部 pop 出到 tempStack,</span><br>  <span class="hljs-comment">// 所以，需要在拿到目标值 res 后，将所有值重新推入 stack。</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>());<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取队头元素。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">peek</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断列队是否为空。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">boolean</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isEmpty</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取队列长度。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type">number</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">MyQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">size</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 class 实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">contents = []</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [...contents];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(x);<br>  &#125;<br>  <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> res;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    res = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tempStack</span>.<span class="hljs-title function_">pop</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>  <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/images/algorithms/leetcode-232-result.png" alt="结果测试"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown实用技巧</title>
    <link href="/2021/04/24/08_Markdown%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/04/24/08_Markdown%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>早有耳闻<strong>Markdown</strong>，然而我一直没什么机会真正的接触它。但自开始写博博客以来，我便和它形影不离，才感叹：相见恨晚！🤩</p><span id="more"></span><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在没开始写博客之前，我更习惯在云笔记上写些想法、心得或随想。相较博客而言，在自己的笔记里可以放飞自我，不用在意格式，也不用在意排版，感觉只要只要记下了最核心的“内容”，便足矣。😂</p><p>那既然要写博客，可不能写的这么放飞自我，否则读者的表情…👇</p><p><img src="/images/stickers/WTF.jpeg" alt="这写的是啥"></p><p>于是，我“被迫”有了真正使用 Markdown 的机会。😎</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>下面简要介绍下基本语法~</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>一个#是一级标题，二个#是二级标题，以此类推。共支持六级标题。</p><p>注：#后要跟个空格再写文字哦🥺</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="加粗（本羊用的最多🤩）"><a href="#加粗（本羊用的最多🤩）" class="headerlink" title="加粗（本羊用的最多🤩）"></a>加粗（本羊用的最多🤩）</h4><p>文字左右分别用两个*号包起来</p><p>效果：<strong>我加粗了</strong></p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>文字左右分别用一个*号包起来</p><p>效果：<em>我歪了</em></p><h4 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h4><p>文字左右分别用三个*号包起来</p><p>效果：<em><strong>我又粗又斜</strong></em></p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>文字左右分别用两个~~号包起来</p><p>效果：<del>懒惰（bushi）</del> 科技，是第一生产力！👏</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>例如本文开头关于 Markdown 的描述，就是用的引用（不知道为啥我觉得这个很酷😎）</p><p>使用方法：<code>&gt;</code> 接引用。&gt;可以无限嵌套哦。效果如下：</p><blockquote><p>为何我的眼里常含泪水，因为我对前端爱得深沉。——羊本羊</p></blockquote><h3 id="本文-Markdown-展示"><a href="#本文-Markdown-展示" class="headerlink" title="本文 Markdown 展示"></a>本文 Markdown 展示</h3><h3 id="分隔线（还没用到过🥲）"><a href="#分隔线（还没用到过🥲）" class="headerlink" title="分隔线（还没用到过🥲）"></a>分隔线（还没用到过🥲）</h3><p>连续三个或以上的 - 或 *</p><hr><p>效果：👆</p><h3 id="图片（我的最爱！😍）"><a href="#图片（我的最爱！😍）" class="headerlink" title="图片（我的最爱！😍）"></a>图片（我的最爱！😍）</h3><p>写博客当然得加上图片，理由如下：</p><ol><li>补充说明</li><li>增加文章丰富性</li><li>我想用表情包！🤩</li></ol><p><code>![alt属性文本](图片地址 &#39;可选标题&#39;)</code></p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。效果：</p><p><img src="/images/stickers/what.png" alt="啥？"></p><h3 id="超链接（常用😘）"><a href="#超链接（常用😘）" class="headerlink" title="超链接（常用😘）"></a>超链接（常用😘）</h3><p><code>[超链接名](超链接地址 &quot;可选超链接title&quot;)</code></p><blockquote><p>tips: hexo中需变量：<code>&#123;% post_link 效率神器——Alfred %&#125;</code></p></blockquote><p>效果：</p><a href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/" title="效率神器——Alfred">效率神器——Alfred</a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p><code>- + *</code> 均可</p><p>如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 小明<br><span class="hljs-bullet">-</span> 小美<br><span class="hljs-bullet">-</span> 小羊<br></code></pre></td></tr></table></figure><p>效果：</p><ul><li>小明</li><li>小美</li><li>小羊</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 小明<br><span class="hljs-bullet">2.</span> 小美<br><span class="hljs-bullet">3.</span> 小羊<br></code></pre></td></tr></table></figure><p>效果：</p><ol><li>小明</li><li>小美</li><li>小羊</li></ol><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>在上一级与下一级间以3个空格作为开头即可，效果：</p><ol><li>小明<ol><li>明之子</li><li>明之女</li></ol></li><li>小美<ol><li>美之子</li><li>美之女</li></ol></li><li>小羊<ol><li>羊之子</li><li>羊之女</li></ol></li></ol><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</code>，用法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">|  表头   | 表头  |<br>|  ----  | ----  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |<br></code></pre></td></tr></table></figure><p>设置表格的对齐方式：</p><ol><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ol><p>以 <a href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Oh-My-Zsh中Git的常用快捷键">Oh-My-Zsh中Git的常用快捷键</a> 这篇文章用到的为例，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">快捷键|完整写法<br>|:-|:-|<br>g|git<br>gaa|git add .<br>gcmsg|git commit -m<br>gcb|git checkout -b<br>gst|git status<br>gf|git fetch<br>gl|git pull<br>gup|git pull --rebase<br>grb|git rebase<br>gsta|git stash save<br>gstp|git stash pop<br>gcp|git cherry-pick<br>mg|git merge<br>gp|git push<br></code></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th align="left">快捷键</th><th align="left">完整写法</th></tr></thead><tbody><tr><td align="left">g</td><td align="left">git</td></tr><tr><td align="left">gaa</td><td align="left">git add .</td></tr><tr><td align="left">gcmsg</td><td align="left">git commit -m</td></tr><tr><td align="left">gcb</td><td align="left">git checkout -b</td></tr><tr><td align="left">gst</td><td align="left">git status</td></tr><tr><td align="left">gf</td><td align="left">git fetch</td></tr><tr><td align="left">gl</td><td align="left">git pull</td></tr><tr><td align="left">gup</td><td align="left">git pull –rebase</td></tr><tr><td align="left">grb</td><td align="left">git rebase</td></tr><tr><td align="left">gsta</td><td align="left">git stash save</td></tr><tr><td align="left">gstp</td><td align="left">git stash pop</td></tr><tr><td align="left">gcp</td><td align="left">git cherry-pick</td></tr><tr><td align="left">mg</td><td align="left">git merge</td></tr><tr><td align="left">gp</td><td align="left">git push</td></tr></tbody></table><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">`单行代码`</span><br></code></pre></td></tr></table></figure><h4 id="代码块（用的很多😘）"><a href="#代码块（用的很多😘）" class="headerlink" title="代码块（用的很多😘）"></a>代码块（用的很多😘）</h4><p>用法如图：</p><p><img src="/images/markdown-block.png" alt="代码块"></p><blockquote><p>tips: &#96;&#96;&#96;后跟js代表当前是JavaScript的代码块，方便高亮。</p></blockquote><p>效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Demo&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，平常用的 Markdown 语法主要是以上介绍的这些，已经足够应付日常的写作~</p><p>如果以后有用到其他的语法，我会继续补充本文章滴~😎</p><p>对了，补充一个 VS Code 插件 <code>Markdown All in One</code>， 可以实时预览~</p><p><img src="/images/markdown-profile.png" alt="Markdown All in One 插件实时预览"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率神器——Alfred</title>
    <link href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/"/>
    <url>/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如Alfred官方所述：Alfred是一款屡获殊荣的macOS应用程序，可通过热键，关键字，文本扩展等功能提高您的效率。搜索Mac和网页的内容，并通过自定义操作来控制Mac来提高生产力。😍</p></blockquote><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Alfred与Mac自带的“聚焦”有何区别呢？简单来说，Alfred就是一个更强大的“聚焦”。</p><p>本文将介绍本羊自己用的比较多的功能，如粘贴板、终端、搜索文件、搜索文件内部内容等。</p><p>直接按下 <code>⌥ + 空格</code> 唤出 Alfred，基本操作就不多介绍了，直接开始！！</p><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><ol><li><p>剪贴板（强烈推荐！！🤩）</p><p>电脑换成MacBook以后，我发现macOS上竟然没有那个极其方便的功能 —— <strong>剪切板😱</strong>！！</p><p>在Windows系统上，可以一次性复制多个项，然后只需按下 <code>Win + V</code> 唤出剪切板，即可方便快捷地进行批量粘贴操作。</p><p>而macOS没有该功能！！😩 作为一名 <del>Ctrl CV工程师</del> 需要经常用到该功能的程序员，当然不可接受。而Alfred，让你不用额外安装剪切板软件，即可实现该功能。🤩</p><p>使用方法：<code>⌥ + ⌘ + C</code></p><p><img src="/images/alfred/clipboard.png" alt="剪切板"></p><p>支持文本、图片~</p></li><li><p>搜索</p><ol><li><p>浏览器搜索（支持检索浏览器历史记录、书签、搜索引擎）</p><p><img src="/images/alfred/browser-search.png" alt="浏览器搜索"></p></li><li><p>本地搜索（文件搜索、文件内部内容搜索）</p><p>文件搜索： <code>&#39;</code>（或者在设置里直接设置成空格），接内容即可检索文件。</p><p><img src="/images/alfred/file-search.png" alt="文件搜索"></p><p>文件内部内容搜索： <code>in</code> 接内容即可检索文件。例如，我这篇文章的摘要包含了“<strong>屡获殊荣</strong>”四个字，因此本文件也被检索到了🤩</p><p><img src="/images/alfred/in-search.png" alt="文件内容搜索"></p></li><li><p>其他自定义搜索（如在指定网站搜索，例如YouTube、MDN、StackOverflow）</p><p><img src="/images/alfred/YouTube-search.png" alt="油管搜索李子柒🤩"></p></li></ol></li><li><p>自定义文本片（Snippet）</p><p>需要经常输入指定内容？太长不想手打？<strong>自定义文本片</strong> 了解一下😎。</p><p><img src="/images/alfred/snp-setting.png" alt="用法非常简单"></p><p>用法：<code>snip 关键词</code> ，输入关键字后，会自动弹出自定义内容。日常用法：每次写东西前习惯标个今天日期，可以自定义 <code>&#123;date&#125;</code> 即可代表今天。使用时，只需 <code>snip today</code> 然后回车，自动生成2021-04-22🤩</p><p><img src="/images/alfred/snp-id.png" alt="身份证太长不想输咋办"></p></li><li><p>直接输入终端命令</p><p>不想每次打开终端再输入命令执行咋办？直接 <code>&gt;命令</code> 了解一下🤩</p><p><img src="/images/alfred/alfred-terminal.png" alt="直接执行命令"></p><p><img src="/images/alfred/terminal-date.png" alt="效果"></p><p>注意，Alfred默认使用默认终端，若想使用 <code>iterm</code> ，可以在Alfred里选Terminal-“自定义”，配置如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs AppleScript"><span class="hljs-keyword">on</span> alfred_script(q)<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;iTerm2&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">application</span> <span class="hljs-string">&quot;iTerm&quot;</span> <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">run script</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">      on run &#123;q&#125;</span><br><span class="hljs-string">        tell application \&quot;iTerm\&quot;</span><br><span class="hljs-string">          activate</span><br><span class="hljs-string">          try</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">            set onlywindow to true</span><br><span class="hljs-string">          on error</span><br><span class="hljs-string">            create window with default profile</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">            set onlywindow to true</span><br><span class="hljs-string">          end try</span><br><span class="hljs-string">          tell the first window</span><br><span class="hljs-string">            if onlywindow is false then</span><br><span class="hljs-string">              create tab with default profile</span><br><span class="hljs-string">            end if</span><br><span class="hljs-string">            tell current session to write text q</span><br><span class="hljs-string">          end tell</span><br><span class="hljs-string">        end tell</span><br><span class="hljs-string">      end run</span><br><span class="hljs-string">    &quot;</span> <span class="hljs-keyword">with</span> parameters &#123;q&#125;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">run script</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">      on run &#123;q&#125;</span><br><span class="hljs-string">        tell application \&quot;iTerm\&quot;</span><br><span class="hljs-string">          activate</span><br><span class="hljs-string">          try</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">          on error</span><br><span class="hljs-string">            create window with default profile</span><br><span class="hljs-string">            select first window</span><br><span class="hljs-string">          end try</span><br><span class="hljs-string">          tell the first window</span><br><span class="hljs-string">            tell current session to write text q</span><br><span class="hljs-string">          end tell</span><br><span class="hljs-string">        end tell</span><br><span class="hljs-string">      end run</span><br><span class="hljs-string">    &quot;</span> <span class="hljs-keyword">with</span> parameters &#123;q&#125;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><br><span class="hljs-keyword">end</span> alfred_script<br></code></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多其他常用功能及强大的Workflow日后继续补充，更多使用方法可参考 <a href="https://www.alfredapp.com/">Alfred官方</a>~😎</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>效率</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法-JavaScript实现</title>
    <link href="/2021/04/10/06_%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/04/10/06_%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-JavaScript%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>前几天偶尔看到了一些排序算法的动态图，觉得非常生动且有助于理解。而自己也有一段时间没接触过各种算法了，因此决定整理一下，将他们拾起来 📝</p><span id="more"></span><h3 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h3><ol><li><p>稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p></li><li><p>非稳定排序：如果 a 原本在 b 的前面，且 a &#x3D;&#x3D; b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</p></li><li><p>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p></li><li><p>非原地排序：需要利用额外的数组来辅助排序。</p></li><li><p>时间复杂度：一个算法执行所消耗的时间。</p></li><li><p>空间复杂度：运行完一个算法所需的内存大小。</p></li></ol><p><img src="/images/algorithms/sort-table.jpg" alt="对比图"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>每次比较如果发现较小的元素在后面，就交换两个相邻的元素</p><p>每轮循环比较后，该轮最后一个值就是该轮最大的值（即大的沉底，小的浮起）</p></blockquote><p><img src="/images/algorithms/bubble.gif" alt="冒泡排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; array.<span class="hljs-property">length</span> - i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// 每轮都会排好一个</span><br>      <span class="hljs-keyword">if</span> (array[j] &gt; array[j + <span class="hljs-number">1</span>]) &#123;<br>        [array[j], array[j + <span class="hljs-number">1</span>]] = [array[j + <span class="hljs-number">1</span>], array[j]];<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>选择排序是冒泡排序的改进。</p><p>选择排序先并不急于调换位置，而是每轮看哪个数最小就记下该数所在的位置minIndex，等该轮扫描完毕，再让最小值和当前指定值对换，这样一来每一轮比较都只需要换一次位置。</p><p>缺点：不是稳定排序。</p></blockquote><p><img src="/images/algorithms/select.gif" alt="选择排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> minIndex;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    minIndex = i; <span class="hljs-comment">// 假设本轮的第一个值为最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; array.<span class="hljs-property">length</span>; j++) &#123; <span class="hljs-comment">// 默认第一个已排好</span><br>      <span class="hljs-keyword">if</span> (array[j] &lt; array[minIndex]) &#123;<br>        minIndex = j<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i !== minIndex) &#123;  <span class="hljs-comment">//如果该最小值和原最小值不同，则交换其值</span><br>      [array[i], array[minIndex]] = [array[minIndex], array[i]];<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>重点：部分有序。将无序部分和有序部分进行比较，然后插入对应位置。</p><p>首先要实现局部有序：直接把第一个元素看成有序。</p><p>数据规模越小、数据有序程度越高，越高效（移动少）</p></blockquote><p><img src="/images/algorithms/insert.gif" alt="插入排序"></p><p>代码实现：</p><p>方法1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort1</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    temp = array[i]; <span class="hljs-comment">// 每轮取出当前值，避免被覆盖。</span><br>    <span class="hljs-keyword">let</span> j = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>  &amp;&amp; array[j] &gt; temp) &#123;<br>      array[j + <span class="hljs-number">1</span>] = array[j];<br>      j--;<br>    &#125;<br>    array[j + <span class="hljs-number">1</span>] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort2</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> temp, i, j;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>    temp = array[i];<br>    <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (array[j] &gt; temp) &#123;<br>        array[j + <span class="hljs-number">1</span>] = array[j];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 务必跳出该轮循环，避免往下执行</span><br>      &#125;<br>    &#125;<br>    array[j + <span class="hljs-number">1</span>] = temp;<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>希尔排序是插入排序的改进。</p><p>当数据规模较大时或有序程度不高时，插入排序的元素移动次数较多，插入效率不高。为了解决这个问题，希尔排序出现了。</p><p>希尔排序把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高。</p></blockquote><p><strong>实现过程</strong>：先让数组中任意间隔为 gap 的元素有序，刚开始 gap 的大小可以是 gap &#x3D; n &#x2F; 2，接着让 gap &#x3D; n &#x2F; 4，让 gap 一直缩小，当 gap &#x3D; 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p><img src="/images/algorithms/Shell.gif" alt="希尔排序"></p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shellSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> len = array.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">let</span> gap = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len / <span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">let</span> temp;<br>  <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//gap不断减小</span><br><br>    <span class="hljs-comment">// 相当于一个有间隔的插入排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i += gap) &#123;<br>      temp = array[i];<br>      <span class="hljs-keyword">let</span> j = i;<br>      <span class="hljs-keyword">while</span> (j &gt;= gap &amp;&amp; array[j - gap] &gt; temp) &#123;<br>        array[j] = array[j - gap];<br>        j -= gap;<br>      &#125;<br>      array[j] = temp;<br>    &#125;<br><br>    gap = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(gap / <span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序的基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p><img src="/images/algorithms/quick.gif" alt="快速排序"></p><p>代码实现：</p><p>简单版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr = []</span>) &#123;<br>  <span class="hljs-comment">// 当数组长度小于等于1时，直接返回数组</span><br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>  <span class="hljs-keyword">const</span> left = [];<br>  <span class="hljs-keyword">const</span> right = [];<br>  <span class="hljs-keyword">const</span> pivot = arr[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// 比指定值大的，推进右数组，否则推进左数组</span><br>    arr[i] &gt; pivot ? right.<span class="hljs-title function_">push</span>(arr[i]) : left.<span class="hljs-title function_">push</span>(arr[i]);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quickSort</span>(left), pivot, ...<span class="hljs-title function_">quickSort</span>(right)];<br>&#125;<br></code></pre></td></tr></table></figure><p>标准版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr = []</span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac必备神器——Homebrew</title>
    <link href="/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/"/>
    <url>/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/</url>
    
    <content type="html"><![CDATA[<p>你是否曾经：想安装某个软件，却发现 App Store 没有上架该软件（例如VS Code）🤬，然后需要进行：打开搜索引擎搜索进入官网、下载、安装、删除安装包……一系列烦人操作？如果是，看万这篇文章，相信你会直呼“<strong>相见恨晚🥺</strong>”</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 <a href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/" title="MacBook前端开发必备清单">MacBook前端开发必备清单</a> 中，本羊简要介绍了下 HomeBrew ，如果你没看过那篇文章，这里本羊再当一遍复读机：</p><blockquote><p><a href="https://brew.sh/index_zh-cn">Homebrew</a> 是一款用于 macOS 的开源的软件包管理器，能够帮助你快速下载软件。</p></blockquote><p>   <strong>那为什么要选Homebrew？</strong></p><p>   一般情况下，在 Mac 上安装软件程序，通常是在 Mac App Store 搜索，然后安装。但是，对于不在 Mac App Store 上架的软件，你需要：</p><ol><li><p>先在搜索引擎中搜索，找到官网，</p></li><li><p>然后打开下载页面下载，</p></li><li><p>最后再将下载的安装包拖到「软件程序」文件夹或执行安装。</p></li><li><p>清理安装包</p></li></ol><p>   这也太麻烦了吧😅😅😅</p><p>   而使用Homebrew，你只需要在终端输入一行命令，就可以解决包括查找、下载和安装软件的一系列步骤。</p><p>   例如安装Chrome浏览器，你只需在终端输入：</p><p>   <code>brew install google-chrome</code></p><p>   例如安装git：</p><p>   <code>brew install git</code></p><p>   是不是非常简单快捷？👏👏👏 不多啰嗦，直奔主题吧！</p><h2 id="安装及用法"><a href="#安装及用法" class="headerlink" title="安装及用法"></a>安装及用法</h2><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>在终端输入：</p><p><code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code></p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在以前，安装软件需要特意注明 <code>install cask</code> ，现在可以直接 <code>install</code> 想要安装的软件即可：</p><p><code>brew install 软件名</code></p><p>以安装强大的 IINA 播放器为例子，如下图：</p><p><img src="/images/brew-install.jpg" alt="安装 IINA"></p><p>tips: 安装的软件位于 usr&#x2F;local&#x2F;Caskroom 目录下。</p><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p><code>brew uninstall iina</code></p><p><img src="/images/brew-uninstall.jpg" alt="卸载 IINA"></p><h3 id="显示所有的已安装的软件"><a href="#显示所有的已安装的软件" class="headerlink" title="显示所有的已安装的软件"></a>显示所有的已安装的软件</h3><p><code>brew list</code></p><h3 id="升级homebrew-（从github下载最新版本）"><a href="#升级homebrew-（从github下载最新版本）" class="headerlink" title="升级homebrew （从github下载最新版本）"></a>升级homebrew （从github下载最新版本）</h3><p><code>brew update</code></p><p>更多 brew 命令及可安装的软件可查看 <a href="https://brew.sh/index_zh-cn">Homebrew</a> 官网。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>安装 Homebrew 以后，大幅提高了软件管理效率，告别了</p><blockquote><p>“要安装，请拖动此图标……”</p></blockquote><p>再也不再需要像以前一样进行繁琐的操作了~🥳</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>当 App Store 的微信版本还停留在2.6时，谁又想到在 Homebrew 上微信已经更新了3.0版本呢？😎</p><p><code>brew install wechat</code></p><p><img src="/images/wechat-tips.jpg" alt="微信 3.0"></p><p>既然是3.0版本，那就可以直接在电脑上刷朋友圈了！🤣</p><p><img src="/images/wechat-moment.jpg" alt="微信 朋友圈"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oh-My-Zsh中Git的常用快捷键</title>
    <link href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>每次使用Git都要输入太多重复内容？Oh-My-Zsh的Git捷键帮到你~🤩</p><span id="more"></span><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>下面将展示 Oh-My-Zsh 中 Git 的快捷键，第一部分的“常用快捷键”已经涵盖了日常大部分使用场景。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><table><thead><tr><th>快捷键</th><th align="left">完整写法</th></tr></thead><tbody><tr><td>g</td><td align="left">git</td></tr><tr><td>gaa</td><td align="left">git add .</td></tr><tr><td>gcmsg</td><td align="left">git commit -m</td></tr><tr><td>gcb</td><td align="left">git checkout -b</td></tr><tr><td>gst</td><td align="left">git status</td></tr><tr><td>gf</td><td align="left">git fetch</td></tr><tr><td>gl</td><td align="left">git pull</td></tr><tr><td>gup</td><td align="left">git pull –rebase</td></tr><tr><td>grb</td><td align="left">git rebase</td></tr><tr><td>gsta</td><td align="left">git stash save</td></tr><tr><td>gstp</td><td align="left">git stash pop</td></tr><tr><td>gcp</td><td align="left">git cherry-pick</td></tr><tr><td>mg</td><td align="left">git merge</td></tr><tr><td>gp</td><td align="left">git push</td></tr></tbody></table><h3 id="完整版快捷键"><a href="#完整版快捷键" class="headerlink" title="完整版快捷键"></a>完整版快捷键</h3><p>上面的常用快捷键已经涵盖日常大部分使用场景，如果你还需要更详尽的信息，可以查看Oh-My-Zsh官方GitHub的Git插件源码：</p><p><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/git.plugin.zsh">git.plugin.zsh</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>终端体验提升计划-iTerm2 + Oh-My-Zsh</title>
    <link href="/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/"/>
    <url>/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/</url>
    
    <content type="html"><![CDATA[<p>如何让你的终端用起来顺手又炫酷？看完本文，将让你的终端体验大幅提升😎</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/" title="MacBook前端开发必备清单">MacBook前端开发必备清单</a> 中展示了MacBook前端开发的必备清单，本文将介绍其一： <strong>iTerm2 + Oh-My-Zsh</strong></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol><li><p><a href="https://iterm2.com/">iTerm2</a></p><blockquote><p>iTerm2是默认终端的替代品，也是目前Mac系统下最好用的终端工具，集颜值和效率于一身。</p></blockquote></li><li><p><a href="https://ohmyz.sh/">Oh-My-Zsh</a></p><blockquote><p>Oh My Zsh 是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。 它基于Zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。它能让你用了直呼： <strong>“Oh My ZSH!” 🤣👏</strong> （它官网的确是这么说的哈哈哈哈）</p></blockquote></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>iTerm2</p><p>安装：</p><p>可以使用上一篇博客提到的Homebrew来安装：<code>brew install iterm2</code></p><p>也可以直接到 <a href="https://iterm2.com/">iTerm2</a> 官网下载</p></li><li><p>Oh-My-Zsh</p><p>安装：</p><p><code>sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></p></li></ol><h2 id="配置及使用"><a href="#配置及使用" class="headerlink" title="配置及使用"></a>配置及使用</h2><p>配置主题的前提：</p><blockquote><ol><li>安装了 zsh</li><li>安装了 powerline 字体</li><li>安装方法参考：<a href="https://github.com/powerline/fonts">https://github.com/powerline/fonts</a></li></ol></blockquote><ol><li><p>iTerm2</p><p>先设置字体：</p><p>进入偏好设置 -&gt; Profiles -&gt; Text -&gt; Font -&gt; 选择 <code>Meslo LG S for PowerLine</code></p></li><li><p>Oh-My-Zsh</p></li></ol><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>   打开zsh配置：<code>vim ~/.zshrc</code></p><p>   修改主题：<code>ZSH_THEME=&quot;agnoster&quot;</code> 个人觉得agnoster主题最好看😍</p><p>   生效：<code>source ~/.zshrc</code></p><p>   <img src="/images/theme-show.png" alt="agnoster主题展示及自动补全插件"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件有自带的Git，让你可以使用简写，如：</p><p><code>gaa</code> 就是 <code>git add --all</code></p><p>更多常用git快捷键可以看 <a href="/2021/04/05/04_Oh-My-Zsh%E4%B8%ADGit%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="Oh-My-Zsh中Git的常用快捷键">Oh-My-Zsh中Git的常用快捷键</a></p><p>此外，还强烈建议装上以下的插件：</p><ol><li><p>zsh-autosuggestion，命令建议和补全</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cd ~/.oh-my-zsh/custom/plugins/<br>git clone https://github.com/zsh-users/zsh-autosuggestions<br></code></pre></td></tr></table></figure></li><li><p>zsh-syntax-highlighting，代码高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">cd ~/.oh-my-zsh/custom/plugins/<br>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git<br></code></pre></td></tr></table></figure></li><li><p>z， 快速跳转到对应目录，让你不再疯狂输入cd</p><p>只要你输入过该路径，以后你便可以直接使用 <code>z 该目录</code> 直接进入该目录，如下：</p></li></ol><p>  <img src="/images/z.jpg" alt="z快速跳转"></p><p>   由于 <code>z</code> 是 zsh 内置的，所以只需在 plugins中加入 z 即可</p><p>输入 <code>vim ~/.zshrc</code> 进入 .zshrc ，按 <code>i</code> 进入编辑状态，找到plugins，输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs zsh">plugins=(<br>  git<br>  zsh-autosuggestions<br>  zsh-syntax-highlighting<br>  z<br>)<br></code></pre></td></tr></table></figure><p>然后在文件的最后一行添加：</p><p><code>source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></p><p>输入完成后，点击键盘<code>esc</code>键退出编辑模式，然后输入<code>:wq</code> 保存并退出，最后执行命令 <code>source ~/.zshrc</code> 使刚才的修改生效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过以上步骤，你拥有了：</p><ol><li>非常好看的终端</li><li>提高效率的插件：代码高亮、自动补全、快速路径跳转、Git命令快捷键</li></ol><p>快去试试吧😎</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacBook前端开发必备清单</title>
    <link href="/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/"/>
    <url>/2021/04/01/02_MacBook%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>当你使用一台MacBook进行前端开发时，有哪些软件或工具是 <strong>“装机必备”</strong>？</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本羊现在用的是16寸MacBook Pro，于2020年初购买，那为什么现在会想写一篇MacBook装机清单的博客呢？因为我上个月电脑主板突然坏了，然后去授权店修了2个星期，除了少数放在桌面的文件能被iCloud恢复，其余存储的内容全没了😭😭😭（以后一定要做好备份）。</p><p>然后我就得重新配置电脑的开发环境，于是就有了这一篇博客：MacBook前端开发必备清单。</p><p>目前电脑的系统是Big Sur 11.2.3，并已安装下面推荐的必备清单并运行良好，现在电脑用起来十分舒服。</p><p><strong>OK，正文开始！</strong></p><h2 id="前端开发必备清单"><a href="#前端开发必备清单" class="headerlink" title="前端开发必备清单"></a>前端开发必备清单</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ol><li><p><code>Git、Node、Yarn</code></p><p>最最基本必备的</p></li><li><p><code>VS Code</code></p><p>强推！刚入门前端的时候用的是Webstorm。一次偶然的机会用到了VS Code，一秒沦陷，各种插件太舒服了！如果一定要我从这么多插件中只选3样，那我必须推荐（太热门的就不特意推荐了哈哈哈）：</p><p><strong>Image preview</strong></p><p><strong>Git Graph</strong></p><p><strong>别名路径跳转</strong></p><p>PS: 一定要开启设置同步（登录后能自动同步设置、插件等），所以我能轻松在我个人笔记本和公司台式之间反复横跳开发。</p></li><li><p><code>Chrome</code></p><p>最强大的浏览器（没有之一😎），强烈推荐登录谷歌账号、安装扩展，强烈推荐以下扩展：</p><p><strong>Infinity Pro</strong>：超好看的首页</p><p><strong>uBlock Origin</strong>：过滤一切广告及干扰，让你清爽网上冲浪</p><p><strong>OneTab</strong>：有时候浏览器必须打开很多标签，但又不想关掉，OneTab就是必备的了，很方便，一键收纳标签，节省内存</p></li><li><p><code>Charles</code></p><p>抓包工具，方便移动端调试。</p></li></ol><h3 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h3><ol><li><p>iTerm2 和 oh-my-zsh</p><p>此神仙组合能让你的终端好用一万倍🤩🤩🤩，详细配置文章看这里：</p><a href="/2021/04/04/03_%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87%E8%AE%A1%E5%88%92-iTerm2-Oh-My-Zsh/" title="终端体验提升计划-iTerm2 + Oh-My-Zsh">终端体验提升计划-iTerm2 + Oh-My-Zsh</a></li><li><p><a href="https://brew.sh/index_zh-cn">Homebrew</a></p><p>HomeBrew 是一款用于 macOS 的开源的软件包管理器，能够帮助你快速下载软件。</p><p><strong>那为什么要选Homebrew？</strong></p><p>一般情况下，在 Mac 上安装软件程序，通常是在 Mac App Store 搜索，然后安装。但是，对于不在 Mac App Store 上架的软件，你需要：</p><ol><li><p>先在搜索引擎中搜索，找到官网，</p></li><li><p>然后打开下载页面下载，</p></li><li><p>最后再将下载的安装包拖到「软件程序」文件夹或执行安装。</p></li><li><p>清理安装包</p></li></ol><p>这也太麻烦了吧😅😅😅</p><p>而使用Homebrew，你只需要在终端输入一行命令，就可以解决包括查找、下载和安装软件的一系列步骤。</p><p>例如安装Chrome浏览器，你只需在终端输入：</p><p><code>brew install google-chrome</code></p><p>例如安装git：</p><p><code>brew install git</code></p><p>是不是非常简单快捷？👏👏👏</p><p>Homebrew的具体说明请看这里：</p><a href="/2021/04/06/05_Mac%E5%BF%85%E5%A4%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Homebrew/" title="Mac必备神器——Homebrew">Mac必备神器——Homebrew</a></li><li><p>Alfred</p><p>Alfred 是一款能让你提高效率的神器，它比Mac自带的“聚焦”有更强大的功能。它能：帮你快速打开网页、快速进行自定义搜索、查看剪贴板历史、快速查询单词等等。</p><p>Alfred 提供的功能虽然很多，但目的只有一个 —— 减少我们工作中的一些重复动作，提升我们的工作效率。</p><p>具体安装及使用请看这里：<a href="/2021/04/17/07_%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8%E2%80%94%E2%80%94Alfred/" title="效率神器——Alfred">效率神器——Alfred</a></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上的“必备清单”只是我个人的推荐，你可以根据自己喜好自行选择。例如上面的</p><blockquote><p>进阶配置</p></blockquote><p>如果不愿意折腾，其实可以忽略。平常使用原生终端及Mac自带的“聚焦”也足矣。但是如果你想提高开发体验，提交效率，那我还是建议你安装😋😋😋</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Mac</tag>
      
      <tag>记录</tag>
      
      <tag>前端</tag>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建指南（Hexo）</title>
    <link href="/2021/03/28/01_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/03/28/01_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><em><strong>如何搭建一个属于自己的在线博客呢？自动打包和部署如何实现？</strong></em> 🤩🤩🤩</p><span id="more"></span><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>在大学某一天，无意间看到了别人的博客网站，这个网站记录了他的学习历程、技术分享文章及日常感想等。当时我觉得这也太酷了吧，于是就萌生了一个搭建个属于自己的博客的想法~</p><p>想法虽然萌生了，但是我并没有立刻行动，一来是当时自己还是个学生，直接被服务器价格劝退了（当时也不知道 Github Pages 怎么用）；二是其实自己平常也有做笔记、做心得记录的习惯，只不过用的是云笔记，记录的知识点也比较任性杂乱（毕竟不用给他人阅读哈哈哈😂）。这样一来二去便作罢了。</p><p><img src="/images/stickers/WTF.jpeg" alt="当我看到服务器价格时"></p><p>但今天，我突然回想起来自己曾经的想法，这想法直接把我从床上拎起来，仿佛在催促我：“赶紧去把这个想法圆了！”</p><p>于是，我动手了。</p><h2 id="实现指南"><a href="#实现指南" class="headerlink" title="实现指南"></a>实现指南</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><p>本次搭建博客对比了 Hexo、VuePress、Gatsby 3款框架，最终选择了Hexo，因为<strong>主题多</strong>！🤩</p><p>首先确保电脑已经安装 node、npm、git，及已经注册了GitHub账号（需要用Github Pages），这里不赘述。</p><h4 id="安装Hexo脚手架"><a href="#安装Hexo脚手架" class="headerlink" title="安装Hexo脚手架"></a>安装Hexo脚手架</h4><p><code>sudo npm install hexo-cli -g</code> (若是window系统，则不用加sudo命令)</p><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p><code>hexo init blog</code></p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p><code>npm install</code></p><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p><code>hexo server</code></p><p>此时，项目已经能正常展示。</p><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>但是，默认主题并不好看，配一个符合自己审美的主题，例如我的是 <strong>Fluid</strong> (Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令)</p><p><code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 <strong>_config.fluid.yml</strong> ，将主题的 [_config.yml]。</p><p>打开 <strong>_config.yml</strong> 文件，可根据安装的主题修改对应的主题名称（theme）、语言（language）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h5 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h5><p>首次使用主题的「关于页」需要手动创建：</p><p><code>hexo new page about</code></p><p>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-03-28 20:54:55</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure><h3 id="使用-GitHub-Pages-实现博客在线访问"><a href="#使用-GitHub-Pages-实现博客在线访问" class="headerlink" title="使用 GitHub Pages 实现博客在线访问"></a>使用 <strong>GitHub Pages</strong> 实现博客在线访问</h3><h4 id="用GitHub部署站点有2种方式"><a href="#用GitHub部署站点有2种方式" class="headerlink" title="用GitHub部署站点有2种方式"></a>用GitHub部署站点有2种方式</h4><ol><li><p><code>https://[username].github.io</code> （适合博客😎）</p><p>优点：路径足够短</p><p>注意：仓库名必须为 <code>[username].github.io</code>；打包产物分支 <strong>master</strong></p></li><li><p><code>https://[username].github.io/[repo]</code> (适合作为开源项目或者Demo的展示页面)</p><p>优点：可以自定义仓库名称repo</p><p>注意：打包产物分支 <strong>gh-pages</strong></p></li></ol><p>建好仓库以后，使用Git初始化本地项目，并推送到远程仓库。</p><h4 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h4><ol><li><p>首先，我们需要安装一个依赖：<code>hexo-deployer-git</code>，它能帮助我们将代码部署到一个具体的分支。</p></li><li><p>安装好后，打开 <strong>_config.yml</strong> 文件，拉到底部，修改deploy配置，如下图 <img src="/images/deploy-setting.png" alt="deploy配置"></p></li><li><p>执行命令 <code>npm run deploy</code></p></li><li><p>打开GitHub，可以看到打包产物已经被提交到master分支上</p></li><li><p>打开仓库Setting，找到GitHub Pages，可以看到你部署的站点</p></li><li><p>点击链接，发现博客可以在线访问了！🥳🥳🥳</p></li></ol><h3 id="GitHub-Actions-自动化部署"><a href="#GitHub-Actions-自动化部署" class="headerlink" title="GitHub Actions 自动化部署"></a><strong>GitHub Actions</strong> 自动化部署</h3><p>好了，经过以上操作，我们已经拥有了一个属于自己的在线博客站点。</p><p>但是！有一个问题：<strong>我不想每次写完博客都要自己手动打包部署怎么办</strong>🥺？</p><p>正所谓，<del>懒是第一生产力（bushi）</del>，科技是第一生产力，GitHub Actions 帮助你。</p><p>我们可以利用 GitHub Actions 的<strong>自动打包和代码部署</strong>功能。</p><p>在此做自动化部署之前，由于master分支已经被占用，所以我们本地新建一个blog分支，提交代码并push到远程仓库。</p><h4 id="实现自动化部署步骤"><a href="#实现自动化部署步骤" class="headerlink" title="实现自动化部署步骤"></a>实现自动化部署步骤</h4><ol><li>根目录下创建 .github 文件夹，进入该文件夹并创建 workflows 文件夹</li><li>在 workflows 文件夹里创建一个 deploy.yml 文件，内部具体配置代码可以看这里：<a href="../../.github/workflows/deploy.yml">deploy.yml</a></li><li>提交代码，并push到远程仓库</li></ol><p>执行完Git push后，打开GitHub，可以看到blog分支右侧出现了一个小黄点，它代表 GitHub Actions 正在被触发，随后，博客被自动更新。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了！经过以上步骤，以后我们在blog分支上写完博客，本地无需执行打包和部署，只需提交代码，然后Git push即可，博客内容会被<strong>自动更新👏👏👏</strong></p><p>本羊的第一篇博客完工！<strong>🤣🤣🤣</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>记录</tag>
      
      <tag>博客</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
